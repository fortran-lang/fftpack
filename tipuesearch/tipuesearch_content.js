var tipuesearch = {"pages":[{"title":" Fortran-lang/fftpack ","text":"Fortran-lang/fftpack Fortran FFTPACK API Documentation FFTPACK Getting started Get the code Build with fortran-lang/fpm Build with CMake Build with Meson Documentation References Warning This API documentation for the Fortran-lang/fftpack is a work in progress. Fortran FFTPACK API Documentation This is the main API documentation landing page generated by FORD .\nThe documentation for comment markup in source code, running FORD and the FORD project file are all maintained on the FORD wiki . FFTPACK A package of Fortran subprograms for the fast Fourier transform of periodic and other symmetric sequences. Getting started Get the code git clone https://github.com/fortran-lang/fftpack.git cd fftpack Build with fortran-lang/fpm Fortran Package Manager (fpm) is a package manager and build system for Fortran. You can build using provided fpm.toml : fpm build\nfpm test --list\nfpm test <test_name, see ` fpm.toml ` or list> To use fftpack within your fpm project, add the following to your fpm.toml file: [dependencies] fftpack = { git = \"https://github.com/fortran-lang/fftpack.git\" } Build with CMake This library can also be built using CMake.  For instructions see Running CMake .  CMake version 3.24 or higher is required. Build with Meson This library can also be built using Meson. The following dependencies are required:\n- a Fortran compiler\n- meson version 0.57 or newer\n- a build-system backend, i.e. ninja version 1.7 or newer Setup a build with meson setup build You can select the Fortran compiler by the FC environment variable.\nTo compile and run the projects testsuite use meson test -C build --print-errorlogs If the testsuite passes you can install with meson configure build --prefix = /path/to/install\nmeson install -C build Documentation See the our GitHub Pages site for documentation generated by FORD from the fortran-lang/fftpack project file . References Although fortran-lang is not interface-compatible with any of the following libraries, each contains documentation that might be useful for different reasons: Recommended reference: The scipy.fftpack documentation contains succinct description of the storage sequences for function results that match those in fortran-lang/fftpack, e.g., the location of the real and imaginary parts of the rfft function result. Theory reference: The documentation for the GNU/gsl FFT routines , which are also based on netlib/fftpack, provides some useful definitions of FFT terminology and represenations of the analytical forms of the Discrete Fourier Transform nicely formatted by LaTeX . Historical reference: The netlib/fftpack library on which fortran-lang/fftpack is useful for understanding several fortran-lang/fftpack design choices, e.g., the procedure dependencies. Developer Info Paul N. Swarztrauber &\nfortran-lang/fftpack contributors","tags":"home","loc":"index.html"},{"title":"radf4 – Fortran-lang/fftpack","text":"subroutine radf4(ido, l1, cc, ch, wa1, wa2, wa3) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,l1,4) real(kind=dp), intent(out) :: ch (ido,4,l1) real(kind=dp), intent(in) :: wa1 (*) real(kind=dp), intent(in) :: wa2 (*) real(kind=dp), intent(in) :: wa3 (*) Contents Variables ci2 ci3 ci4 cr2 cr3 cr4 hsqt2 i ic idp2 k ti1 ti2 ti3 ti4 tr1 tr2 tr3 tr4 Source Code radf4 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: ci2 real(kind=dp), public :: ci3 real(kind=dp), public :: ci4 real(kind=dp), public :: cr2 real(kind=dp), public :: cr3 real(kind=dp), public :: cr4 real(kind=dp), public, parameter :: hsqt2 = sqrt(2.0_dp)/2.0_dp integer, public :: i integer, public :: ic integer, public :: idp2 integer, public :: k real(kind=dp), public :: ti1 real(kind=dp), public :: ti2 real(kind=dp), public :: ti3 real(kind=dp), public :: ti4 real(kind=dp), public :: tr1 real(kind=dp), public :: tr2 real(kind=dp), public :: tr3 real(kind=dp), public :: tr4 Source Code subroutine radf4 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , l1 , 4 ), wa1 ( * ), wa2 ( * ), wa3 ( * ) real ( dp ), intent ( out ) :: ch ( ido , 4 , l1 ) real ( dp ) :: ci2 , ci3 , ci4 , cr2 , cr3 , cr4 , & ti1 , ti2 , ti3 , ti4 , tr1 , tr2 , tr3 , & tr4 integer :: i , ic , idp2 , k real ( dp ), parameter :: hsqt2 = sqrt ( 2.0_dp ) / 2.0_dp do k = 1 , l1 tr1 = cc ( 1 , k , 2 ) + cc ( 1 , k , 4 ) tr2 = cc ( 1 , k , 1 ) + cc ( 1 , k , 3 ) ch ( 1 , 1 , k ) = tr1 + tr2 ch ( ido , 4 , k ) = tr2 - tr1 ch ( ido , 2 , k ) = cc ( 1 , k , 1 ) - cc ( 1 , k , 3 ) ch ( 1 , 3 , k ) = cc ( 1 , k , 4 ) - cc ( 1 , k , 2 ) end do if ( ido < 2 ) return if ( ido /= 2 ) then idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i cr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) ci2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) cr3 = wa2 ( i - 2 ) * cc ( i - 1 , k , 3 ) + wa2 ( i - 1 ) * cc ( i , k , 3 ) ci3 = wa2 ( i - 2 ) * cc ( i , k , 3 ) - wa2 ( i - 1 ) * cc ( i - 1 , k , 3 ) cr4 = wa3 ( i - 2 ) * cc ( i - 1 , k , 4 ) + wa3 ( i - 1 ) * cc ( i , k , 4 ) ci4 = wa3 ( i - 2 ) * cc ( i , k , 4 ) - wa3 ( i - 1 ) * cc ( i - 1 , k , 4 ) tr1 = cr2 + cr4 tr4 = cr4 - cr2 ti1 = ci2 + ci4 ti4 = ci2 - ci4 ti2 = cc ( i , k , 1 ) + ci3 ti3 = cc ( i , k , 1 ) - ci3 tr2 = cc ( i - 1 , k , 1 ) + cr3 tr3 = cc ( i - 1 , k , 1 ) - cr3 ch ( i - 1 , 1 , k ) = tr1 + tr2 ch ( ic - 1 , 4 , k ) = tr2 - tr1 ch ( i , 1 , k ) = ti1 + ti2 ch ( ic , 4 , k ) = ti1 - ti2 ch ( i - 1 , 3 , k ) = ti4 + tr3 ch ( ic - 1 , 2 , k ) = tr3 - ti4 ch ( i , 3 , k ) = tr4 + ti3 ch ( ic , 2 , k ) = tr4 - ti3 end do end do if ( mod ( ido , 2 ) == 1 ) return end if do k = 1 , l1 ti1 = - hsqt2 * ( cc ( ido , k , 2 ) + cc ( ido , k , 4 )) tr1 = hsqt2 * ( cc ( ido , k , 2 ) - cc ( ido , k , 4 )) ch ( ido , 1 , k ) = tr1 + cc ( ido , k , 1 ) ch ( ido , 3 , k ) = cc ( ido , k , 1 ) - tr1 ch ( 1 , 2 , k ) = ti1 - cc ( ido , k , 3 ) ch ( 1 , 4 , k ) = ti1 + cc ( ido , k , 3 ) end do end subroutine radf4","tags":"","loc":"proc/radf4.html"},{"title":"ezfft1 – Fortran-lang/fftpack","text":"subroutine ezfft1(n, wa, ifac) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(out) :: wa (*) integer, intent(out) :: ifac (*) Contents Variables arg1 argh ch1 ch1h dch1 dsh1 i ib ido ii ip ipm is j k1 l1 l2 nf nfm1 nl nq nr ntry ntryh sh1 tpi Source Code ezfft1 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: arg1 real(kind=dp), public :: argh real(kind=dp), public :: ch1 real(kind=dp), public :: ch1h real(kind=dp), public :: dch1 real(kind=dp), public :: dsh1 integer, public :: i integer, public :: ib integer, public :: ido integer, public :: ii integer, public :: ip integer, public :: ipm integer, public :: is integer, public :: j integer, public :: k1 integer, public :: l1 integer, public :: l2 integer, public :: nf integer, public :: nfm1 integer, public :: nl integer, public :: nq integer, public :: nr integer, public :: ntry integer, public, parameter,               dimension(4) :: ntryh = [4, 2, 3, 5] real(kind=dp), public :: sh1 real(kind=dp), public, parameter :: tpi = 2.0_dp*acos(-1.0_dp) Source Code subroutine ezfft1 ( n , wa , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wa ( * ) integer , intent ( out ) :: ifac ( * ) real ( dp ) :: arg1 , argh , ch1 , ch1h , dch1 , dsh1 , sh1 integer :: i , ib , ido , ii , ip , ipm , is , j , k1 , l1 , & l2 , nf , nfm1 , nl , nq , nr , ntry integer , dimension ( 4 ), parameter :: ntryh = [ 4 , 2 , 3 , 5 ] real ( dp ), parameter :: tpi = 2.0_dp * acos ( - 1.0_dp ) ! 2 * pi nl = n nf = 0 j = 0 100 j = j + 1 if ( j <= 4 ) then ntry = ntryh ( j ) else ntry = ntry + 2 end if 200 nq = nl / ntry nr = nl - ntry * nq if ( nr /= 0 ) goto 100 nf = nf + 1 ifac ( nf + 2 ) = ntry nl = nq if ( ntry == 2 ) then if ( nf /= 1 ) then do i = 2 , nf ib = nf - i + 2 ifac ( ib + 2 ) = ifac ( ib + 1 ) end do ifac ( 3 ) = 2 end if end if if ( nl /= 1 ) goto 200 ifac ( 1 ) = n ifac ( 2 ) = nf argh = tpi / real ( n , dp ) is = 0 nfm1 = nf - 1 l1 = 1 if ( nfm1 == 0 ) return do k1 = 1 , nfm1 ip = ifac ( k1 + 2 ) l2 = l1 * ip ido = n / l2 ipm = ip - 1 arg1 = real ( l1 , dp ) * argh ch1 = 1.0_dp sh1 = 0.0_dp dch1 = cos ( arg1 ) dsh1 = sin ( arg1 ) do j = 1 , ipm ch1h = dch1 * ch1 - dsh1 * sh1 sh1 = dch1 * sh1 + dsh1 * ch1 ch1 = ch1h i = is + 2 wa ( i - 1 ) = ch1 wa ( i ) = sh1 if ( ido >= 5 ) then do ii = 5 , ido , 2 i = i + 2 wa ( i - 1 ) = ch1 * wa ( i - 3 ) - sh1 * wa ( i - 2 ) wa ( i ) = ch1 * wa ( i - 2 ) + sh1 * wa ( i - 3 ) end do end if is = is + ido end do l1 = l2 end do end subroutine ezfft1","tags":"","loc":"proc/ezfft1.html"},{"title":"dsinqi – Fortran-lang/fftpack","text":"subroutine dsinqi(n, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(out) :: wsave (*) Contents Source Code dsinqi Source Code subroutine dsinqi ( n , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wsave ( * ) call dcosqi ( n , wsave ) end subroutine dsinqi","tags":"","loc":"proc/dsinqi.html"},{"title":"cffti1 – Fortran-lang/fftpack","text":"subroutine cffti1(n, wa, ifac) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(out) :: wa (*) integer, intent(out) :: ifac (*) Contents Variables arg argh argld fi i i1 ib ido idot ii ip ipm j k1 l1 l2 ld nf nl nq nr ntry ntryh tpi Source Code cffti1 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: arg real(kind=dp), public :: argh real(kind=dp), public :: argld real(kind=dp), public :: fi integer, public :: i integer, public :: i1 integer, public :: ib integer, public :: ido integer, public :: idot integer, public :: ii integer, public :: ip integer, public :: ipm integer, public :: j integer, public :: k1 integer, public :: l1 integer, public :: l2 integer, public :: ld integer, public :: nf integer, public :: nl integer, public :: nq integer, public :: nr integer, public :: ntry integer, public, parameter,               dimension(4) :: ntryh = [3, 4, 2, 5] real(kind=dp), public, parameter :: tpi = 2.0_dp*acos(-1.0_dp) Source Code subroutine cffti1 ( n , wa , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n integer , intent ( out ) :: ifac ( * ) real ( dp ), intent ( out ) :: wa ( * ) real ( dp ) :: arg , argh , argld , fi integer :: i , i1 , ib , ido , idot , ii , ip , ipm , j , k1 , & l1 , l2 , ld , nf , nl , nq , nr , ntry integer , dimension ( 4 ), parameter :: ntryh = [ 3 , 4 , 2 , 5 ] real ( dp ), parameter :: tpi = 2.0_dp * acos ( - 1.0_dp ) ! 2 * pi nl = n nf = 0 j = 0 100 j = j + 1 if ( j <= 4 ) then ntry = ntryh ( j ) else ntry = ntry + 2 end if 200 nq = nl / ntry nr = nl - ntry * nq if ( nr /= 0 ) goto 100 nf = nf + 1 ifac ( nf + 2 ) = ntry nl = nq if ( ntry == 2 ) then if ( nf /= 1 ) then do i = 2 , nf ib = nf - i + 2 ifac ( ib + 2 ) = ifac ( ib + 1 ) end do ifac ( 3 ) = 2 end if end if if ( nl /= 1 ) goto 200 ifac ( 1 ) = n ifac ( 2 ) = nf argh = tpi / real ( n , kind = dp ) i = 2 l1 = 1 do k1 = 1 , nf ip = ifac ( k1 + 2 ) ld = 0 l2 = l1 * ip ido = n / l2 idot = ido + ido + 2 ipm = ip - 1 do j = 1 , ipm i1 = i wa ( i - 1 ) = 1.0_dp wa ( i ) = 0.0_dp ld = ld + l1 fi = 0.0_dp argld = real ( ld , kind = dp ) * argh do ii = 4 , idot , 2 i = i + 2 fi = fi + 1.0_dp arg = fi * argld wa ( i - 1 ) = cos ( arg ) wa ( i ) = sin ( arg ) end do if ( ip > 5 ) then wa ( i1 - 1 ) = wa ( i - 1 ) wa ( i1 ) = wa ( i ) end if end do l1 = l2 end do end subroutine cffti1","tags":"","loc":"proc/cffti1.html"},{"title":"rfftf1 – Fortran-lang/fftpack","text":"subroutine rfftf1(n, c, ch, wa, ifac) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: c (*) real(kind=dp), intent(inout) :: ch (*) real(kind=dp), intent(in) :: wa (*) integer, intent(in) :: ifac (*) Contents Variables i idl1 ido ip iw ix2 ix3 ix4 k1 kh l1 l2 na nf Source Code rfftf1 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: idl1 integer, public :: ido integer, public :: ip integer, public :: iw integer, public :: ix2 integer, public :: ix3 integer, public :: ix4 integer, public :: k1 integer, public :: kh integer, public :: l1 integer, public :: l2 integer, public :: na integer, public :: nf Source Code subroutine rfftf1 ( n , c , ch , wa , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: c ( * ) real ( dp ), intent ( in ) :: wa ( * ) real ( dp ), intent ( inout ) :: ch ( * ) integer , intent ( in ) :: ifac ( * ) integer :: i , idl1 , ido , ip , iw , ix2 , ix3 , ix4 , k1 , & kh , l1 , l2 , na , nf nf = ifac ( 2 ) na = 1 l2 = n iw = n do k1 = 1 , nf kh = nf - k1 ip = ifac ( kh + 3 ) l1 = l2 / ip ido = n / l2 idl1 = ido * l1 iw = iw - ( ip - 1 ) * ido na = 1 - na if ( ip == 4 ) then ix2 = iw + ido ix3 = ix2 + ido if ( na /= 0 ) then call radf4 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 )) else call radf4 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 )) end if elseif ( ip /= 2 ) then if ( ip == 3 ) then ix2 = iw + ido if ( na /= 0 ) then call radf3 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 )) else call radf3 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 )) end if elseif ( ip /= 5 ) then if ( ido == 1 ) na = 1 - na if ( na /= 0 ) then call radfg ( ido , ip , l1 , idl1 , ch , ch , ch , c , c , wa ( iw )) na = 0 else call radfg ( ido , ip , l1 , idl1 , c , c , c , ch , ch , wa ( iw )) na = 1 end if else ix2 = iw + ido ix3 = ix2 + ido ix4 = ix3 + ido if ( na /= 0 ) then call radf5 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) else call radf5 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) end if end if elseif ( na /= 0 ) then call radf2 ( ido , l1 , ch , c , wa ( iw )) else call radf2 ( ido , l1 , c , ch , wa ( iw )) end if l2 = l1 end do if ( na == 1 ) return do i = 1 , n c ( i ) = ch ( i ) end do end subroutine rfftf1","tags":"","loc":"proc/rfftf1.html"},{"title":"dzfftf – Fortran-lang/fftpack","text":"subroutine dzfftf(n, r, azero, a, b, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(in) :: r (*) real(kind=dp), intent(out) :: azero real(kind=dp), intent(out) :: a (*) real(kind=dp), intent(out) :: b (*) real(kind=dp), intent(inout) :: wsave (*) Contents Variables cf cfm i ns2 ns2m Source Code dzfftf Variables Type Visibility Attributes Name Initial real(kind=dp), public :: cf real(kind=dp), public :: cfm integer, public :: i integer, public :: ns2 integer, public :: ns2m Source Code subroutine dzfftf ( n , r , azero , a , b , wsave ) !     version 3  june 1979 use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( in ) :: r ( * ) real ( dp ), intent ( out ) :: azero , a ( * ), b ( * ) real ( dp ), intent ( inout ) :: wsave ( * ) real ( dp ) :: cf , cfm integer :: i , ns2 , ns2m if ( n < 2 ) then azero = r ( 1 ) return elseif ( n == 2 ) then azero = 0.5_dp * ( r ( 1 ) + r ( 2 )) a ( 1 ) = 0.5_dp * ( r ( 1 ) - r ( 2 )) return else do i = 1 , n wsave ( i ) = r ( i ) end do call dfftf ( n , wsave , wsave ( n + 1 )) cf = 2.0_dp / real ( n , dp ) cfm = - cf azero = 0.5_dp * cf * wsave ( 1 ) ns2 = ( n + 1 ) / 2 ns2m = ns2 - 1 do i = 1 , ns2m a ( i ) = cf * wsave ( 2 * i ) b ( i ) = cfm * wsave ( 2 * i + 1 ) end do if ( mod ( n , 2 ) == 1 ) return a ( ns2 ) = 0.5_dp * cf * wsave ( n ) b ( ns2 ) = 0.0_dp end if end subroutine dzfftf","tags":"","loc":"proc/dzfftf.html"},{"title":"passf3 – Fortran-lang/fftpack","text":"subroutine passf3(ido, l1, cc, ch, wa1, wa2) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,3,l1) real(kind=dp), intent(out) :: ch (ido,l1,3) real(kind=dp), intent(in) :: wa1 (*) real(kind=dp), intent(in) :: wa2 (*) Contents Variables ci2 ci3 cr2 cr3 di2 di3 dr2 dr3 i k taui taur ti2 tr2 Source Code passf3 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: ci2 real(kind=dp), public :: ci3 real(kind=dp), public :: cr2 real(kind=dp), public :: cr3 real(kind=dp), public :: di2 real(kind=dp), public :: di3 real(kind=dp), public :: dr2 real(kind=dp), public :: dr3 integer, public :: i integer, public :: k real(kind=dp), public, parameter :: taui = -sqrt(3.0_dp)/2.0_dp real(kind=dp), public, parameter :: taur = -0.5_dp real(kind=dp), public :: ti2 real(kind=dp), public :: tr2 Source Code subroutine passf3 ( ido , l1 , cc , ch , wa1 , wa2 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 3 , l1 ), wa1 ( * ), wa2 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 3 ) real ( dp ) :: ci2 , ci3 , cr2 , cr3 , di2 , di3 , & & dr2 , dr3 , ti2 , tr2 integer :: i , k real ( dp ), parameter :: taur = - 0.5_dp real ( dp ), parameter :: taui = - sqrt ( 3.0_dp ) / 2.0_dp if ( ido /= 2 ) then do k = 1 , l1 do i = 2 , ido , 2 tr2 = cc ( i - 1 , 2 , k ) + cc ( i - 1 , 3 , k ) cr2 = cc ( i - 1 , 1 , k ) + taur * tr2 ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 ti2 = cc ( i , 2 , k ) + cc ( i , 3 , k ) ci2 = cc ( i , 1 , k ) + taur * ti2 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 cr3 = taui * ( cc ( i - 1 , 2 , k ) - cc ( i - 1 , 3 , k )) ci3 = taui * ( cc ( i , 2 , k ) - cc ( i , 3 , k )) dr2 = cr2 - ci3 dr3 = cr2 + ci3 di2 = ci2 + cr3 di3 = ci2 - cr3 ch ( i , k , 2 ) = wa1 ( i - 1 ) * di2 - wa1 ( i ) * dr2 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * dr2 + wa1 ( i ) * di2 ch ( i , k , 3 ) = wa2 ( i - 1 ) * di3 - wa2 ( i ) * dr3 ch ( i - 1 , k , 3 ) = wa2 ( i - 1 ) * dr3 + wa2 ( i ) * di3 end do end do else do k = 1 , l1 tr2 = cc ( 1 , 2 , k ) + cc ( 1 , 3 , k ) cr2 = cc ( 1 , 1 , k ) + taur * tr2 ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + tr2 ti2 = cc ( 2 , 2 , k ) + cc ( 2 , 3 , k ) ci2 = cc ( 2 , 1 , k ) + taur * ti2 ch ( 2 , k , 1 ) = cc ( 2 , 1 , k ) + ti2 cr3 = taui * ( cc ( 1 , 2 , k ) - cc ( 1 , 3 , k )) ci3 = taui * ( cc ( 2 , 2 , k ) - cc ( 2 , 3 , k )) ch ( 1 , k , 2 ) = cr2 - ci3 ch ( 1 , k , 3 ) = cr2 + ci3 ch ( 2 , k , 2 ) = ci2 + cr3 ch ( 2 , k , 3 ) = ci2 - cr3 end do end if end subroutine passf3","tags":"","loc":"proc/passf3.html"},{"title":"passf – Fortran-lang/fftpack","text":"subroutine passf(nac, ido, ip, l1, idl1, cc, c1, c2, ch, ch2, wa) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(out) :: nac integer, intent(in) :: ido integer, intent(in) :: ip integer, intent(in) :: l1 integer, intent(in) :: idl1 real(kind=dp), intent(in) :: cc (ido,ip,l1) real(kind=dp), intent(out) :: c1 (ido,l1,ip) real(kind=dp), intent(out) :: c2 (idl1,ip) real(kind=dp), intent(out) :: ch (ido,l1,ip) real(kind=dp), intent(inout) :: ch2 (idl1,ip) real(kind=dp), intent(in) :: wa (*) Contents Variables i idij idj idl idlj idot idp ik inc ipp2 ipph j jc k l lc nt wai war Source Code passf Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: idij integer, public :: idj integer, public :: idl integer, public :: idlj integer, public :: idot integer, public :: idp integer, public :: ik integer, public :: inc integer, public :: ipp2 integer, public :: ipph integer, public :: j integer, public :: jc integer, public :: k integer, public :: l integer, public :: lc integer, public :: nt real(kind=dp), public :: wai real(kind=dp), public :: war Source Code subroutine passf ( nac , ido , ip , l1 , idl1 , cc , c1 , c2 , ch , ch2 , wa ) use fftpack_kind , only : dp => rk implicit none integer , intent ( out ) :: nac integer , intent ( in ) :: ido , ip , l1 , idl1 real ( dp ), intent ( in ) :: cc ( ido , ip , l1 ), wa ( * ) real ( dp ), intent ( out ) :: c1 ( ido , l1 , ip ), c2 ( idl1 , ip ), ch ( ido , l1 , ip ) real ( dp ), intent ( inout ) :: ch2 ( idl1 , ip ) real ( dp ) :: wai , war integer :: i , idij , idj , idl , idlj , idot , idp , & ik , inc , ipp2 , ipph , j , jc , k , l , lc integer :: nt idot = ido / 2 nt = ip * idl1 ipp2 = ip + 2 ipph = ( ip + 1 ) / 2 idp = ip * ido ! if ( ido < l1 ) then do j = 2 , ipph jc = ipp2 - j do i = 1 , ido do k = 1 , l1 ch ( i , k , j ) = cc ( i , j , k ) + cc ( i , jc , k ) ch ( i , k , jc ) = cc ( i , j , k ) - cc ( i , jc , k ) end do end do end do do i = 1 , ido do k = 1 , l1 ch ( i , k , 1 ) = cc ( i , 1 , k ) end do end do else do j = 2 , ipph jc = ipp2 - j do k = 1 , l1 do i = 1 , ido ch ( i , k , j ) = cc ( i , j , k ) + cc ( i , jc , k ) ch ( i , k , jc ) = cc ( i , j , k ) - cc ( i , jc , k ) end do end do end do do k = 1 , l1 do i = 1 , ido ch ( i , k , 1 ) = cc ( i , 1 , k ) end do end do end if idl = 2 - ido inc = 0 do l = 2 , ipph lc = ipp2 - l idl = idl + ido do ik = 1 , idl1 c2 ( ik , l ) = ch2 ( ik , 1 ) + wa ( idl - 1 ) * ch2 ( ik , 2 ) c2 ( ik , lc ) = - wa ( idl ) * ch2 ( ik , ip ) end do idlj = idl inc = inc + ido do j = 3 , ipph jc = ipp2 - j idlj = idlj + inc if ( idlj > idp ) idlj = idlj - idp war = wa ( idlj - 1 ) wai = wa ( idlj ) do ik = 1 , idl1 c2 ( ik , l ) = c2 ( ik , l ) + war * ch2 ( ik , j ) c2 ( ik , lc ) = c2 ( ik , lc ) - wai * ch2 ( ik , jc ) end do end do end do do j = 2 , ipph do ik = 1 , idl1 ch2 ( ik , 1 ) = ch2 ( ik , 1 ) + ch2 ( ik , j ) end do end do do j = 2 , ipph jc = ipp2 - j do ik = 2 , idl1 , 2 ch2 ( ik - 1 , j ) = c2 ( ik - 1 , j ) - c2 ( ik , jc ) ch2 ( ik - 1 , jc ) = c2 ( ik - 1 , j ) + c2 ( ik , jc ) ch2 ( ik , j ) = c2 ( ik , j ) + c2 ( ik - 1 , jc ) ch2 ( ik , jc ) = c2 ( ik , j ) - c2 ( ik - 1 , jc ) end do end do nac = 1 if ( ido == 2 ) return nac = 0 do ik = 1 , idl1 c2 ( ik , 1 ) = ch2 ( ik , 1 ) end do do j = 2 , ip do k = 1 , l1 c1 ( 1 , k , j ) = ch ( 1 , k , j ) c1 ( 2 , k , j ) = ch ( 2 , k , j ) end do end do if ( idot > l1 ) then idj = 2 - ido do j = 2 , ip idj = idj + ido do k = 1 , l1 idij = idj do i = 4 , ido , 2 idij = idij + 2 c1 ( i - 1 , k , j ) = wa ( idij - 1 ) * ch ( i - 1 , k , j ) + wa ( idij ) & * ch ( i , k , j ) c1 ( i , k , j ) = wa ( idij - 1 ) * ch ( i , k , j ) - wa ( idij ) & * ch ( i - 1 , k , j ) end do end do end do else idij = 0 do j = 2 , ip idij = idij + 2 do i = 4 , ido , 2 idij = idij + 2 do k = 1 , l1 c1 ( i - 1 , k , j ) = wa ( idij - 1 ) * ch ( i - 1 , k , j ) + wa ( idij ) * ch ( i , k , j ) c1 ( i , k , j ) = wa ( idij - 1 ) * ch ( i , k , j ) - wa ( idij ) * ch ( i - 1 , k , j ) end do end do end do end if end subroutine passf","tags":"","loc":"proc/passf.html"},{"title":"passb3 – Fortran-lang/fftpack","text":"subroutine passb3(ido, l1, cc, ch, wa1, wa2) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,3,l1) real(kind=dp), intent(out) :: ch (ido,l1,3) real(kind=dp), intent(in) :: wa1 (*) real(kind=dp), intent(in) :: wa2 (*) Contents Variables ci2 ci3 cr2 cr3 di2 di3 dr2 dr3 i k taui taur ti2 tr2 Source Code passb3 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: ci2 real(kind=dp), public :: ci3 real(kind=dp), public :: cr2 real(kind=dp), public :: cr3 real(kind=dp), public :: di2 real(kind=dp), public :: di3 real(kind=dp), public :: dr2 real(kind=dp), public :: dr3 integer, public :: i integer, public :: k real(kind=dp), public, parameter :: taui = sqrt(3.0_dp)/2.0_dp real(kind=dp), public, parameter :: taur = -0.5_dp real(kind=dp), public :: ti2 real(kind=dp), public :: tr2 Source Code subroutine passb3 ( ido , l1 , cc , ch , wa1 , wa2 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 3 , l1 ), wa1 ( * ), wa2 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 3 ) real ( dp ) :: ci2 , ci3 , cr2 , cr3 , di2 , di3 , & dr2 , dr3 , ti2 , tr2 integer :: i , k real ( dp ), parameter :: taur = - 0.5_dp real ( dp ), parameter :: taui = sqrt ( 3.0_dp ) / 2.0_dp if ( ido /= 2 ) then do k = 1 , l1 do i = 2 , ido , 2 tr2 = cc ( i - 1 , 2 , k ) + cc ( i - 1 , 3 , k ) cr2 = cc ( i - 1 , 1 , k ) + taur * tr2 ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 ti2 = cc ( i , 2 , k ) + cc ( i , 3 , k ) ci2 = cc ( i , 1 , k ) + taur * ti2 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 cr3 = taui * ( cc ( i - 1 , 2 , k ) - cc ( i - 1 , 3 , k )) ci3 = taui * ( cc ( i , 2 , k ) - cc ( i , 3 , k )) dr2 = cr2 - ci3 dr3 = cr2 + ci3 di2 = ci2 + cr3 di3 = ci2 - cr3 ch ( i , k , 2 ) = wa1 ( i - 1 ) * di2 + wa1 ( i ) * dr2 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * dr2 - wa1 ( i ) * di2 ch ( i , k , 3 ) = wa2 ( i - 1 ) * di3 + wa2 ( i ) * dr3 ch ( i - 1 , k , 3 ) = wa2 ( i - 1 ) * dr3 - wa2 ( i ) * di3 end do end do else do k = 1 , l1 tr2 = cc ( 1 , 2 , k ) + cc ( 1 , 3 , k ) cr2 = cc ( 1 , 1 , k ) + taur * tr2 ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + tr2 ti2 = cc ( 2 , 2 , k ) + cc ( 2 , 3 , k ) ci2 = cc ( 2 , 1 , k ) + taur * ti2 ch ( 2 , k , 1 ) = cc ( 2 , 1 , k ) + ti2 cr3 = taui * ( cc ( 1 , 2 , k ) - cc ( 1 , 3 , k )) ci3 = taui * ( cc ( 2 , 2 , k ) - cc ( 2 , 3 , k )) ch ( 1 , k , 2 ) = cr2 - ci3 ch ( 1 , k , 3 ) = cr2 + ci3 ch ( 2 , k , 2 ) = ci2 + cr3 ch ( 2 , k , 3 ) = ci2 - cr3 end do end if end subroutine passb3","tags":"","loc":"proc/passb3.html"},{"title":"radb3 – Fortran-lang/fftpack","text":"subroutine radb3(ido, l1, cc, ch, wa1, wa2) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,3,l1) real(kind=dp), intent(out) :: ch (ido,l1,3) real(kind=dp), intent(in) :: wa1 (*) real(kind=dp), intent(in) :: wa2 (*) Contents Variables ci2 ci3 cr2 cr3 di2 di3 dr2 dr3 i ic idp2 k taui taur ti2 tr2 Source Code radb3 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: ci2 real(kind=dp), public :: ci3 real(kind=dp), public :: cr2 real(kind=dp), public :: cr3 real(kind=dp), public :: di2 real(kind=dp), public :: di3 real(kind=dp), public :: dr2 real(kind=dp), public :: dr3 integer, public :: i integer, public :: ic integer, public :: idp2 integer, public :: k real(kind=dp), public, parameter :: taui = sqrt(3.0_dp)/2.0_dp real(kind=dp), public, parameter :: taur = -0.5_dp real(kind=dp), public :: ti2 real(kind=dp), public :: tr2 Source Code subroutine radb3 ( ido , l1 , cc , ch , wa1 , wa2 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 3 , l1 ), wa1 ( * ), wa2 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 3 ) real ( dp ) :: ci2 , ci3 , cr2 , cr3 , di2 , di3 , & dr2 , dr3 , ti2 , tr2 integer :: i , ic , idp2 , k real ( dp ), parameter :: taur = - 0.5_dp real ( dp ), parameter :: taui = sqrt ( 3.0_dp ) / 2.0_dp do k = 1 , l1 tr2 = cc ( ido , 2 , k ) + cc ( ido , 2 , k ) cr2 = cc ( 1 , 1 , k ) + taur * tr2 ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + tr2 ci3 = taui * ( cc ( 1 , 3 , k ) + cc ( 1 , 3 , k )) ch ( 1 , k , 2 ) = cr2 - ci3 ch ( 1 , k , 3 ) = cr2 + ci3 end do if ( ido == 1 ) return idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i tr2 = cc ( i - 1 , 3 , k ) + cc ( ic - 1 , 2 , k ) cr2 = cc ( i - 1 , 1 , k ) + taur * tr2 ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 ti2 = cc ( i , 3 , k ) - cc ( ic , 2 , k ) ci2 = cc ( i , 1 , k ) + taur * ti2 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 cr3 = taui * ( cc ( i - 1 , 3 , k ) - cc ( ic - 1 , 2 , k )) ci3 = taui * ( cc ( i , 3 , k ) + cc ( ic , 2 , k )) dr2 = cr2 - ci3 dr3 = cr2 + ci3 di2 = ci2 + cr3 di3 = ci2 - cr3 ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * dr2 - wa1 ( i - 1 ) * di2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * di2 + wa1 ( i - 1 ) * dr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 2 ) * dr3 - wa2 ( i - 1 ) * di3 ch ( i , k , 3 ) = wa2 ( i - 2 ) * di3 + wa2 ( i - 1 ) * dr3 end do end do end subroutine radb3","tags":"","loc":"proc/radb3.html"},{"title":"dsinqb – Fortran-lang/fftpack","text":"subroutine dsinqb(n, x, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: x (*) real(kind=dp), intent(in) :: wsave (*) Contents Variables k kc ns2 xhold Source Code dsinqb Variables Type Visibility Attributes Name Initial integer, public :: k integer, public :: kc integer, public :: ns2 real(kind=dp), public :: xhold Source Code subroutine dsinqb ( n , x , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: x ( * ) real ( dp ), intent ( in ) :: wsave ( * ) integer :: k , kc , ns2 real ( dp ) :: xhold if ( n > 1 ) then ns2 = n / 2 do k = 2 , n , 2 x ( k ) = - x ( k ) end do call dcosqb ( n , x , wsave ) do k = 1 , ns2 kc = n - k xhold = x ( k ) x ( k ) = x ( kc + 1 ) x ( kc + 1 ) = xhold end do return end if x ( 1 ) = 4.0_dp * x ( 1 ) return end subroutine dsinqb","tags":"","loc":"proc/dsinqb.html"},{"title":"passf2 – Fortran-lang/fftpack","text":"subroutine passf2(ido, l1, cc, ch, wa1) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,2,l1) real(kind=dp), intent(out) :: ch (ido,l1,2) real(kind=dp), intent(in) :: wa1 (*) Contents Variables i k ti2 tr2 Source Code passf2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k real(kind=dp), public :: ti2 real(kind=dp), public :: tr2 Source Code subroutine passf2 ( ido , l1 , cc , ch , wa1 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 2 , l1 ), wa1 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 2 ) real ( dp ) :: ti2 , tr2 integer :: i , k if ( ido > 2 ) then do k = 1 , l1 do i = 2 , ido , 2 ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + cc ( i - 1 , 2 , k ) tr2 = cc ( i - 1 , 1 , k ) - cc ( i - 1 , 2 , k ) ch ( i , k , 1 ) = cc ( i , 1 , k ) + cc ( i , 2 , k ) ti2 = cc ( i , 1 , k ) - cc ( i , 2 , k ) ch ( i , k , 2 ) = wa1 ( i - 1 ) * ti2 - wa1 ( i ) * tr2 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * tr2 + wa1 ( i ) * ti2 end do end do else do k = 1 , l1 ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + cc ( 1 , 2 , k ) ch ( 1 , k , 2 ) = cc ( 1 , 1 , k ) - cc ( 1 , 2 , k ) ch ( 2 , k , 1 ) = cc ( 2 , 1 , k ) + cc ( 2 , 2 , k ) ch ( 2 , k , 2 ) = cc ( 2 , 1 , k ) - cc ( 2 , 2 , k ) end do end if end subroutine passf2","tags":"","loc":"proc/passf2.html"},{"title":"radb5 – Fortran-lang/fftpack","text":"subroutine radb5(ido, l1, cc, ch, wa1, wa2, wa3, wa4) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,5,l1) real(kind=dp), intent(out) :: ch (ido,l1,5) real(kind=dp), intent(in) :: wa1 (*) real(kind=dp), intent(in) :: wa2 (*) real(kind=dp), intent(in) :: wa3 (*) real(kind=dp), intent(in) :: wa4 (*) Contents Variables ci2 ci3 ci4 ci5 cr2 cr3 cr4 cr5 di2 di3 di4 di5 dr2 dr3 dr4 dr5 i ic idp2 k pi ti11 ti12 ti2 ti3 ti4 ti5 tr11 tr12 tr2 tr3 tr4 tr5 Source Code radb5 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: ci2 real(kind=dp), public :: ci3 real(kind=dp), public :: ci4 real(kind=dp), public :: ci5 real(kind=dp), public :: cr2 real(kind=dp), public :: cr3 real(kind=dp), public :: cr4 real(kind=dp), public :: cr5 real(kind=dp), public :: di2 real(kind=dp), public :: di3 real(kind=dp), public :: di4 real(kind=dp), public :: di5 real(kind=dp), public :: dr2 real(kind=dp), public :: dr3 real(kind=dp), public :: dr4 real(kind=dp), public :: dr5 integer, public :: i integer, public :: ic integer, public :: idp2 integer, public :: k real(kind=dp), public, parameter :: pi = acos(-1.0_dp) real(kind=dp), public, parameter :: ti11 = sin(2.0_dp*pi/5.0_dp) real(kind=dp), public, parameter :: ti12 = sin(4.0_dp*pi/5.0_dp) real(kind=dp), public :: ti2 real(kind=dp), public :: ti3 real(kind=dp), public :: ti4 real(kind=dp), public :: ti5 real(kind=dp), public, parameter :: tr11 = cos(2.0_dp*pi/5.0_dp) real(kind=dp), public, parameter :: tr12 = cos(4.0_dp*pi/5.0_dp) real(kind=dp), public :: tr2 real(kind=dp), public :: tr3 real(kind=dp), public :: tr4 real(kind=dp), public :: tr5 Source Code subroutine radb5 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 , wa4 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 5 , l1 ), wa1 ( * ), wa2 ( * ), wa3 ( * ), wa4 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 5 ) real ( dp ) :: ci2 , ci3 , ci4 , ci5 , cr2 , cr3 , & cr4 , cr5 , di2 , di3 , di4 , di5 , dr2 , dr3 , & dr4 , dr5 real ( dp ) :: ti2 , ti3 , ti4 , ti5 , tr2 , tr3 , & tr4 , tr5 integer :: i , ic , idp2 , k real ( dp ), parameter :: pi = acos ( - 1.0_dp ) real ( dp ), parameter :: tr11 = cos ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti11 = sin ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: tr12 = cos ( 4.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti12 = sin ( 4.0_dp * pi / 5.0_dp ) do k = 1 , l1 ti5 = cc ( 1 , 3 , k ) + cc ( 1 , 3 , k ) ti4 = cc ( 1 , 5 , k ) + cc ( 1 , 5 , k ) tr2 = cc ( ido , 2 , k ) + cc ( ido , 2 , k ) tr3 = cc ( ido , 4 , k ) + cc ( ido , 4 , k ) ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + tr2 + tr3 cr2 = cc ( 1 , 1 , k ) + tr11 * tr2 + tr12 * tr3 cr3 = cc ( 1 , 1 , k ) + tr12 * tr2 + tr11 * tr3 ci5 = ti11 * ti5 + ti12 * ti4 ci4 = ti12 * ti5 - ti11 * ti4 ch ( 1 , k , 2 ) = cr2 - ci5 ch ( 1 , k , 3 ) = cr3 - ci4 ch ( 1 , k , 4 ) = cr3 + ci4 ch ( 1 , k , 5 ) = cr2 + ci5 end do if ( ido == 1 ) return idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i ti5 = cc ( i , 3 , k ) + cc ( ic , 2 , k ) ti2 = cc ( i , 3 , k ) - cc ( ic , 2 , k ) ti4 = cc ( i , 5 , k ) + cc ( ic , 4 , k ) ti3 = cc ( i , 5 , k ) - cc ( ic , 4 , k ) tr5 = cc ( i - 1 , 3 , k ) - cc ( ic - 1 , 2 , k ) tr2 = cc ( i - 1 , 3 , k ) + cc ( ic - 1 , 2 , k ) tr4 = cc ( i - 1 , 5 , k ) - cc ( ic - 1 , 4 , k ) tr3 = cc ( i - 1 , 5 , k ) + cc ( ic - 1 , 4 , k ) ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 + tr3 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 + ti3 cr2 = cc ( i - 1 , 1 , k ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( i , 1 , k ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( i - 1 , 1 , k ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( i , 1 , k ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 dr3 = cr3 - ci4 dr4 = cr3 + ci4 di3 = ci3 + cr4 di4 = ci3 - cr4 dr5 = cr2 + ci5 dr2 = cr2 - ci5 di5 = ci2 - cr5 di2 = ci2 + cr5 ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * dr2 - wa1 ( i - 1 ) * di2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * di2 + wa1 ( i - 1 ) * dr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 2 ) * dr3 - wa2 ( i - 1 ) * di3 ch ( i , k , 3 ) = wa2 ( i - 2 ) * di3 + wa2 ( i - 1 ) * dr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 2 ) * dr4 - wa3 ( i - 1 ) * di4 ch ( i , k , 4 ) = wa3 ( i - 2 ) * di4 + wa3 ( i - 1 ) * dr4 ch ( i - 1 , k , 5 ) = wa4 ( i - 2 ) * dr5 - wa4 ( i - 1 ) * di5 ch ( i , k , 5 ) = wa4 ( i - 2 ) * di5 + wa4 ( i - 1 ) * dr5 end do end do end subroutine radb5","tags":"","loc":"proc/radb5.html"},{"title":"passf4 – Fortran-lang/fftpack","text":"subroutine passf4(ido, l1, cc, ch, wa1, wa2, wa3) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,4,l1) real(kind=dp), intent(out) :: ch (ido,l1,4) real(kind=dp), intent(in) :: wa1 (*) real(kind=dp), intent(in) :: wa2 (*) real(kind=dp), intent(in) :: wa3 (*) Contents Variables ci2 ci3 ci4 cr2 cr3 cr4 i k ti1 ti2 ti3 ti4 tr1 tr2 tr3 tr4 Source Code passf4 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: ci2 real(kind=dp), public :: ci3 real(kind=dp), public :: ci4 real(kind=dp), public :: cr2 real(kind=dp), public :: cr3 real(kind=dp), public :: cr4 integer, public :: i integer, public :: k real(kind=dp), public :: ti1 real(kind=dp), public :: ti2 real(kind=dp), public :: ti3 real(kind=dp), public :: ti4 real(kind=dp), public :: tr1 real(kind=dp), public :: tr2 real(kind=dp), public :: tr3 real(kind=dp), public :: tr4 Source Code subroutine passf4 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 4 , l1 ), wa1 ( * ), wa2 ( * ), wa3 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 4 ) real ( dp ) :: ci2 , ci3 , ci4 , cr2 , cr3 , cr4 , & & ti1 , ti2 , ti3 , ti4 , tr1 , tr2 , tr3 , tr4 integer :: i , k if ( ido /= 2 ) then do k = 1 , l1 do i = 2 , ido , 2 ti1 = cc ( i , 1 , k ) - cc ( i , 3 , k ) ti2 = cc ( i , 1 , k ) + cc ( i , 3 , k ) ti3 = cc ( i , 2 , k ) + cc ( i , 4 , k ) tr4 = cc ( i , 2 , k ) - cc ( i , 4 , k ) tr1 = cc ( i - 1 , 1 , k ) - cc ( i - 1 , 3 , k ) tr2 = cc ( i - 1 , 1 , k ) + cc ( i - 1 , 3 , k ) ti4 = cc ( i - 1 , 4 , k ) - cc ( i - 1 , 2 , k ) tr3 = cc ( i - 1 , 2 , k ) + cc ( i - 1 , 4 , k ) ch ( i - 1 , k , 1 ) = tr2 + tr3 cr3 = tr2 - tr3 ch ( i , k , 1 ) = ti2 + ti3 ci3 = ti2 - ti3 cr2 = tr1 + tr4 cr4 = tr1 - tr4 ci2 = ti1 + ti4 ci4 = ti1 - ti4 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * cr2 + wa1 ( i ) * ci2 ch ( i , k , 2 ) = wa1 ( i - 1 ) * ci2 - wa1 ( i ) * cr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 1 ) * cr3 + wa2 ( i ) * ci3 ch ( i , k , 3 ) = wa2 ( i - 1 ) * ci3 - wa2 ( i ) * cr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 1 ) * cr4 + wa3 ( i ) * ci4 ch ( i , k , 4 ) = wa3 ( i - 1 ) * ci4 - wa3 ( i ) * cr4 end do end do else do k = 1 , l1 ti1 = cc ( 2 , 1 , k ) - cc ( 2 , 3 , k ) ti2 = cc ( 2 , 1 , k ) + cc ( 2 , 3 , k ) tr4 = cc ( 2 , 2 , k ) - cc ( 2 , 4 , k ) ti3 = cc ( 2 , 2 , k ) + cc ( 2 , 4 , k ) tr1 = cc ( 1 , 1 , k ) - cc ( 1 , 3 , k ) tr2 = cc ( 1 , 1 , k ) + cc ( 1 , 3 , k ) ti4 = cc ( 1 , 4 , k ) - cc ( 1 , 2 , k ) tr3 = cc ( 1 , 2 , k ) + cc ( 1 , 4 , k ) ch ( 1 , k , 1 ) = tr2 + tr3 ch ( 1 , k , 3 ) = tr2 - tr3 ch ( 2 , k , 1 ) = ti2 + ti3 ch ( 2 , k , 3 ) = ti2 - ti3 ch ( 1 , k , 2 ) = tr1 + tr4 ch ( 1 , k , 4 ) = tr1 - tr4 ch ( 2 , k , 2 ) = ti1 + ti4 ch ( 2 , k , 4 ) = ti1 - ti4 end do end if end subroutine passf4","tags":"","loc":"proc/passf4.html"},{"title":"cfftf1 – Fortran-lang/fftpack","text":"subroutine cfftf1(n, c, ch, wa, ifac) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: c (*) real(kind=dp), intent(inout) :: ch (*) real(kind=dp), intent(in) :: wa (*) integer, intent(in) :: ifac (*) Contents Variables i idl1 ido idot ip iw ix2 ix3 ix4 k1 l1 l2 n2 na nac nf Source Code cfftf1 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: idl1 integer, public :: ido integer, public :: idot integer, public :: ip integer, public :: iw integer, public :: ix2 integer, public :: ix3 integer, public :: ix4 integer, public :: k1 integer, public :: l1 integer, public :: l2 integer, public :: n2 integer, public :: na integer, public :: nac integer, public :: nf Source Code subroutine cfftf1 ( n , c , ch , wa , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n , ifac ( * ) real ( dp ), intent ( inout ) :: c ( * ), ch ( * ) real ( dp ), intent ( in ) :: wa ( * ) integer :: i , idl1 , ido , idot , ip , iw , ix2 , ix3 , ix4 , & k1 , l1 , l2 , n2 , na , nac , nf nf = ifac ( 2 ) na = 0 l1 = 1 iw = 1 do k1 = 1 , nf ip = ifac ( k1 + 2 ) l2 = ip * l1 ido = n / l2 idot = ido + ido idl1 = idot * l1 if ( ip == 4 ) then ix2 = iw + idot ix3 = ix2 + idot if ( na /= 0 ) then call passf4 ( idot , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 )) else call passf4 ( idot , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 )) end if na = 1 - na elseif ( ip == 2 ) then if ( na /= 0 ) then call passf2 ( idot , l1 , ch , c , wa ( iw )) else call passf2 ( idot , l1 , c , ch , wa ( iw )) end if na = 1 - na elseif ( ip == 3 ) then ix2 = iw + idot if ( na /= 0 ) then call passf3 ( idot , l1 , ch , c , wa ( iw ), wa ( ix2 )) else call passf3 ( idot , l1 , c , ch , wa ( iw ), wa ( ix2 )) end if na = 1 - na elseif ( ip /= 5 ) then if ( na /= 0 ) then call passf ( nac , idot , ip , l1 , idl1 , ch , ch , ch , c , c , wa ( iw )) else call passf ( nac , idot , ip , l1 , idl1 , c , c , c , ch , ch , wa ( iw )) end if if ( nac /= 0 ) na = 1 - na else ix2 = iw + idot ix3 = ix2 + idot ix4 = ix3 + idot if ( na /= 0 ) then call passf5 ( idot , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) else call passf5 ( idot , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) end if na = 1 - na end if l1 = l2 iw = iw + ( ip - 1 ) * idot end do if ( na == 0 ) return n2 = n + n do i = 1 , n2 c ( i ) = ch ( i ) end do end subroutine cfftf1","tags":"","loc":"proc/cfftf1.html"},{"title":"radfg – Fortran-lang/fftpack","text":"subroutine radfg(ido, ip, l1, idl1, cc, c1, c2, ch, ch2, wa) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: ip integer, intent(in) :: l1 integer, intent(in) :: idl1 real(kind=dp), intent(inout) :: cc (ido,ip,l1) real(kind=dp), intent(inout) :: c1 (ido,l1,ip) real(kind=dp), intent(inout) :: c2 (idl1,ip) real(kind=dp), intent(out) :: ch (ido,l1,ip) real(kind=dp), intent(inout) :: ch2 (idl1,ip) real(kind=dp), intent(in) :: wa (*) Contents Variables ai1 ai2 ar1 ar1h ar2 ar2h arg dc2 dcp ds2 dsp i ic idij idp2 ik ipp2 ipph is j j2 jc k l lc nbd tpi Source Code radfg Variables Type Visibility Attributes Name Initial real(kind=dp), public :: ai1 real(kind=dp), public :: ai2 real(kind=dp), public :: ar1 real(kind=dp), public :: ar1h real(kind=dp), public :: ar2 real(kind=dp), public :: ar2h real(kind=dp), public :: arg real(kind=dp), public :: dc2 real(kind=dp), public :: dcp real(kind=dp), public :: ds2 real(kind=dp), public :: dsp integer, public :: i integer, public :: ic integer, public :: idij integer, public :: idp2 integer, public :: ik integer, public :: ipp2 integer, public :: ipph integer, public :: is integer, public :: j integer, public :: j2 integer, public :: jc integer, public :: k integer, public :: l integer, public :: lc integer, public :: nbd real(kind=dp), public, parameter :: tpi = 2.0_dp*acos(-1.0_dp) Source Code subroutine radfg ( ido , ip , l1 , idl1 , cc , c1 , c2 , ch , ch2 , wa ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , ip , l1 , idl1 real ( dp ), intent ( in ) :: wa ( * ) real ( dp ), intent ( inout ) :: cc ( ido , ip , l1 ) real ( dp ), intent ( inout ) :: c1 ( ido , l1 , ip ) real ( dp ), intent ( inout ) :: c2 ( idl1 , ip ) real ( dp ), intent ( out ) :: ch ( ido , l1 , ip ) real ( dp ), intent ( inout ) :: ch2 ( idl1 , ip ) real ( dp ) :: ai1 , ai2 , ar1 , ar1h , ar2 , ar2h , arg , & dc2 , dcp , ds2 , dsp integer :: i , ic , idij , idp2 , ik , ipp2 , & ipph , is , j , j2 , jc , k , l , lc , nbd real ( dp ), parameter :: tpi = 2.0_dp * acos ( - 1.0_dp ) ! 2 * pi arg = tpi / real ( ip , kind = dp ) dcp = cos ( arg ) dsp = sin ( arg ) ipph = ( ip + 1 ) / 2 ipp2 = ip + 2 idp2 = ido + 2 nbd = ( ido - 1 ) / 2 if ( ido == 1 ) then do ik = 1 , idl1 c2 ( ik , 1 ) = ch2 ( ik , 1 ) end do else do ik = 1 , idl1 ch2 ( ik , 1 ) = c2 ( ik , 1 ) end do do j = 2 , ip do k = 1 , l1 ch ( 1 , k , j ) = c1 ( 1 , k , j ) end do end do if ( nbd > l1 ) then is = - ido do j = 2 , ip is = is + ido do k = 1 , l1 idij = is do i = 3 , ido , 2 idij = idij + 2 ch ( i - 1 , k , j ) = wa ( idij - 1 ) * c1 ( i - 1 , k , j ) + wa ( idij ) & * c1 ( i , k , j ) ch ( i , k , j ) = wa ( idij - 1 ) * c1 ( i , k , j ) - wa ( idij ) & * c1 ( i - 1 , k , j ) end do end do end do else is = - ido do j = 2 , ip is = is + ido idij = is do i = 3 , ido , 2 idij = idij + 2 do k = 1 , l1 ch ( i - 1 , k , j ) = wa ( idij - 1 ) * c1 ( i - 1 , k , j ) + wa ( idij ) & * c1 ( i , k , j ) ch ( i , k , j ) = wa ( idij - 1 ) * c1 ( i , k , j ) - wa ( idij ) & * c1 ( i - 1 , k , j ) end do end do end do end if if ( nbd < l1 ) then do j = 2 , ipph jc = ipp2 - j do i = 3 , ido , 2 do k = 1 , l1 c1 ( i - 1 , k , j ) = ch ( i - 1 , k , j ) + ch ( i - 1 , k , jc ) c1 ( i - 1 , k , jc ) = ch ( i , k , j ) - ch ( i , k , jc ) c1 ( i , k , j ) = ch ( i , k , j ) + ch ( i , k , jc ) c1 ( i , k , jc ) = ch ( i - 1 , k , jc ) - ch ( i - 1 , k , j ) end do end do end do else do j = 2 , ipph jc = ipp2 - j do k = 1 , l1 do i = 3 , ido , 2 c1 ( i - 1 , k , j ) = ch ( i - 1 , k , j ) + ch ( i - 1 , k , jc ) c1 ( i - 1 , k , jc ) = ch ( i , k , j ) - ch ( i , k , jc ) c1 ( i , k , j ) = ch ( i , k , j ) + ch ( i , k , jc ) c1 ( i , k , jc ) = ch ( i - 1 , k , jc ) - ch ( i - 1 , k , j ) end do end do end do end if end if do j = 2 , ipph jc = ipp2 - j do k = 1 , l1 c1 ( 1 , k , j ) = ch ( 1 , k , j ) + ch ( 1 , k , jc ) c1 ( 1 , k , jc ) = ch ( 1 , k , jc ) - ch ( 1 , k , j ) end do end do ! ar1 = 1.0_dp ai1 = 0.0_dp do l = 2 , ipph lc = ipp2 - l ar1h = dcp * ar1 - dsp * ai1 ai1 = dcp * ai1 + dsp * ar1 ar1 = ar1h do ik = 1 , idl1 ch2 ( ik , l ) = c2 ( ik , 1 ) + ar1 * c2 ( ik , 2 ) ch2 ( ik , lc ) = ai1 * c2 ( ik , ip ) end do dc2 = ar1 ds2 = ai1 ar2 = ar1 ai2 = ai1 do j = 3 , ipph jc = ipp2 - j ar2h = dc2 * ar2 - ds2 * ai2 ai2 = dc2 * ai2 + ds2 * ar2 ar2 = ar2h do ik = 1 , idl1 ch2 ( ik , l ) = ch2 ( ik , l ) + ar2 * c2 ( ik , j ) ch2 ( ik , lc ) = ch2 ( ik , lc ) + ai2 * c2 ( ik , jc ) end do end do end do do j = 2 , ipph do ik = 1 , idl1 ch2 ( ik , 1 ) = ch2 ( ik , 1 ) + c2 ( ik , j ) end do end do ! if ( ido < l1 ) then do i = 1 , ido do k = 1 , l1 cc ( i , 1 , k ) = ch ( i , k , 1 ) end do end do else do k = 1 , l1 do i = 1 , ido cc ( i , 1 , k ) = ch ( i , k , 1 ) end do end do end if do j = 2 , ipph jc = ipp2 - j j2 = j + j do k = 1 , l1 cc ( ido , j2 - 2 , k ) = ch ( 1 , k , j ) cc ( 1 , j2 - 1 , k ) = ch ( 1 , k , jc ) end do end do if ( ido == 1 ) return if ( nbd < l1 ) then do j = 2 , ipph jc = ipp2 - j j2 = j + j do i = 3 , ido , 2 ic = idp2 - i do k = 1 , l1 cc ( i - 1 , j2 - 1 , k ) = ch ( i - 1 , k , j ) + ch ( i - 1 , k , jc ) cc ( ic - 1 , j2 - 2 , k ) = ch ( i - 1 , k , j ) - ch ( i - 1 , k , jc ) cc ( i , j2 - 1 , k ) = ch ( i , k , j ) + ch ( i , k , jc ) cc ( ic , j2 - 2 , k ) = ch ( i , k , jc ) - ch ( i , k , j ) end do end do end do else do j = 2 , ipph jc = ipp2 - j j2 = j + j do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i cc ( i - 1 , j2 - 1 , k ) = ch ( i - 1 , k , j ) + ch ( i - 1 , k , jc ) cc ( ic - 1 , j2 - 2 , k ) = ch ( i - 1 , k , j ) - ch ( i - 1 , k , jc ) cc ( i , j2 - 1 , k ) = ch ( i , k , j ) + ch ( i , k , jc ) cc ( ic , j2 - 2 , k ) = ch ( i , k , jc ) - ch ( i , k , j ) end do end do end do end if end subroutine radfg","tags":"","loc":"proc/radfg.html"},{"title":"zfftb – Fortran-lang/fftpack","text":"subroutine zfftb(n, c, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: c (*) real(kind=dp), intent(inout) :: wsave (*) Contents Variables iw1 iw2 Source Code zfftb Variables Type Visibility Attributes Name Initial integer, public :: iw1 integer, public :: iw2 Source Code subroutine zfftb ( n , c , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: c ( * ) real ( dp ), intent ( inout ) :: wsave ( * ) integer :: iw1 , iw2 if ( n == 1 ) return iw1 = n + n + 1 iw2 = iw1 + n + n call cfftb1 ( n , c , wsave , wsave ( iw1 ), wsave ( iw2 )) end subroutine zfftb","tags":"","loc":"proc/zfftb.html"},{"title":"passf5 – Fortran-lang/fftpack","text":"subroutine passf5(ido, l1, cc, ch, wa1, wa2, wa3, wa4) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,5,l1) real(kind=dp), intent(out) :: ch (ido,l1,5) real(kind=dp), intent(in) :: wa1 (*) real(kind=dp), intent(in) :: wa2 (*) real(kind=dp), intent(in) :: wa3 (*) real(kind=dp), intent(in) :: wa4 (*) Contents Variables ci2 ci3 ci4 ci5 cr2 cr3 cr4 cr5 di2 di3 di4 di5 dr2 dr3 dr4 dr5 i k pi ti11 ti12 ti2 ti3 ti4 ti5 tr11 tr12 tr2 tr3 tr4 tr5 Source Code passf5 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: ci2 real(kind=dp), public :: ci3 real(kind=dp), public :: ci4 real(kind=dp), public :: ci5 real(kind=dp), public :: cr2 real(kind=dp), public :: cr3 real(kind=dp), public :: cr4 real(kind=dp), public :: cr5 real(kind=dp), public :: di2 real(kind=dp), public :: di3 real(kind=dp), public :: di4 real(kind=dp), public :: di5 real(kind=dp), public :: dr2 real(kind=dp), public :: dr3 real(kind=dp), public :: dr4 real(kind=dp), public :: dr5 integer, public :: i integer, public :: k real(kind=dp), public, parameter :: pi = acos(-1.0_dp) real(kind=dp), public, parameter :: ti11 = -sin(2.0_dp*pi/5.0_dp) real(kind=dp), public, parameter :: ti12 = -sin(4.0_dp*pi/5.0_dp) real(kind=dp), public :: ti2 real(kind=dp), public :: ti3 real(kind=dp), public :: ti4 real(kind=dp), public :: ti5 real(kind=dp), public, parameter :: tr11 = cos(2.0_dp*pi/5.0_dp) real(kind=dp), public, parameter :: tr12 = cos(4.0_dp*pi/5.0_dp) real(kind=dp), public :: tr2 real(kind=dp), public :: tr3 real(kind=dp), public :: tr4 real(kind=dp), public :: tr5 Source Code subroutine passf5 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 , wa4 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 5 , l1 ), wa1 ( * ), wa2 ( * ), wa3 ( * ), wa4 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 5 ) real ( dp ) :: ci2 , ci3 , ci4 , ci5 , cr2 , cr3 , & cr4 , cr5 , di2 , di3 , di4 , di5 , dr2 , dr3 , & dr4 , dr5 real ( dp ) :: ti2 , ti3 , ti4 , ti5 , tr2 , tr3 , & tr4 , tr5 integer :: i , k real ( dp ), parameter :: pi = acos ( - 1.0_dp ) real ( dp ), parameter :: tr11 = cos ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti11 = - sin ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: tr12 = cos ( 4.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti12 = - sin ( 4.0_dp * pi / 5.0_dp ) if ( ido /= 2 ) then do k = 1 , l1 do i = 2 , ido , 2 ti5 = cc ( i , 2 , k ) - cc ( i , 5 , k ) ti2 = cc ( i , 2 , k ) + cc ( i , 5 , k ) ti4 = cc ( i , 3 , k ) - cc ( i , 4 , k ) ti3 = cc ( i , 3 , k ) + cc ( i , 4 , k ) tr5 = cc ( i - 1 , 2 , k ) - cc ( i - 1 , 5 , k ) tr2 = cc ( i - 1 , 2 , k ) + cc ( i - 1 , 5 , k ) tr4 = cc ( i - 1 , 3 , k ) - cc ( i - 1 , 4 , k ) tr3 = cc ( i - 1 , 3 , k ) + cc ( i - 1 , 4 , k ) ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 + tr3 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 + ti3 cr2 = cc ( i - 1 , 1 , k ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( i , 1 , k ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( i - 1 , 1 , k ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( i , 1 , k ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 dr3 = cr3 - ci4 dr4 = cr3 + ci4 di3 = ci3 + cr4 di4 = ci3 - cr4 dr5 = cr2 + ci5 dr2 = cr2 - ci5 di5 = ci2 - cr5 di2 = ci2 + cr5 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * dr2 + wa1 ( i ) * di2 ch ( i , k , 2 ) = wa1 ( i - 1 ) * di2 - wa1 ( i ) * dr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 1 ) * dr3 + wa2 ( i ) * di3 ch ( i , k , 3 ) = wa2 ( i - 1 ) * di3 - wa2 ( i ) * dr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 1 ) * dr4 + wa3 ( i ) * di4 ch ( i , k , 4 ) = wa3 ( i - 1 ) * di4 - wa3 ( i ) * dr4 ch ( i - 1 , k , 5 ) = wa4 ( i - 1 ) * dr5 + wa4 ( i ) * di5 ch ( i , k , 5 ) = wa4 ( i - 1 ) * di5 - wa4 ( i ) * dr5 end do end do else do k = 1 , l1 ti5 = cc ( 2 , 2 , k ) - cc ( 2 , 5 , k ) ti2 = cc ( 2 , 2 , k ) + cc ( 2 , 5 , k ) ti4 = cc ( 2 , 3 , k ) - cc ( 2 , 4 , k ) ti3 = cc ( 2 , 3 , k ) + cc ( 2 , 4 , k ) tr5 = cc ( 1 , 2 , k ) - cc ( 1 , 5 , k ) tr2 = cc ( 1 , 2 , k ) + cc ( 1 , 5 , k ) tr4 = cc ( 1 , 3 , k ) - cc ( 1 , 4 , k ) tr3 = cc ( 1 , 3 , k ) + cc ( 1 , 4 , k ) ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + tr2 + tr3 ch ( 2 , k , 1 ) = cc ( 2 , 1 , k ) + ti2 + ti3 cr2 = cc ( 1 , 1 , k ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( 2 , 1 , k ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( 1 , 1 , k ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( 2 , 1 , k ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 ch ( 1 , k , 2 ) = cr2 - ci5 ch ( 1 , k , 5 ) = cr2 + ci5 ch ( 2 , k , 2 ) = ci2 + cr5 ch ( 2 , k , 3 ) = ci3 + cr4 ch ( 1 , k , 3 ) = cr3 - ci4 ch ( 1 , k , 4 ) = cr3 + ci4 ch ( 2 , k , 4 ) = ci3 - cr4 ch ( 2 , k , 5 ) = ci2 - cr5 end do end if end subroutine passf5","tags":"","loc":"proc/passf5.html"},{"title":"passb4 – Fortran-lang/fftpack","text":"subroutine passb4(ido, l1, cc, ch, wa1, wa2, wa3) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,4,l1) real(kind=dp), intent(out) :: ch (ido,l1,4) real(kind=dp), intent(in) :: wa1 (*) real(kind=dp), intent(in) :: wa2 (*) real(kind=dp), intent(in) :: wa3 (*) Contents Variables ci2 ci3 ci4 cr2 cr3 cr4 i k ti1 ti2 ti3 ti4 tr1 tr2 tr3 tr4 Source Code passb4 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: ci2 real(kind=dp), public :: ci3 real(kind=dp), public :: ci4 real(kind=dp), public :: cr2 real(kind=dp), public :: cr3 real(kind=dp), public :: cr4 integer, public :: i integer, public :: k real(kind=dp), public :: ti1 real(kind=dp), public :: ti2 real(kind=dp), public :: ti3 real(kind=dp), public :: ti4 real(kind=dp), public :: tr1 real(kind=dp), public :: tr2 real(kind=dp), public :: tr3 real(kind=dp), public :: tr4 Source Code subroutine passb4 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 4 , l1 ), wa1 ( * ), wa2 ( * ), wa3 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 4 ) real ( dp ) :: ci2 , ci3 , ci4 , cr2 , cr3 , cr4 , & & ti1 , ti2 , ti3 , ti4 , tr1 , tr2 , tr3 , tr4 integer :: i , k if ( ido /= 2 ) then do k = 1 , l1 do i = 2 , ido , 2 ti1 = cc ( i , 1 , k ) - cc ( i , 3 , k ) ti2 = cc ( i , 1 , k ) + cc ( i , 3 , k ) ti3 = cc ( i , 2 , k ) + cc ( i , 4 , k ) tr4 = cc ( i , 4 , k ) - cc ( i , 2 , k ) tr1 = cc ( i - 1 , 1 , k ) - cc ( i - 1 , 3 , k ) tr2 = cc ( i - 1 , 1 , k ) + cc ( i - 1 , 3 , k ) ti4 = cc ( i - 1 , 2 , k ) - cc ( i - 1 , 4 , k ) tr3 = cc ( i - 1 , 2 , k ) + cc ( i - 1 , 4 , k ) ch ( i - 1 , k , 1 ) = tr2 + tr3 cr3 = tr2 - tr3 ch ( i , k , 1 ) = ti2 + ti3 ci3 = ti2 - ti3 cr2 = tr1 + tr4 cr4 = tr1 - tr4 ci2 = ti1 + ti4 ci4 = ti1 - ti4 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * cr2 - wa1 ( i ) * ci2 ch ( i , k , 2 ) = wa1 ( i - 1 ) * ci2 + wa1 ( i ) * cr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 1 ) * cr3 - wa2 ( i ) * ci3 ch ( i , k , 3 ) = wa2 ( i - 1 ) * ci3 + wa2 ( i ) * cr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 1 ) * cr4 - wa3 ( i ) * ci4 ch ( i , k , 4 ) = wa3 ( i - 1 ) * ci4 + wa3 ( i ) * cr4 end do end do else do k = 1 , l1 ti1 = cc ( 2 , 1 , k ) - cc ( 2 , 3 , k ) ti2 = cc ( 2 , 1 , k ) + cc ( 2 , 3 , k ) tr4 = cc ( 2 , 4 , k ) - cc ( 2 , 2 , k ) ti3 = cc ( 2 , 2 , k ) + cc ( 2 , 4 , k ) tr1 = cc ( 1 , 1 , k ) - cc ( 1 , 3 , k ) tr2 = cc ( 1 , 1 , k ) + cc ( 1 , 3 , k ) ti4 = cc ( 1 , 2 , k ) - cc ( 1 , 4 , k ) tr3 = cc ( 1 , 2 , k ) + cc ( 1 , 4 , k ) ch ( 1 , k , 1 ) = tr2 + tr3 ch ( 1 , k , 3 ) = tr2 - tr3 ch ( 2 , k , 1 ) = ti2 + ti3 ch ( 2 , k , 3 ) = ti2 - ti3 ch ( 1 , k , 2 ) = tr1 + tr4 ch ( 1 , k , 4 ) = tr1 - tr4 ch ( 2 , k , 2 ) = ti1 + ti4 ch ( 2 , k , 4 ) = ti1 - ti4 end do end if end subroutine passb4","tags":"","loc":"proc/passb4.html"},{"title":"dsinqf – Fortran-lang/fftpack","text":"subroutine dsinqf(n, x, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: x (*) real(kind=dp), intent(in) :: wsave (*) Contents Variables k kc ns2 xhold Source Code dsinqf Variables Type Visibility Attributes Name Initial integer, public :: k integer, public :: kc integer, public :: ns2 real(kind=dp), public :: xhold Source Code subroutine dsinqf ( n , x , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: x ( * ) real ( dp ), intent ( in ) :: wsave ( * ) integer :: k , kc , ns2 real ( dp ) :: xhold if ( n == 1 ) return ns2 = n / 2 do k = 1 , ns2 kc = n - k xhold = x ( k ) x ( k ) = x ( kc + 1 ) x ( kc + 1 ) = xhold end do call dcosqf ( n , x , wsave ) do k = 2 , n , 2 x ( k ) = - x ( k ) end do end subroutine dsinqf","tags":"","loc":"proc/dsinqf.html"},{"title":"zffti – Fortran-lang/fftpack","text":"subroutine zffti(n, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(out) :: wsave (*) Contents Variables iw1 iw2 Source Code zffti Variables Type Visibility Attributes Name Initial integer, public :: iw1 integer, public :: iw2 Source Code subroutine zffti ( n , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wsave ( * ) integer :: iw1 , iw2 if ( n == 1 ) return iw1 = n + n + 1 iw2 = iw1 + n + n call cffti1 ( n , wsave ( iw1 ), wsave ( iw2 )) end subroutine zffti","tags":"","loc":"proc/zffti.html"},{"title":"passb2 – Fortran-lang/fftpack","text":"subroutine passb2(ido, l1, cc, ch, wa1) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,2,l1) real(kind=dp), intent(out) :: ch (ido,l1,2) real(kind=dp), intent(in) :: wa1 (*) Contents Variables i k ti2 tr2 Source Code passb2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k real(kind=dp), public :: ti2 real(kind=dp), public :: tr2 Source Code subroutine passb2 ( ido , l1 , cc , ch , wa1 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 2 , l1 ), wa1 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 2 ) real ( dp ) :: ti2 , tr2 integer :: i , k if ( ido > 2 ) then do k = 1 , l1 do i = 2 , ido , 2 ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + cc ( i - 1 , 2 , k ) tr2 = cc ( i - 1 , 1 , k ) - cc ( i - 1 , 2 , k ) ch ( i , k , 1 ) = cc ( i , 1 , k ) + cc ( i , 2 , k ) ti2 = cc ( i , 1 , k ) - cc ( i , 2 , k ) ch ( i , k , 2 ) = wa1 ( i - 1 ) * ti2 + wa1 ( i ) * tr2 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * tr2 - wa1 ( i ) * ti2 end do end do else do k = 1 , l1 ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + cc ( 1 , 2 , k ) ch ( 1 , k , 2 ) = cc ( 1 , 1 , k ) - cc ( 1 , 2 , k ) ch ( 2 , k , 1 ) = cc ( 2 , 1 , k ) + cc ( 2 , 2 , k ) ch ( 2 , k , 2 ) = cc ( 2 , 1 , k ) - cc ( 2 , 2 , k ) end do end if end subroutine passb2","tags":"","loc":"proc/passb2.html"},{"title":"radb4 – Fortran-lang/fftpack","text":"subroutine radb4(ido, l1, cc, ch, wa1, wa2, wa3) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,4,l1) real(kind=dp), intent(out) :: ch (ido,l1,4) real(kind=dp), intent(in) :: wa1 (*) real(kind=dp), intent(in) :: wa2 (*) real(kind=dp), intent(in) :: wa3 (*) Contents Variables ci2 ci3 ci4 cr2 cr3 cr4 i ic idp2 k sqrt2 ti1 ti2 ti3 ti4 tr1 tr2 tr3 tr4 Source Code radb4 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: ci2 real(kind=dp), public :: ci3 real(kind=dp), public :: ci4 real(kind=dp), public :: cr2 real(kind=dp), public :: cr3 real(kind=dp), public :: cr4 integer, public :: i integer, public :: ic integer, public :: idp2 integer, public :: k real(kind=dp), public, parameter :: sqrt2 = sqrt(2.0_dp) real(kind=dp), public :: ti1 real(kind=dp), public :: ti2 real(kind=dp), public :: ti3 real(kind=dp), public :: ti4 real(kind=dp), public :: tr1 real(kind=dp), public :: tr2 real(kind=dp), public :: tr3 real(kind=dp), public :: tr4 Source Code subroutine radb4 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 4 , l1 ), wa1 ( * ), wa2 ( * ), wa3 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 4 ) real ( dp ) :: ci2 , ci3 , ci4 , cr2 , cr3 , cr4 , & ti1 , ti2 , ti3 , ti4 , tr1 , tr2 , tr3 , & tr4 integer :: i , ic , idp2 , k real ( dp ), parameter :: sqrt2 = sqrt ( 2.0_dp ) do k = 1 , l1 tr1 = cc ( 1 , 1 , k ) - cc ( ido , 4 , k ) tr2 = cc ( 1 , 1 , k ) + cc ( ido , 4 , k ) tr3 = cc ( ido , 2 , k ) + cc ( ido , 2 , k ) tr4 = cc ( 1 , 3 , k ) + cc ( 1 , 3 , k ) ch ( 1 , k , 1 ) = tr2 + tr3 ch ( 1 , k , 2 ) = tr1 - tr4 ch ( 1 , k , 3 ) = tr2 - tr3 ch ( 1 , k , 4 ) = tr1 + tr4 end do if ( ido < 2 ) return if ( ido /= 2 ) then idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i ti1 = cc ( i , 1 , k ) + cc ( ic , 4 , k ) ti2 = cc ( i , 1 , k ) - cc ( ic , 4 , k ) ti3 = cc ( i , 3 , k ) - cc ( ic , 2 , k ) tr4 = cc ( i , 3 , k ) + cc ( ic , 2 , k ) tr1 = cc ( i - 1 , 1 , k ) - cc ( ic - 1 , 4 , k ) tr2 = cc ( i - 1 , 1 , k ) + cc ( ic - 1 , 4 , k ) ti4 = cc ( i - 1 , 3 , k ) - cc ( ic - 1 , 2 , k ) tr3 = cc ( i - 1 , 3 , k ) + cc ( ic - 1 , 2 , k ) ch ( i - 1 , k , 1 ) = tr2 + tr3 cr3 = tr2 - tr3 ch ( i , k , 1 ) = ti2 + ti3 ci3 = ti2 - ti3 cr2 = tr1 - tr4 cr4 = tr1 + tr4 ci2 = ti1 + ti4 ci4 = ti1 - ti4 ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * cr2 - wa1 ( i - 1 ) * ci2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * ci2 + wa1 ( i - 1 ) * cr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 2 ) * cr3 - wa2 ( i - 1 ) * ci3 ch ( i , k , 3 ) = wa2 ( i - 2 ) * ci3 + wa2 ( i - 1 ) * cr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 2 ) * cr4 - wa3 ( i - 1 ) * ci4 ch ( i , k , 4 ) = wa3 ( i - 2 ) * ci4 + wa3 ( i - 1 ) * cr4 end do end do if ( mod ( ido , 2 ) == 1 ) return end if do k = 1 , l1 ti1 = cc ( 1 , 2 , k ) + cc ( 1 , 4 , k ) ti2 = cc ( 1 , 4 , k ) - cc ( 1 , 2 , k ) tr1 = cc ( ido , 1 , k ) - cc ( ido , 3 , k ) tr2 = cc ( ido , 1 , k ) + cc ( ido , 3 , k ) ch ( ido , k , 1 ) = tr2 + tr2 ch ( ido , k , 2 ) = sqrt2 * ( tr1 - ti1 ) ch ( ido , k , 3 ) = ti2 + ti2 ch ( ido , k , 4 ) = - sqrt2 * ( tr1 + ti1 ) end do end subroutine radb4","tags":"","loc":"proc/radb4.html"},{"title":"dcosqi – Fortran-lang/fftpack","text":"subroutine dcosqi(n, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(out) :: wsave (*) Contents Variables dt fk k pih Source Code dcosqi Variables Type Visibility Attributes Name Initial real(kind=dp), public :: dt real(kind=dp), public :: fk integer, public :: k real(kind=dp), public, parameter :: pih = acos(-1.0_dp)/2.0_dp Source Code subroutine dcosqi ( n , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wsave ( * ) real ( dp ) :: dt , fk integer :: k real ( dp ), parameter :: pih = acos ( - 1.0_dp ) / 2.0_dp ! pi / 2 dt = pih / real ( n , kind = dp ) fk = 0.0_dp do k = 1 , n fk = fk + 1.0_dp wsave ( k ) = cos ( fk * dt ) end do call dffti ( n , wsave ( n + 1 )) end subroutine dcosqi","tags":"","loc":"proc/dcosqi.html"},{"title":"radb2 – Fortran-lang/fftpack","text":"subroutine radb2(ido, l1, cc, ch, wa1) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,2,l1) real(kind=dp), intent(out) :: ch (ido,l1,2) real(kind=dp), intent(in) :: wa1 (*) Contents Variables i ic idp2 k ti2 tr2 Source Code radb2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ic integer, public :: idp2 integer, public :: k real(kind=dp), public :: ti2 real(kind=dp), public :: tr2 Source Code subroutine radb2 ( ido , l1 , cc , ch , wa1 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 2 , l1 ), wa1 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 2 ) real ( dp ) :: ti2 , tr2 integer :: i , ic , idp2 , k do k = 1 , l1 ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + cc ( ido , 2 , k ) ch ( 1 , k , 2 ) = cc ( 1 , 1 , k ) - cc ( ido , 2 , k ) end do if ( ido < 2 ) return if ( ido /= 2 ) then idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + cc ( ic - 1 , 2 , k ) tr2 = cc ( i - 1 , 1 , k ) - cc ( ic - 1 , 2 , k ) ch ( i , k , 1 ) = cc ( i , 1 , k ) - cc ( ic , 2 , k ) ti2 = cc ( i , 1 , k ) + cc ( ic , 2 , k ) ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * tr2 - wa1 ( i - 1 ) * ti2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * ti2 + wa1 ( i - 1 ) * tr2 end do end do if ( mod ( ido , 2 ) == 1 ) return end if do k = 1 , l1 ch ( ido , k , 1 ) = cc ( ido , 1 , k ) + cc ( ido , 1 , k ) ch ( ido , k , 2 ) = - ( cc ( 1 , 2 , k ) + cc ( 1 , 2 , k )) end do end subroutine radb2","tags":"","loc":"proc/radb2.html"},{"title":"radf3 – Fortran-lang/fftpack","text":"subroutine radf3(ido, l1, cc, ch, wa1, wa2) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,l1,3) real(kind=dp), intent(out) :: ch (ido,3,l1) real(kind=dp), intent(in) :: wa1 (*) real(kind=dp), intent(in) :: wa2 (*) Contents Variables ci2 cr2 di2 di3 dr2 dr3 i ic idp2 k taui taur ti2 ti3 tr2 tr3 Source Code radf3 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: ci2 real(kind=dp), public :: cr2 real(kind=dp), public :: di2 real(kind=dp), public :: di3 real(kind=dp), public :: dr2 real(kind=dp), public :: dr3 integer, public :: i integer, public :: ic integer, public :: idp2 integer, public :: k real(kind=dp), public, parameter :: taui = sqrt(3.0_dp)/2.0_dp real(kind=dp), public, parameter :: taur = -0.5_dp real(kind=dp), public :: ti2 real(kind=dp), public :: ti3 real(kind=dp), public :: tr2 real(kind=dp), public :: tr3 Source Code subroutine radf3 ( ido , l1 , cc , ch , wa1 , wa2 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , l1 , 3 ), wa1 ( * ), wa2 ( * ) real ( dp ), intent ( out ) :: ch ( ido , 3 , l1 ) real ( dp ) :: ci2 , cr2 , di2 , di3 , dr2 , dr3 , & ti2 , ti3 , tr2 , tr3 integer :: i , ic , idp2 , k real ( dp ), parameter :: taur = - 0.5_dp ! note: original comment said this was -sqrt(3)/2 but value was 0.86602540378443864676d0 real ( dp ), parameter :: taui = sqrt ( 3.0_dp ) / 2.0_dp do k = 1 , l1 cr2 = cc ( 1 , k , 2 ) + cc ( 1 , k , 3 ) ch ( 1 , 1 , k ) = cc ( 1 , k , 1 ) + cr2 ch ( 1 , 3 , k ) = taui * ( cc ( 1 , k , 3 ) - cc ( 1 , k , 2 )) ch ( ido , 2 , k ) = cc ( 1 , k , 1 ) + taur * cr2 end do if ( ido == 1 ) return idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i dr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) di2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) dr3 = wa2 ( i - 2 ) * cc ( i - 1 , k , 3 ) + wa2 ( i - 1 ) * cc ( i , k , 3 ) di3 = wa2 ( i - 2 ) * cc ( i , k , 3 ) - wa2 ( i - 1 ) * cc ( i - 1 , k , 3 ) cr2 = dr2 + dr3 ci2 = di2 + di3 ch ( i - 1 , 1 , k ) = cc ( i - 1 , k , 1 ) + cr2 ch ( i , 1 , k ) = cc ( i , k , 1 ) + ci2 tr2 = cc ( i - 1 , k , 1 ) + taur * cr2 ti2 = cc ( i , k , 1 ) + taur * ci2 tr3 = taui * ( di2 - di3 ) ti3 = taui * ( dr3 - dr2 ) ch ( i - 1 , 3 , k ) = tr2 + tr3 ch ( ic - 1 , 2 , k ) = tr2 - tr3 ch ( i , 3 , k ) = ti2 + ti3 ch ( ic , 2 , k ) = ti3 - ti2 end do end do end subroutine radf3","tags":"","loc":"proc/radf3.html"},{"title":"zfftf – Fortran-lang/fftpack","text":"subroutine zfftf(n, c, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: c (*) real(kind=dp), intent(inout) :: wsave (*) Contents Variables iw1 iw2 Source Code zfftf Variables Type Visibility Attributes Name Initial integer, public :: iw1 integer, public :: iw2 Source Code subroutine zfftf ( n , c , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: c ( * ) real ( dp ), intent ( inout ) :: wsave ( * ) integer :: iw1 , iw2 if ( n == 1 ) return iw1 = n + n + 1 iw2 = iw1 + n + n call cfftf1 ( n , c , wsave , wsave ( iw1 ), wsave ( iw2 )) end subroutine zfftf","tags":"","loc":"proc/zfftf.html"},{"title":"radf2 – Fortran-lang/fftpack","text":"subroutine radf2(ido, l1, cc, ch, wa1) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,l1,2) real(kind=dp), intent(out) :: ch (ido,2,l1) real(kind=dp), intent(in) :: wa1 (*) Contents Variables i ic idp2 k ti2 tr2 Source Code radf2 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ic integer, public :: idp2 integer, public :: k real(kind=dp), public :: ti2 real(kind=dp), public :: tr2 Source Code subroutine radf2 ( ido , l1 , cc , ch , wa1 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , l1 , 2 ), wa1 ( * ) real ( dp ), intent ( out ) :: ch ( ido , 2 , l1 ) real ( dp ) :: ti2 , tr2 integer :: i , ic , idp2 , k do k = 1 , l1 ch ( 1 , 1 , k ) = cc ( 1 , k , 1 ) + cc ( 1 , k , 2 ) ch ( ido , 2 , k ) = cc ( 1 , k , 1 ) - cc ( 1 , k , 2 ) end do if ( ido < 2 ) return if ( ido /= 2 ) then idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i tr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) ti2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) ch ( i , 1 , k ) = cc ( i , k , 1 ) + ti2 ch ( ic , 2 , k ) = ti2 - cc ( i , k , 1 ) ch ( i - 1 , 1 , k ) = cc ( i - 1 , k , 1 ) + tr2 ch ( ic - 1 , 2 , k ) = cc ( i - 1 , k , 1 ) - tr2 end do end do if ( mod ( ido , 2 ) == 1 ) return end if do k = 1 , l1 ch ( 1 , 2 , k ) = - cc ( ido , k , 2 ) ch ( ido , 1 , k ) = cc ( ido , k , 1 ) end do end subroutine radf2","tags":"","loc":"proc/radf2.html"},{"title":"dffti – Fortran-lang/fftpack","text":"subroutine dffti(n, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(out) :: wsave (*) Contents Source Code dffti Source Code subroutine dffti ( n , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wsave ( * ) if ( n == 1 ) return call rffti1 ( n , wsave ( n + 1 ), wsave ( 2 * n + 1 )) end subroutine dffti","tags":"","loc":"proc/dffti.html"},{"title":"sint1 – Fortran-lang/fftpack","text":"subroutine sint1(n, war, was, xh, x, ifac) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: war (*) real(kind=dp), intent(in) :: was (*) real(kind=dp), intent(out) :: xh (*) real(kind=dp), intent(inout) :: x (*) integer, intent(in) :: ifac (*) Contents Variables i k kc modn np1 ns2 sqrt3 t1 t2 xhold Source Code sint1 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: kc integer, public :: modn integer, public :: np1 integer, public :: ns2 real(kind=dp), public, parameter :: sqrt3 = sqrt(3.0_dp) real(kind=dp), public :: t1 real(kind=dp), public :: t2 real(kind=dp), public :: xhold Source Code subroutine sint1 ( n , war , was , xh , x , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n , ifac ( * ) real ( dp ), intent ( in ) :: was ( * ) real ( dp ), intent ( inout ) :: war ( * ), x ( * ) real ( dp ), intent ( out ) :: xh ( * ) integer :: i , k , kc , modn , np1 , ns2 real ( dp ) :: t1 , t2 , xhold real ( dp ), parameter :: sqrt3 = sqrt ( 3.0_dp ) do i = 1 , n xh ( i ) = war ( i ) war ( i ) = x ( i ) end do if ( n < 2 ) then xh ( 1 ) = xh ( 1 ) + xh ( 1 ) elseif ( n == 2 ) then xhold = sqrt3 * ( xh ( 1 ) + xh ( 2 )) xh ( 2 ) = sqrt3 * ( xh ( 1 ) - xh ( 2 )) xh ( 1 ) = xhold else np1 = n + 1 ns2 = n / 2 x ( 1 ) = 0.0_dp do k = 1 , ns2 kc = np1 - k t1 = xh ( k ) - xh ( kc ) t2 = was ( k ) * ( xh ( k ) + xh ( kc )) x ( k + 1 ) = t1 + t2 x ( kc + 1 ) = t2 - t1 end do modn = mod ( n , 2 ) if ( modn /= 0 ) x ( ns2 + 2 ) = 4.0_dp * xh ( ns2 + 1 ) call rfftf1 ( np1 , x , xh , war , ifac ) xh ( 1 ) = 0.5_dp * x ( 1 ) do i = 3 , n , 2 xh ( i - 1 ) = - x ( i ) xh ( i ) = xh ( i - 2 ) + x ( i - 1 ) end do if ( modn == 0 ) xh ( n ) = - x ( n + 1 ) end if do i = 1 , n x ( i ) = war ( i ) war ( i ) = xh ( i ) end do end subroutine sint1","tags":"","loc":"proc/sint1.html"},{"title":"dzffti – Fortran-lang/fftpack","text":"subroutine dzffti(n, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(out) :: wsave (*) Contents Source Code dzffti Source Code subroutine dzffti ( n , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wsave ( * ) if ( n == 1 ) return call ezfft1 ( n , wsave ( 2 * n + 1 ), wsave ( 3 * n + 1 )) end subroutine dzffti","tags":"","loc":"proc/dzffti.html"},{"title":"dcost – Fortran-lang/fftpack","text":"subroutine dcost(n, x, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(inout) :: x (*) real(kind=rk), intent(inout) :: wsave (*) Contents Variables c1 i k kc modn nm1 np1 ns2 t1 t2 tx2 x1h x1p3 xi xim2 Source Code dcost Variables Type Visibility Attributes Name Initial real(kind=rk), public :: c1 integer, public :: i integer, public :: k integer, public :: kc integer, public :: modn integer, public :: nm1 integer, public :: np1 integer, public :: ns2 real(kind=rk), public :: t1 real(kind=rk), public :: t2 real(kind=rk), public :: tx2 real(kind=rk), public :: x1h real(kind=rk), public :: x1p3 real(kind=rk), public :: xi real(kind=rk), public :: xim2 Source Code subroutine dcost ( n , x , wsave ) use fftpack_kind , only : rk implicit none integer , intent ( in ) :: n real ( rk ), intent ( inout ) :: wsave ( * ) real ( rk ), intent ( inout ) :: x ( * ) real ( rk ) :: c1 , t1 , t2 , tx2 , x1h , x1p3 , & xi , xim2 integer :: i , k , kc , modn , nm1 , np1 , ns2 nm1 = n - 1 np1 = n + 1 ns2 = n / 2 if ( n < 2 ) return if ( n == 2 ) then x1h = x ( 1 ) + x ( 2 ) x ( 2 ) = x ( 1 ) - x ( 2 ) x ( 1 ) = x1h return elseif ( n > 3 ) then c1 = x ( 1 ) - x ( n ) x ( 1 ) = x ( 1 ) + x ( n ) do k = 2 , ns2 kc = np1 - k t1 = x ( k ) + x ( kc ) t2 = x ( k ) - x ( kc ) c1 = c1 + wsave ( kc ) * t2 t2 = wsave ( k ) * t2 x ( k ) = t1 - t2 x ( kc ) = t1 + t2 end do modn = mod ( n , 2 ) if ( modn /= 0 ) x ( ns2 + 1 ) = x ( ns2 + 1 ) + x ( ns2 + 1 ) call dfftf ( nm1 , x , wsave ( n + 1 )) xim2 = x ( 2 ) x ( 2 ) = c1 do i = 4 , n , 2 xi = x ( i ) x ( i ) = x ( i - 2 ) - x ( i - 1 ) x ( i - 1 ) = xim2 xim2 = xi end do if ( modn /= 0 ) x ( n ) = xim2 return end if x1p3 = x ( 1 ) + x ( 3 ) tx2 = x ( 2 ) + x ( 2 ) x ( 2 ) = x ( 1 ) - x ( 3 ) x ( 1 ) = x1p3 + tx2 x ( 3 ) = x1p3 - tx2 end subroutine dcost","tags":"","loc":"proc/dcost.html"},{"title":"passb5 – Fortran-lang/fftpack","text":"subroutine passb5(ido, l1, cc, ch, wa1, wa2, wa3, wa4) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,5,l1) real(kind=dp), intent(out) :: ch (ido,l1,5) real(kind=dp), intent(in) :: wa1 (*) real(kind=dp), intent(in) :: wa2 (*) real(kind=dp), intent(in) :: wa3 (*) real(kind=dp), intent(in) :: wa4 (*) Contents Variables ci2 ci3 ci4 ci5 cr2 cr3 cr4 cr5 di2 di3 di4 di5 dr2 dr3 dr4 dr5 i k pi ti11 ti12 ti2 ti3 ti4 ti5 tr11 tr12 tr2 tr3 tr4 tr5 Source Code passb5 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: ci2 real(kind=dp), public :: ci3 real(kind=dp), public :: ci4 real(kind=dp), public :: ci5 real(kind=dp), public :: cr2 real(kind=dp), public :: cr3 real(kind=dp), public :: cr4 real(kind=dp), public :: cr5 real(kind=dp), public :: di2 real(kind=dp), public :: di3 real(kind=dp), public :: di4 real(kind=dp), public :: di5 real(kind=dp), public :: dr2 real(kind=dp), public :: dr3 real(kind=dp), public :: dr4 real(kind=dp), public :: dr5 integer, public :: i integer, public :: k real(kind=dp), public, parameter :: pi = acos(-1.0_dp) real(kind=dp), public, parameter :: ti11 = sin(2.0_dp*pi/5.0_dp) real(kind=dp), public, parameter :: ti12 = sin(4.0_dp*pi/5.0_dp) real(kind=dp), public :: ti2 real(kind=dp), public :: ti3 real(kind=dp), public :: ti4 real(kind=dp), public :: ti5 real(kind=dp), public, parameter :: tr11 = cos(2.0_dp*pi/5.0_dp) real(kind=dp), public, parameter :: tr12 = cos(4.0_dp*pi/5.0_dp) real(kind=dp), public :: tr2 real(kind=dp), public :: tr3 real(kind=dp), public :: tr4 real(kind=dp), public :: tr5 Source Code subroutine passb5 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 , wa4 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 5 , l1 ), wa1 ( * ), wa2 ( * ), wa3 ( * ), wa4 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 5 ) real ( dp ) :: ci2 , ci3 , ci4 , ci5 , cr2 , cr3 , & cr4 , cr5 , di2 , di3 , di4 , di5 , dr2 , dr3 , & dr4 , dr5 real ( dp ) :: ti2 , ti3 , ti4 , ti5 , tr2 , tr3 , & tr4 , tr5 integer :: i , k real ( dp ), parameter :: pi = acos ( - 1.0_dp ) real ( dp ), parameter :: tr11 = cos ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti11 = sin ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: tr12 = cos ( 4.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti12 = sin ( 4.0_dp * pi / 5.0_dp ) if ( ido /= 2 ) then do k = 1 , l1 do i = 2 , ido , 2 ti5 = cc ( i , 2 , k ) - cc ( i , 5 , k ) ti2 = cc ( i , 2 , k ) + cc ( i , 5 , k ) ti4 = cc ( i , 3 , k ) - cc ( i , 4 , k ) ti3 = cc ( i , 3 , k ) + cc ( i , 4 , k ) tr5 = cc ( i - 1 , 2 , k ) - cc ( i - 1 , 5 , k ) tr2 = cc ( i - 1 , 2 , k ) + cc ( i - 1 , 5 , k ) tr4 = cc ( i - 1 , 3 , k ) - cc ( i - 1 , 4 , k ) tr3 = cc ( i - 1 , 3 , k ) + cc ( i - 1 , 4 , k ) ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 + tr3 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 + ti3 cr2 = cc ( i - 1 , 1 , k ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( i , 1 , k ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( i - 1 , 1 , k ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( i , 1 , k ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 dr3 = cr3 - ci4 dr4 = cr3 + ci4 di3 = ci3 + cr4 di4 = ci3 - cr4 dr5 = cr2 + ci5 dr2 = cr2 - ci5 di5 = ci2 - cr5 di2 = ci2 + cr5 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * dr2 - wa1 ( i ) * di2 ch ( i , k , 2 ) = wa1 ( i - 1 ) * di2 + wa1 ( i ) * dr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 1 ) * dr3 - wa2 ( i ) * di3 ch ( i , k , 3 ) = wa2 ( i - 1 ) * di3 + wa2 ( i ) * dr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 1 ) * dr4 - wa3 ( i ) * di4 ch ( i , k , 4 ) = wa3 ( i - 1 ) * di4 + wa3 ( i ) * dr4 ch ( i - 1 , k , 5 ) = wa4 ( i - 1 ) * dr5 - wa4 ( i ) * di5 ch ( i , k , 5 ) = wa4 ( i - 1 ) * di5 + wa4 ( i ) * dr5 end do end do else do k = 1 , l1 ti5 = cc ( 2 , 2 , k ) - cc ( 2 , 5 , k ) ti2 = cc ( 2 , 2 , k ) + cc ( 2 , 5 , k ) ti4 = cc ( 2 , 3 , k ) - cc ( 2 , 4 , k ) ti3 = cc ( 2 , 3 , k ) + cc ( 2 , 4 , k ) tr5 = cc ( 1 , 2 , k ) - cc ( 1 , 5 , k ) tr2 = cc ( 1 , 2 , k ) + cc ( 1 , 5 , k ) tr4 = cc ( 1 , 3 , k ) - cc ( 1 , 4 , k ) tr3 = cc ( 1 , 3 , k ) + cc ( 1 , 4 , k ) ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + tr2 + tr3 ch ( 2 , k , 1 ) = cc ( 2 , 1 , k ) + ti2 + ti3 cr2 = cc ( 1 , 1 , k ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( 2 , 1 , k ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( 1 , 1 , k ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( 2 , 1 , k ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 ch ( 1 , k , 2 ) = cr2 - ci5 ch ( 1 , k , 5 ) = cr2 + ci5 ch ( 2 , k , 2 ) = ci2 + cr5 ch ( 2 , k , 3 ) = ci3 + cr4 ch ( 1 , k , 3 ) = cr3 - ci4 ch ( 1 , k , 4 ) = cr3 + ci4 ch ( 2 , k , 4 ) = ci3 - cr4 ch ( 2 , k , 5 ) = ci2 - cr5 end do end if end subroutine passb5","tags":"","loc":"proc/passb5.html"},{"title":"dfftb – Fortran-lang/fftpack","text":"subroutine dfftb(n, r, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: r (*) real(kind=dp), intent(inout) :: wsave (*) Contents Source Code dfftb Source Code subroutine dfftb ( n , r , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: r ( * ) real ( dp ), intent ( inout ) :: wsave ( * ) if ( n == 1 ) return call rfftb1 ( n , r , wsave , wsave ( n + 1 ), wsave ( 2 * n + 1 )) end subroutine dfftb","tags":"","loc":"proc/dfftb.html"},{"title":"rfftb1 – Fortran-lang/fftpack","text":"subroutine rfftb1(n, c, ch, wa, ifac) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: c (*) real(kind=dp), intent(inout) :: ch (*) real(kind=dp), intent(in) :: wa (*) integer, intent(in) :: ifac (*) Contents Variables i idl1 ido ip iw ix2 ix3 ix4 k1 l1 l2 na nf Source Code rfftb1 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: idl1 integer, public :: ido integer, public :: ip integer, public :: iw integer, public :: ix2 integer, public :: ix3 integer, public :: ix4 integer, public :: k1 integer, public :: l1 integer, public :: l2 integer, public :: na integer, public :: nf Source Code subroutine rfftb1 ( n , c , ch , wa , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: c ( * ) real ( dp ), intent ( in ) :: wa ( * ) real ( dp ), intent ( inout ) :: ch ( * ) integer , intent ( in ) :: ifac ( * ) integer :: i , idl1 , ido , ip , iw , ix2 , ix3 , ix4 , k1 , & l1 , l2 , na , nf nf = ifac ( 2 ) na = 0 l1 = 1 iw = 1 do k1 = 1 , nf ip = ifac ( k1 + 2 ) l2 = ip * l1 ido = n / l2 idl1 = ido * l1 if ( ip == 4 ) then ix2 = iw + ido ix3 = ix2 + ido if ( na /= 0 ) then call radb4 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 )) else call radb4 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 )) end if na = 1 - na elseif ( ip == 2 ) then if ( na /= 0 ) then call radb2 ( ido , l1 , ch , c , wa ( iw )) else call radb2 ( ido , l1 , c , ch , wa ( iw )) end if na = 1 - na elseif ( ip == 3 ) then ix2 = iw + ido if ( na /= 0 ) then call radb3 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 )) else call radb3 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 )) end if na = 1 - na elseif ( ip /= 5 ) then if ( na /= 0 ) then call radbg ( ido , ip , l1 , idl1 , ch , ch , ch , c , c , wa ( iw )) else call radbg ( ido , ip , l1 , idl1 , c , c , c , ch , ch , wa ( iw )) end if if ( ido == 1 ) na = 1 - na else ix2 = iw + ido ix3 = ix2 + ido ix4 = ix3 + ido if ( na /= 0 ) then call radb5 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) else call radb5 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) end if na = 1 - na end if l1 = l2 iw = iw + ( ip - 1 ) * ido end do if ( na == 0 ) return do i = 1 , n c ( i ) = ch ( i ) end do end subroutine rfftb1","tags":"","loc":"proc/rfftb1.html"},{"title":"dcosti – Fortran-lang/fftpack","text":"subroutine dcosti(n, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(out) :: wsave (*) Contents Variables dt fk k kc nm1 np1 ns2 pi Source Code dcosti Variables Type Visibility Attributes Name Initial real(kind=dp), public :: dt real(kind=dp), public :: fk integer, public :: k integer, public :: kc integer, public :: nm1 integer, public :: np1 integer, public :: ns2 real(kind=dp), public, parameter :: pi = acos(-1.0_dp) Source Code subroutine dcosti ( n , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wsave ( * ) real ( dp ) :: dt , fk integer :: k , kc , nm1 , np1 , ns2 real ( dp ), parameter :: pi = acos ( - 1.0_dp ) if ( n <= 3 ) return nm1 = n - 1 np1 = n + 1 ns2 = n / 2 dt = pi / real ( nm1 , kind = dp ) fk = 0.0_dp do k = 2 , ns2 kc = np1 - k fk = fk + 1.0_dp wsave ( k ) = 2.0_dp * sin ( fk * dt ) wsave ( kc ) = 2.0_dp * cos ( fk * dt ) end do call dffti ( nm1 , wsave ( n + 1 )) end subroutine dcosti","tags":"","loc":"proc/dcosti.html"},{"title":"dsinti – Fortran-lang/fftpack","text":"subroutine dsinti(n, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(out) :: wsave (*) Contents Variables dt k np1 ns2 pi Source Code dsinti Variables Type Visibility Attributes Name Initial real(kind=dp), public :: dt integer, public :: k integer, public :: np1 integer, public :: ns2 real(kind=dp), public, parameter :: pi = acos(-1.0_dp) Source Code subroutine dsinti ( n , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wsave ( * ) real ( dp ) :: dt integer :: k , np1 , ns2 real ( dp ), parameter :: pi = acos ( - 1.0_dp ) if ( n <= 1 ) return ns2 = n / 2 np1 = n + 1 dt = pi / real ( np1 , dp ) do k = 1 , ns2 wsave ( k ) = 2.0_dp * sin ( k * dt ) end do call dffti ( np1 , wsave ( ns2 + 1 )) end subroutine dsinti","tags":"","loc":"proc/dsinti.html"},{"title":"passb – Fortran-lang/fftpack","text":"subroutine passb(nac, ido, ip, l1, idl1, cc, c1, c2, ch, ch2, wa) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(out) :: nac integer, intent(in) :: ido integer, intent(in) :: ip integer, intent(in) :: l1 integer, intent(in) :: idl1 real(kind=dp), intent(in) :: cc (ido,ip,l1) real(kind=dp), intent(out) :: c1 (ido,l1,ip) real(kind=dp), intent(out) :: c2 (idl1,ip) real(kind=dp), intent(out) :: ch (ido,l1,ip) real(kind=dp), intent(inout) :: ch2 (idl1,ip) real(kind=dp), intent(in) :: wa (*) Contents Variables i idij idj idl idlj idot idp ik inc ipp2 ipph j jc k l lc nt wai war Source Code passb Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: idij integer, public :: idj integer, public :: idl integer, public :: idlj integer, public :: idot integer, public :: idp integer, public :: ik integer, public :: inc integer, public :: ipp2 integer, public :: ipph integer, public :: j integer, public :: jc integer, public :: k integer, public :: l integer, public :: lc integer, public :: nt real(kind=dp), public :: wai real(kind=dp), public :: war Source Code subroutine passb ( nac , ido , ip , l1 , idl1 , cc , c1 , c2 , ch , ch2 , wa ) use fftpack_kind , only : dp => rk implicit none integer , intent ( out ) :: nac integer , intent ( in ) :: ido , ip , l1 , idl1 real ( dp ), intent ( in ) :: cc ( ido , ip , l1 ), wa ( * ) real ( dp ), intent ( out ) :: c1 ( ido , l1 , ip ), c2 ( idl1 , ip ), ch ( ido , l1 , ip ) real ( dp ), intent ( inout ) :: ch2 ( idl1 , ip ) real ( dp ) :: wai , war integer :: i , idij , idj , idl , idlj , idot , idp , & ik , inc , ipp2 , ipph , j , jc , k , l , lc integer :: nt idot = ido / 2 nt = ip * idl1 ipp2 = ip + 2 ipph = ( ip + 1 ) / 2 idp = ip * ido ! if ( ido < l1 ) then do j = 2 , ipph jc = ipp2 - j do i = 1 , ido do k = 1 , l1 ch ( i , k , j ) = cc ( i , j , k ) + cc ( i , jc , k ) ch ( i , k , jc ) = cc ( i , j , k ) - cc ( i , jc , k ) end do end do end do do i = 1 , ido do k = 1 , l1 ch ( i , k , 1 ) = cc ( i , 1 , k ) end do end do else do j = 2 , ipph jc = ipp2 - j do k = 1 , l1 do i = 1 , ido ch ( i , k , j ) = cc ( i , j , k ) + cc ( i , jc , k ) ch ( i , k , jc ) = cc ( i , j , k ) - cc ( i , jc , k ) end do end do end do do k = 1 , l1 do i = 1 , ido ch ( i , k , 1 ) = cc ( i , 1 , k ) end do end do end if idl = 2 - ido inc = 0 do l = 2 , ipph lc = ipp2 - l idl = idl + ido do ik = 1 , idl1 c2 ( ik , l ) = ch2 ( ik , 1 ) + wa ( idl - 1 ) * ch2 ( ik , 2 ) c2 ( ik , lc ) = wa ( idl ) * ch2 ( ik , ip ) end do idlj = idl inc = inc + ido do j = 3 , ipph jc = ipp2 - j idlj = idlj + inc if ( idlj > idp ) idlj = idlj - idp war = wa ( idlj - 1 ) wai = wa ( idlj ) do ik = 1 , idl1 c2 ( ik , l ) = c2 ( ik , l ) + war * ch2 ( ik , j ) c2 ( ik , lc ) = c2 ( ik , lc ) + wai * ch2 ( ik , jc ) end do end do end do do j = 2 , ipph do ik = 1 , idl1 ch2 ( ik , 1 ) = ch2 ( ik , 1 ) + ch2 ( ik , j ) end do end do do j = 2 , ipph jc = ipp2 - j do ik = 2 , idl1 , 2 ch2 ( ik - 1 , j ) = c2 ( ik - 1 , j ) - c2 ( ik , jc ) ch2 ( ik - 1 , jc ) = c2 ( ik - 1 , j ) + c2 ( ik , jc ) ch2 ( ik , j ) = c2 ( ik , j ) + c2 ( ik - 1 , jc ) ch2 ( ik , jc ) = c2 ( ik , j ) - c2 ( ik - 1 , jc ) end do end do nac = 1 if ( ido == 2 ) return nac = 0 do ik = 1 , idl1 c2 ( ik , 1 ) = ch2 ( ik , 1 ) end do do j = 2 , ip do k = 1 , l1 c1 ( 1 , k , j ) = ch ( 1 , k , j ) c1 ( 2 , k , j ) = ch ( 2 , k , j ) end do end do if ( idot > l1 ) then idj = 2 - ido do j = 2 , ip idj = idj + ido do k = 1 , l1 idij = idj do i = 4 , ido , 2 idij = idij + 2 c1 ( i - 1 , k , j ) = wa ( idij - 1 ) * ch ( i - 1 , k , j ) - wa ( idij ) & * ch ( i , k , j ) c1 ( i , k , j ) = wa ( idij - 1 ) * ch ( i , k , j ) + wa ( idij ) & * ch ( i - 1 , k , j ) end do end do end do return end if idij = 0 do j = 2 , ip idij = idij + 2 do i = 4 , ido , 2 idij = idij + 2 do k = 1 , l1 c1 ( i - 1 , k , j ) = wa ( idij - 1 ) * ch ( i - 1 , k , j ) - wa ( idij ) * ch ( i , k , j ) c1 ( i , k , j ) = wa ( idij - 1 ) * ch ( i , k , j ) + wa ( idij ) * ch ( i - 1 , k , j ) end do end do end do return end subroutine passb","tags":"","loc":"proc/passb.html"},{"title":"dzfftb – Fortran-lang/fftpack","text":"subroutine dzfftb(n, r, azero, a, b, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(out) :: r (*) real(kind=dp), intent(in) :: azero real(kind=dp), intent(in) :: a (*) real(kind=dp), intent(in) :: b (*) real(kind=dp), intent(inout) :: wsave (*) Contents Variables i ns2 Source Code dzfftb Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ns2 Source Code subroutine dzfftb ( n , r , azero , a , b , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: r ( * ) real ( dp ), intent ( inout ) :: wsave ( * ) real ( dp ), intent ( in ) :: azero , a ( * ), b ( * ) integer :: i , ns2 if ( n < 2 ) then r ( 1 ) = azero return elseif ( n == 2 ) then r ( 1 ) = azero + a ( 1 ) r ( 2 ) = azero - a ( 1 ) return else ns2 = ( n - 1 ) / 2 do i = 1 , ns2 r ( 2 * i ) = 0.5_dp * a ( i ) r ( 2 * i + 1 ) = - 0.5_dp * b ( i ) end do r ( 1 ) = azero if ( mod ( n , 2 ) == 0 ) r ( n ) = a ( ns2 + 1 ) call dfftb ( n , r , wsave ( n + 1 )) end if end subroutine dzfftb","tags":"","loc":"proc/dzfftb.html"},{"title":"dfftf – Fortran-lang/fftpack","text":"subroutine dfftf(n, r, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: r (*) real(kind=dp), intent(inout) :: wsave (*) Contents Source Code dfftf Source Code subroutine dfftf ( n , r , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: r ( * ) real ( dp ), intent ( inout ) :: wsave ( * ) if ( n == 1 ) return call rfftf1 ( n , r , wsave , wsave ( n + 1 ), wsave ( 2 * n + 1 )) end subroutine dfftf","tags":"","loc":"proc/dfftf.html"},{"title":"radf5 – Fortran-lang/fftpack","text":"subroutine radf5(ido, l1, cc, ch, wa1, wa2, wa3, wa4) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: l1 real(kind=dp), intent(in) :: cc (ido,l1,5) real(kind=dp), intent(out) :: ch (ido,5,l1) real(kind=dp), intent(in) :: wa1 (*) real(kind=dp), intent(in) :: wa2 (*) real(kind=dp), intent(in) :: wa3 (*) real(kind=dp), intent(in) :: wa4 (*) Contents Variables ci2 ci3 ci4 ci5 cr2 cr3 cr4 cr5 di2 di3 di4 di5 dr2 dr3 dr4 dr5 i ic idp2 k pi ti11 ti12 ti2 ti3 ti4 ti5 tr11 tr12 tr2 tr3 tr4 tr5 Source Code radf5 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: ci2 real(kind=dp), public :: ci3 real(kind=dp), public :: ci4 real(kind=dp), public :: ci5 real(kind=dp), public :: cr2 real(kind=dp), public :: cr3 real(kind=dp), public :: cr4 real(kind=dp), public :: cr5 real(kind=dp), public :: di2 real(kind=dp), public :: di3 real(kind=dp), public :: di4 real(kind=dp), public :: di5 real(kind=dp), public :: dr2 real(kind=dp), public :: dr3 real(kind=dp), public :: dr4 real(kind=dp), public :: dr5 integer, public :: i integer, public :: ic integer, public :: idp2 integer, public :: k real(kind=dp), public, parameter :: pi = acos(-1.0_dp) real(kind=dp), public, parameter :: ti11 = sin(2.0_dp*pi/5.0_dp) real(kind=dp), public, parameter :: ti12 = sin(4.0_dp*pi/5.0_dp) real(kind=dp), public :: ti2 real(kind=dp), public :: ti3 real(kind=dp), public :: ti4 real(kind=dp), public :: ti5 real(kind=dp), public, parameter :: tr11 = cos(2.0_dp*pi/5.0_dp) real(kind=dp), public, parameter :: tr12 = cos(4.0_dp*pi/5.0_dp) real(kind=dp), public :: tr2 real(kind=dp), public :: tr3 real(kind=dp), public :: tr4 real(kind=dp), public :: tr5 Source Code subroutine radf5 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 , wa4 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , l1 , 5 ), wa1 ( * ), wa2 ( * ), wa3 ( * ), wa4 ( * ) real ( dp ), intent ( out ) :: ch ( ido , 5 , l1 ) real ( dp ) :: ci2 , ci3 , ci4 , ci5 , cr2 , cr3 , & cr4 , cr5 , di2 , di3 , di4 , di5 , dr2 , dr3 , & dr4 , dr5 real ( dp ) :: ti2 , ti3 , ti4 , ti5 , tr2 , tr3 , & tr4 , tr5 integer :: i , ic , idp2 , k real ( dp ), parameter :: pi = acos ( - 1.0_dp ) real ( dp ), parameter :: tr11 = cos ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti11 = sin ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: tr12 = cos ( 4.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti12 = sin ( 4.0_dp * pi / 5.0_dp ) do k = 1 , l1 cr2 = cc ( 1 , k , 5 ) + cc ( 1 , k , 2 ) ci5 = cc ( 1 , k , 5 ) - cc ( 1 , k , 2 ) cr3 = cc ( 1 , k , 4 ) + cc ( 1 , k , 3 ) ci4 = cc ( 1 , k , 4 ) - cc ( 1 , k , 3 ) ch ( 1 , 1 , k ) = cc ( 1 , k , 1 ) + cr2 + cr3 ch ( ido , 2 , k ) = cc ( 1 , k , 1 ) + tr11 * cr2 + tr12 * cr3 ch ( 1 , 3 , k ) = ti11 * ci5 + ti12 * ci4 ch ( ido , 4 , k ) = cc ( 1 , k , 1 ) + tr12 * cr2 + tr11 * cr3 ch ( 1 , 5 , k ) = ti12 * ci5 - ti11 * ci4 end do if ( ido == 1 ) return idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i dr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) di2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) dr3 = wa2 ( i - 2 ) * cc ( i - 1 , k , 3 ) + wa2 ( i - 1 ) * cc ( i , k , 3 ) di3 = wa2 ( i - 2 ) * cc ( i , k , 3 ) - wa2 ( i - 1 ) * cc ( i - 1 , k , 3 ) dr4 = wa3 ( i - 2 ) * cc ( i - 1 , k , 4 ) + wa3 ( i - 1 ) * cc ( i , k , 4 ) di4 = wa3 ( i - 2 ) * cc ( i , k , 4 ) - wa3 ( i - 1 ) * cc ( i - 1 , k , 4 ) dr5 = wa4 ( i - 2 ) * cc ( i - 1 , k , 5 ) + wa4 ( i - 1 ) * cc ( i , k , 5 ) di5 = wa4 ( i - 2 ) * cc ( i , k , 5 ) - wa4 ( i - 1 ) * cc ( i - 1 , k , 5 ) cr2 = dr2 + dr5 ci5 = dr5 - dr2 cr5 = di2 - di5 ci2 = di2 + di5 cr3 = dr3 + dr4 ci4 = dr4 - dr3 cr4 = di3 - di4 ci3 = di3 + di4 ch ( i - 1 , 1 , k ) = cc ( i - 1 , k , 1 ) + cr2 + cr3 ch ( i , 1 , k ) = cc ( i , k , 1 ) + ci2 + ci3 tr2 = cc ( i - 1 , k , 1 ) + tr11 * cr2 + tr12 * cr3 ti2 = cc ( i , k , 1 ) + tr11 * ci2 + tr12 * ci3 tr3 = cc ( i - 1 , k , 1 ) + tr12 * cr2 + tr11 * cr3 ti3 = cc ( i , k , 1 ) + tr12 * ci2 + tr11 * ci3 tr5 = ti11 * cr5 + ti12 * cr4 ti5 = ti11 * ci5 + ti12 * ci4 tr4 = ti12 * cr5 - ti11 * cr4 ti4 = ti12 * ci5 - ti11 * ci4 ch ( i - 1 , 3 , k ) = tr2 + tr5 ch ( ic - 1 , 2 , k ) = tr2 - tr5 ch ( i , 3 , k ) = ti2 + ti5 ch ( ic , 2 , k ) = ti5 - ti2 ch ( i - 1 , 5 , k ) = tr3 + tr4 ch ( ic - 1 , 4 , k ) = tr3 - tr4 ch ( i , 5 , k ) = ti3 + ti4 ch ( ic , 4 , k ) = ti4 - ti3 end do end do end subroutine radf5","tags":"","loc":"proc/radf5.html"},{"title":"cosqb1 – Fortran-lang/fftpack","text":"subroutine cosqb1(n, x, w, xh) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: x (*) real(kind=dp), intent(in) :: w (*) real(kind=dp), intent(out) :: xh (*) Contents Variables i k kc modn np2 ns2 xim1 Source Code cosqb1 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: kc integer, public :: modn integer, public :: np2 integer, public :: ns2 real(kind=dp), public :: xim1 Source Code subroutine cosqb1 ( n , x , w , xh ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: x ( * ) real ( dp ), intent ( in ) :: w ( * ) real ( dp ), intent ( out ) :: xh ( * ) integer :: i , k , kc , modn , np2 , ns2 real ( dp ) :: xim1 ns2 = ( n + 1 ) / 2 np2 = n + 2 do i = 3 , n , 2 xim1 = x ( i - 1 ) + x ( i ) x ( i ) = x ( i ) - x ( i - 1 ) x ( i - 1 ) = xim1 end do x ( 1 ) = x ( 1 ) + x ( 1 ) modn = mod ( n , 2 ) if ( modn == 0 ) x ( n ) = x ( n ) + x ( n ) call dfftb ( n , x , xh ) do k = 2 , ns2 kc = np2 - k xh ( k ) = w ( k - 1 ) * x ( kc ) + w ( kc - 1 ) * x ( k ) xh ( kc ) = w ( k - 1 ) * x ( k ) - w ( kc - 1 ) * x ( kc ) end do if ( modn == 0 ) x ( ns2 + 1 ) = w ( ns2 ) * ( x ( ns2 + 1 ) + x ( ns2 + 1 )) do k = 2 , ns2 kc = np2 - k x ( k ) = xh ( k ) + xh ( kc ) x ( kc ) = xh ( k ) - xh ( kc ) end do x ( 1 ) = x ( 1 ) + x ( 1 ) end subroutine cosqb1","tags":"","loc":"proc/cosqb1.html"},{"title":"dcosqf – Fortran-lang/fftpack","text":"subroutine dcosqf(n, x, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: x (*) real(kind=dp), intent(in) :: wsave (*) Contents Variables sqrt2 tsqx Source Code dcosqf Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: sqrt2 = sqrt(2.0_dp) real(kind=dp), public :: tsqx Source Code subroutine dcosqf ( n , x , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( in ) :: wsave ( * ) real ( dp ), intent ( inout ) :: x ( * ) real ( dp ) :: tsqx real ( dp ), parameter :: sqrt2 = sqrt ( 2.0_dp ) if ( n < 2 ) then return elseif ( n == 2 ) then tsqx = sqrt2 * x ( 2 ) x ( 2 ) = x ( 1 ) - tsqx x ( 1 ) = x ( 1 ) + tsqx else call cosqf1 ( n , x , wsave , wsave ( n + 1 )) end if end subroutine dcosqf","tags":"","loc":"proc/dcosqf.html"},{"title":"cosqf1 – Fortran-lang/fftpack","text":"subroutine cosqf1(n, x, w, xh) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: x (*) real(kind=dp), intent(in) :: w (*) real(kind=dp), intent(out) :: xh (*) Contents Variables i k kc modn np2 ns2 xim1 Source Code cosqf1 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: k integer, public :: kc integer, public :: modn integer, public :: np2 integer, public :: ns2 real(kind=dp), public :: xim1 Source Code subroutine cosqf1 ( n , x , w , xh ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: x ( * ) real ( dp ), intent ( in ) :: w ( * ) real ( dp ), intent ( out ) :: xh ( * ) integer :: i , k , kc , modn , np2 , ns2 real ( dp ) :: xim1 ns2 = ( n + 1 ) / 2 np2 = n + 2 do k = 2 , ns2 kc = np2 - k xh ( k ) = x ( k ) + x ( kc ) xh ( kc ) = x ( k ) - x ( kc ) end do modn = mod ( n , 2 ) if ( modn == 0 ) xh ( ns2 + 1 ) = x ( ns2 + 1 ) + x ( ns2 + 1 ) do k = 2 , ns2 kc = np2 - k x ( k ) = w ( k - 1 ) * xh ( kc ) + w ( kc - 1 ) * xh ( k ) x ( kc ) = w ( k - 1 ) * xh ( k ) - w ( kc - 1 ) * xh ( kc ) end do if ( modn == 0 ) x ( ns2 + 1 ) = w ( ns2 ) * xh ( ns2 + 1 ) call dfftf ( n , x , xh ) do i = 3 , n , 2 xim1 = x ( i - 1 ) - x ( i ) x ( i ) = x ( i - 1 ) + x ( i ) x ( i - 1 ) = xim1 end do end subroutine cosqf1","tags":"","loc":"proc/cosqf1.html"},{"title":"dsint – Fortran-lang/fftpack","text":"subroutine dsint(n, x, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: x (*) real(kind=dp), intent(in) :: wsave (*) Contents Variables iw1 iw2 iw3 np1 Source Code dsint Variables Type Visibility Attributes Name Initial integer, public :: iw1 integer, public :: iw2 integer, public :: iw3 integer, public :: np1 Source Code subroutine dsint ( n , x , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: x ( * ) real ( dp ), intent ( in ) :: wsave ( * ) integer :: iw1 , iw2 , iw3 , np1 np1 = n + 1 iw1 = n / 2 + 1 iw2 = iw1 + np1 iw3 = iw2 + np1 call sint1 ( n , x , wsave , wsave ( iw1 ), wsave ( iw2 ), wsave ( iw3 )) end subroutine dsint","tags":"","loc":"proc/dsint.html"},{"title":"rffti1 – Fortran-lang/fftpack","text":"subroutine rffti1(n, wa, ifac) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(out) :: wa (*) integer, intent(out) :: ifac (*) Contents Variables arg argh argld fi i ib ido ii ip ipm is j k1 l1 l2 ld nf nfm1 nl nq nr ntry ntryh tpi Source Code rffti1 Variables Type Visibility Attributes Name Initial real(kind=dp), public :: arg real(kind=dp), public :: argh real(kind=dp), public :: argld real(kind=dp), public :: fi integer, public :: i integer, public :: ib integer, public :: ido integer, public :: ii integer, public :: ip integer, public :: ipm integer, public :: is integer, public :: j integer, public :: k1 integer, public :: l1 integer, public :: l2 integer, public :: ld integer, public :: nf integer, public :: nfm1 integer, public :: nl integer, public :: nq integer, public :: nr integer, public :: ntry integer, public, parameter,               dimension(4) :: ntryh = [4, 2, 3, 5] real(kind=dp), public, parameter :: tpi = 2.0_dp*acos(-1.0_dp) Source Code subroutine rffti1 ( n , wa , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wa ( * ) integer , intent ( out ) :: ifac ( * ) real ( dp ) :: arg , argh , argld , fi integer :: i , ib , ido , ii , ip , ipm , is , j , k1 , l1 , & l2 , ld , nf , nfm1 , nl , nq , nr , ntry integer , dimension ( 4 ), parameter :: ntryh = [ 4 , 2 , 3 , 5 ] real ( dp ), parameter :: tpi = 2.0_dp * acos ( - 1.0_dp ) ! 2 * pi nl = n nf = 0 j = 0 100 j = j + 1 if ( j <= 4 ) then ntry = ntryh ( j ) else ntry = ntry + 2 end if 200 nq = nl / ntry nr = nl - ntry * nq if ( nr /= 0 ) goto 100 nf = nf + 1 ifac ( nf + 2 ) = ntry nl = nq if ( ntry == 2 ) then if ( nf /= 1 ) then do i = 2 , nf ib = nf - i + 2 ifac ( ib + 2 ) = ifac ( ib + 1 ) end do ifac ( 3 ) = 2 end if end if if ( nl /= 1 ) goto 200 ifac ( 1 ) = n ifac ( 2 ) = nf argh = tpi / real ( n , dp ) is = 0 nfm1 = nf - 1 l1 = 1 if ( nfm1 == 0 ) return do k1 = 1 , nfm1 ip = ifac ( k1 + 2 ) ld = 0 l2 = l1 * ip ido = n / l2 ipm = ip - 1 do j = 1 , ipm ld = ld + l1 i = is argld = real ( ld , dp ) * argh fi = 0.0_dp do ii = 3 , ido , 2 i = i + 2 fi = fi + 1.0_dp arg = fi * argld wa ( i - 1 ) = cos ( arg ) wa ( i ) = sin ( arg ) end do is = is + ido end do l1 = l2 end do end subroutine rffti1","tags":"","loc":"proc/rffti1.html"},{"title":"radbg – Fortran-lang/fftpack","text":"subroutine radbg(ido, ip, l1, idl1, cc, c1, c2, ch, ch2, wa) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: ido integer, intent(in) :: ip integer, intent(in) :: l1 integer, intent(in) :: idl1 real(kind=dp), intent(in) :: cc (ido,ip,l1) real(kind=dp), intent(inout) :: c1 (ido,l1,ip) real(kind=dp), intent(out) :: c2 (idl1,ip) real(kind=dp), intent(out) :: ch (ido,l1,ip) real(kind=dp), intent(inout) :: ch2 (idl1,ip) real(kind=dp), intent(in) :: wa (*) Contents Variables ai1 ai2 ar1 ar1h ar2 ar2h arg dc2 dcp ds2 dsp i ic idij idp2 ik ipp2 ipph is j j2 jc k l lc nbd tpi Source Code radbg Variables Type Visibility Attributes Name Initial real(kind=dp), public :: ai1 real(kind=dp), public :: ai2 real(kind=dp), public :: ar1 real(kind=dp), public :: ar1h real(kind=dp), public :: ar2 real(kind=dp), public :: ar2h real(kind=dp), public :: arg real(kind=dp), public :: dc2 real(kind=dp), public :: dcp real(kind=dp), public :: ds2 real(kind=dp), public :: dsp integer, public :: i integer, public :: ic integer, public :: idij integer, public :: idp2 integer, public :: ik integer, public :: ipp2 integer, public :: ipph integer, public :: is integer, public :: j integer, public :: j2 integer, public :: jc integer, public :: k integer, public :: l integer, public :: lc integer, public :: nbd real(kind=dp), public, parameter :: tpi = 2*acos(-1.0_dp) Source Code subroutine radbg ( ido , ip , l1 , idl1 , cc , c1 , c2 , ch , ch2 , wa ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , ip , l1 , idl1 real ( dp ), intent ( in ) :: cc ( ido , ip , l1 ), wa ( * ) real ( dp ), intent ( inout ) :: c1 ( ido , l1 , ip ), ch2 ( idl1 , ip ) real ( dp ), intent ( out ) :: c2 ( idl1 , ip ), ch ( ido , l1 , ip ) real ( dp ) :: ai1 , ai2 , ar1 , ar1h , ar2 , ar2h , arg , & dc2 , dcp , ds2 , dsp integer :: i , ic , idij , idp2 , ik , ipp2 , & ipph , is , j , j2 , jc , k , l , lc , nbd real ( dp ), parameter :: tpi = 2 * acos ( - 1.0_dp ) ! 2 * pi arg = tpi / real ( ip , dp ) dcp = cos ( arg ) dsp = sin ( arg ) idp2 = ido + 2 nbd = ( ido - 1 ) / 2 ipp2 = ip + 2 ipph = ( ip + 1 ) / 2 if ( ido < l1 ) then do i = 1 , ido do k = 1 , l1 ch ( i , k , 1 ) = cc ( i , 1 , k ) end do end do else do k = 1 , l1 do i = 1 , ido ch ( i , k , 1 ) = cc ( i , 1 , k ) end do end do end if do j = 2 , ipph jc = ipp2 - j j2 = j + j do k = 1 , l1 ch ( 1 , k , j ) = cc ( ido , j2 - 2 , k ) + cc ( ido , j2 - 2 , k ) ch ( 1 , k , jc ) = cc ( 1 , j2 - 1 , k ) + cc ( 1 , j2 - 1 , k ) end do end do if ( ido /= 1 ) then if ( nbd < l1 ) then do j = 2 , ipph jc = ipp2 - j do i = 3 , ido , 2 ic = idp2 - i do k = 1 , l1 ch ( i - 1 , k , j ) = cc ( i - 1 , 2 * j - 1 , k ) + cc ( ic - 1 , 2 * j - 2 , k ) ch ( i - 1 , k , jc ) = cc ( i - 1 , 2 * j - 1 , k ) - cc ( ic - 1 , 2 * j - 2 , k ) ch ( i , k , j ) = cc ( i , 2 * j - 1 , k ) - cc ( ic , 2 * j - 2 , k ) ch ( i , k , jc ) = cc ( i , 2 * j - 1 , k ) + cc ( ic , 2 * j - 2 , k ) end do end do end do else do j = 2 , ipph jc = ipp2 - j do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i ch ( i - 1 , k , j ) = cc ( i - 1 , 2 * j - 1 , k ) + cc ( ic - 1 , 2 * j - 2 , k ) ch ( i - 1 , k , jc ) = cc ( i - 1 , 2 * j - 1 , k ) - cc ( ic - 1 , 2 * j - 2 , k ) ch ( i , k , j ) = cc ( i , 2 * j - 1 , k ) - cc ( ic , 2 * j - 2 , k ) ch ( i , k , jc ) = cc ( i , 2 * j - 1 , k ) + cc ( ic , 2 * j - 2 , k ) end do end do end do end if end if ar1 = 1.0_dp ai1 = 0.0_dp do l = 2 , ipph lc = ipp2 - l ar1h = dcp * ar1 - dsp * ai1 ai1 = dcp * ai1 + dsp * ar1 ar1 = ar1h do ik = 1 , idl1 c2 ( ik , l ) = ch2 ( ik , 1 ) + ar1 * ch2 ( ik , 2 ) c2 ( ik , lc ) = ai1 * ch2 ( ik , ip ) end do dc2 = ar1 ds2 = ai1 ar2 = ar1 ai2 = ai1 do j = 3 , ipph jc = ipp2 - j ar2h = dc2 * ar2 - ds2 * ai2 ai2 = dc2 * ai2 + ds2 * ar2 ar2 = ar2h do ik = 1 , idl1 c2 ( ik , l ) = c2 ( ik , l ) + ar2 * ch2 ( ik , j ) c2 ( ik , lc ) = c2 ( ik , lc ) + ai2 * ch2 ( ik , jc ) end do end do end do do j = 2 , ipph do ik = 1 , idl1 ch2 ( ik , 1 ) = ch2 ( ik , 1 ) + ch2 ( ik , j ) end do end do do j = 2 , ipph jc = ipp2 - j do k = 1 , l1 ch ( 1 , k , j ) = c1 ( 1 , k , j ) - c1 ( 1 , k , jc ) ch ( 1 , k , jc ) = c1 ( 1 , k , j ) + c1 ( 1 , k , jc ) end do end do if ( ido /= 1 ) then if ( nbd < l1 ) then do j = 2 , ipph jc = ipp2 - j do i = 3 , ido , 2 do k = 1 , l1 ch ( i - 1 , k , j ) = c1 ( i - 1 , k , j ) - c1 ( i , k , jc ) ch ( i - 1 , k , jc ) = c1 ( i - 1 , k , j ) + c1 ( i , k , jc ) ch ( i , k , j ) = c1 ( i , k , j ) + c1 ( i - 1 , k , jc ) ch ( i , k , jc ) = c1 ( i , k , j ) - c1 ( i - 1 , k , jc ) end do end do end do else do j = 2 , ipph jc = ipp2 - j do k = 1 , l1 do i = 3 , ido , 2 ch ( i - 1 , k , j ) = c1 ( i - 1 , k , j ) - c1 ( i , k , jc ) ch ( i - 1 , k , jc ) = c1 ( i - 1 , k , j ) + c1 ( i , k , jc ) ch ( i , k , j ) = c1 ( i , k , j ) + c1 ( i - 1 , k , jc ) ch ( i , k , jc ) = c1 ( i , k , j ) - c1 ( i - 1 , k , jc ) end do end do end do end if end if if ( ido == 1 ) return do ik = 1 , idl1 c2 ( ik , 1 ) = ch2 ( ik , 1 ) end do do j = 2 , ip do k = 1 , l1 c1 ( 1 , k , j ) = ch ( 1 , k , j ) end do end do if ( nbd > l1 ) then is = - ido do j = 2 , ip is = is + ido do k = 1 , l1 idij = is do i = 3 , ido , 2 idij = idij + 2 c1 ( i - 1 , k , j ) = wa ( idij - 1 ) * ch ( i - 1 , k , j ) - wa ( idij ) & * ch ( i , k , j ) c1 ( i , k , j ) = wa ( idij - 1 ) * ch ( i , k , j ) + wa ( idij ) & * ch ( i - 1 , k , j ) end do end do end do else is = - ido do j = 2 , ip is = is + ido idij = is do i = 3 , ido , 2 idij = idij + 2 do k = 1 , l1 c1 ( i - 1 , k , j ) = wa ( idij - 1 ) * ch ( i - 1 , k , j ) - wa ( idij ) & * ch ( i , k , j ) c1 ( i , k , j ) = wa ( idij - 1 ) * ch ( i , k , j ) + wa ( idij ) & * ch ( i - 1 , k , j ) end do end do end do end if end subroutine radbg","tags":"","loc":"proc/radbg.html"},{"title":"dcosqb – Fortran-lang/fftpack","text":"subroutine dcosqb(n, x, wsave) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: x (*) real(kind=dp), intent(in) :: wsave (*) Contents Variables tsqrt2 x1 Source Code dcosqb Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: tsqrt2 = 2.0_dp*sqrt(2.0_dp) real(kind=dp), public :: x1 Source Code subroutine dcosqb ( n , x , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( in ) :: wsave ( * ) real ( dp ), intent ( inout ) :: x ( * ) real ( dp ) :: x1 real ( dp ), parameter :: tsqrt2 = 2.0_dp * sqrt ( 2.0_dp ) if ( n < 2 ) then x ( 1 ) = 4.0_dp * x ( 1 ) return elseif ( n == 2 ) then x1 = 4.0_dp * ( x ( 1 ) + x ( 2 )) x ( 2 ) = tsqrt2 * ( x ( 1 ) - x ( 2 )) x ( 1 ) = x1 return else call cosqb1 ( n , x , wsave , wsave ( n + 1 )) end if end subroutine dcosqb","tags":"","loc":"proc/dcosqb.html"},{"title":"cfftb1 – Fortran-lang/fftpack","text":"subroutine cfftb1(n, c, ch, wa, ifac) Uses fftpack_kind Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=dp), intent(inout) :: c (*) real(kind=dp), intent(inout) :: ch (*) real(kind=dp), intent(in) :: wa (*) integer, intent(in) :: ifac (*) Contents Variables i idl1 ido idot ip iw ix2 ix3 ix4 k1 l1 l2 n2 na nac nf Source Code cfftb1 Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: idl1 integer, public :: ido integer, public :: idot integer, public :: ip integer, public :: iw integer, public :: ix2 integer, public :: ix3 integer, public :: ix4 integer, public :: k1 integer, public :: l1 integer, public :: l2 integer, public :: n2 integer, public :: na integer, public :: nac integer, public :: nf Source Code subroutine cfftb1 ( n , c , ch , wa , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n , ifac ( * ) real ( dp ), intent ( in ) :: wa ( * ) real ( dp ), intent ( inout ) :: c ( * ), ch ( * ) integer :: i , idl1 , ido , idot , ip , iw , ix2 , ix3 , ix4 , & k1 , l1 , l2 , n2 , na , nac , nf nf = ifac ( 2 ) na = 0 l1 = 1 iw = 1 do k1 = 1 , nf ip = ifac ( k1 + 2 ) l2 = ip * l1 ido = n / l2 idot = ido + ido idl1 = idot * l1 if ( ip == 4 ) then ix2 = iw + idot ix3 = ix2 + idot if ( na /= 0 ) then call passb4 ( idot , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 )) else call passb4 ( idot , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 )) end if na = 1 - na elseif ( ip == 2 ) then if ( na /= 0 ) then call passb2 ( idot , l1 , ch , c , wa ( iw )) else call passb2 ( idot , l1 , c , ch , wa ( iw )) end if na = 1 - na elseif ( ip == 3 ) then ix2 = iw + idot if ( na /= 0 ) then call passb3 ( idot , l1 , ch , c , wa ( iw ), wa ( ix2 )) else call passb3 ( idot , l1 , c , ch , wa ( iw ), wa ( ix2 )) end if na = 1 - na elseif ( ip /= 5 ) then if ( na /= 0 ) then call passb ( nac , idot , ip , l1 , idl1 , ch , ch , ch , c , c , wa ( iw )) else call passb ( nac , idot , ip , l1 , idl1 , c , c , c , ch , ch , wa ( iw )) end if if ( nac /= 0 ) na = 1 - na else ix2 = iw + idot ix3 = ix2 + idot ix4 = ix3 + idot if ( na /= 0 ) then call passb5 ( idot , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) else call passb5 ( idot , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) end if na = 1 - na end if l1 = l2 iw = iw + ( ip - 1 ) * idot end do if ( na == 0 ) return n2 = n + n do i = 1 , n2 c ( i ) = ch ( i ) end do end subroutine cfftb1","tags":"","loc":"proc/cfftb1.html"},{"title":"dcosqb – Fortran-lang/fftpack","text":"interface public pure subroutine dcosqb(n, x, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(inout) :: x (*) real(kind=rk), intent(in) :: wsave (*) Description Unnormalized inverse of dcosqf .\n( Specification )","tags":"","loc":"interface/dcosqb.html"},{"title":"dcosqf – Fortran-lang/fftpack","text":"interface public pure subroutine dcosqf(n, x, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(inout) :: x (*) real(kind=rk), intent(in) :: wsave (*) Description Forward transform of quarter wave data.\n( Specification )","tags":"","loc":"interface/dcosqf.html"},{"title":"dcosqi – Fortran-lang/fftpack","text":"interface public pure subroutine dcosqi(n, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(out) :: wsave (*) Description Initialize dcosqf and dcosqb .\n( Specification )","tags":"","loc":"interface/dcosqi.html"},{"title":"dcost – Fortran-lang/fftpack","text":"interface public pure subroutine dcost(n, x, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(inout) :: x (*) real(kind=rk), intent(in) :: wsave (*) Description Discrete fourier cosine transform of an even sequence.\n( Specification )","tags":"","loc":"interface/dcost.html"},{"title":"dcosti – Fortran-lang/fftpack","text":"interface public pure subroutine dcosti(n, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(out) :: wsave (*) Description Initialize dcost .\n( Specification )","tags":"","loc":"interface/dcosti.html"},{"title":"dct – Fortran-lang/fftpack","text":"public interface dct Dsicrete cosine transforms.\n( Specification ) Contents Functions dct_rk Functions private pure module function dct_rk(x, n, type) result(result) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (:) integer, intent(in), optional :: n integer, intent(in), optional :: type Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"interface/dct.html"},{"title":"dct_t1 – Fortran-lang/fftpack","text":"public interface dct_t1 Perform DCT type-1\n( Specification ) Contents Module Procedures dcost Module Procedures public  interface dcost () Arguments None","tags":"","loc":"interface/dct_t1.html"},{"title":"dct_t1i – Fortran-lang/fftpack","text":"public interface dct_t1i Initialize DCT type-1\n( Specification ) Contents Module Procedures dcosti Module Procedures public  interface dcosti () Arguments None","tags":"","loc":"interface/dct_t1i.html"},{"title":"dct_t2 – Fortran-lang/fftpack","text":"public interface dct_t2 Perform DCT type-2\n( Specification ) Contents Module Procedures dcosqb Module Procedures public  interface dcosqb () Arguments None","tags":"","loc":"interface/dct_t2.html"},{"title":"dct_t23i – Fortran-lang/fftpack","text":"public interface dct_t23i Initialize DCT types 2, 3\n( Specification ) Contents Module Procedures dcosqi Module Procedures public  interface dcosqi () Arguments None","tags":"","loc":"interface/dct_t23i.html"},{"title":"dct_t3 – Fortran-lang/fftpack","text":"public interface dct_t3 Perform DCT type-3\n( Specification ) Contents Module Procedures dcosqf Module Procedures public  interface dcosqf () Arguments None","tags":"","loc":"interface/dct_t3.html"},{"title":"dfftb – Fortran-lang/fftpack","text":"interface public pure subroutine dfftb(n, r, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(inout) :: r (*) real(kind=rk), intent(in) :: wsave (*) Description Unnormalized inverse of dfftf .\n( Specification )","tags":"","loc":"interface/dfftb.html"},{"title":"dfftf – Fortran-lang/fftpack","text":"interface public pure subroutine dfftf(n, r, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(inout) :: r (*) real(kind=rk), intent(in) :: wsave (*) Description Forward transform of a real periodic sequence.\n( Specification )","tags":"","loc":"interface/dfftf.html"},{"title":"dffti – Fortran-lang/fftpack","text":"interface public pure subroutine dffti(n, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(out) :: wsave (*) Description Initialize dfftf and dfftb .\n( Specification )","tags":"","loc":"interface/dffti.html"},{"title":"dsint – Fortran-lang/fftpack","text":"interface public pure subroutine dsint(n, x, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(inout) :: x (*) real(kind=rk), intent(in) :: wsave (*)","tags":"","loc":"interface/dsint.html"},{"title":"dsinti – Fortran-lang/fftpack","text":"interface public pure subroutine dsinti(n, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(out) :: wsave (*)","tags":"","loc":"interface/dsinti.html"},{"title":"dzfftb – Fortran-lang/fftpack","text":"interface public pure subroutine dzfftb(n, r, azero, a, b, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(out) :: r (*) real(kind=rk), intent(in) :: azero real(kind=rk), intent(in) :: a (*) real(kind=rk), intent(in) :: b (*) real(kind=rk), intent(in) :: wsave (*) Description Unnormalized inverse of dzfftf .\n( Specification )","tags":"","loc":"interface/dzfftb.html"},{"title":"dzfftf – Fortran-lang/fftpack","text":"interface public pure subroutine dzfftf(n, r, azero, a, b, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(in) :: r (*) real(kind=rk), intent(out) :: azero real(kind=rk), intent(out) :: a (*) real(kind=rk), intent(out) :: b (*) real(kind=rk), intent(in) :: wsave (*) Description Simplified forward transform of a real periodic sequence.\n( Specification )","tags":"","loc":"interface/dzfftf.html"},{"title":"dzffti – Fortran-lang/fftpack","text":"interface public pure subroutine dzffti(n, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(out) :: wsave (*) Description Initialize dzfftf and dzfftb .\n( Specification )","tags":"","loc":"interface/dzffti.html"},{"title":"fft – Fortran-lang/fftpack","text":"public interface fft Forward transform of a complex periodic sequence.\n( Specifiction ) Contents Functions fft_rk Functions private pure module function fft_rk(x, n) result(result) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in) :: x (:) integer, intent(in), optional :: n Return Value complex(kind=rk), allocatable, (:)","tags":"","loc":"interface/fft.html"},{"title":"fftfreq – Fortran-lang/fftpack","text":"interface public pure module function fftfreq(n) result(out) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer,dimension(n) Description Integer frequency values involved in complex FFT.\n( Specifiction )","tags":"","loc":"interface/fftfreq.html"},{"title":"fftshift – Fortran-lang/fftpack","text":"public interface fftshift Shifts zero-frequency component to center of spectrum.\n( Specifiction ) Contents Functions fftshift_crk fftshift_rrk Functions private pure module function fftshift_crk(x) result(result) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in) :: x (:) Return Value complex(kind=rk), dimension(size(x)) private pure module function fftshift_rrk(x) result(result) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (:) Return Value real(kind=rk), dimension(size(x))","tags":"","loc":"interface/fftshift.html"},{"title":"idct – Fortran-lang/fftpack","text":"public interface idct Inverse discrete cosine transforms.\n( Specification ) Contents Functions idct_rk Functions private pure module function idct_rk(x, n, type) result(result) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (:) integer, intent(in), optional :: n integer, intent(in), optional :: type Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"interface/idct.html"},{"title":"ifft – Fortran-lang/fftpack","text":"public interface ifft Backward transform of a complex periodic sequence.\n( Specifiction ) Contents Functions ifft_rk Functions private pure module function ifft_rk(x, n) result(result) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in) :: x (:) integer, intent(in), optional :: n Return Value complex(kind=rk), allocatable, (:)","tags":"","loc":"interface/ifft.html"},{"title":"ifftshift – Fortran-lang/fftpack","text":"public interface ifftshift Shifts zero-frequency component to beginning of spectrum.\n( Specifiction ) Contents Functions ifftshift_crk ifftshift_rrk Functions private pure module function ifftshift_crk(x) result(result) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in) :: x (:) Return Value complex(kind=rk), dimension(size(x)) private pure module function ifftshift_rrk(x) result(result) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (:) Return Value real(kind=rk), dimension(size(x))","tags":"","loc":"interface/ifftshift.html"},{"title":"irfft – Fortran-lang/fftpack","text":"public interface irfft Backward transform of a real periodic sequence.\n( Specifiction ) Contents Functions irfft_rk Functions private pure module function irfft_rk(x, n) result(result) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (:) integer, intent(in), optional :: n Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"interface/irfft.html"},{"title":"rfft – Fortran-lang/fftpack","text":"public interface rfft Forward transform of a real periodic sequence.\n( Specifiction ) Contents Functions rfft_rk Functions private pure module function rfft_rk(x, n) result(result) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (:) integer, intent(in), optional :: n Return Value real(kind=rk), allocatable, (:)","tags":"","loc":"interface/rfft.html"},{"title":"rfftfreq – Fortran-lang/fftpack","text":"interface public pure module function rfftfreq(n) result(out) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer,dimension(n) Description Integer frequency values involved in real FFT.\n( Specifiction )","tags":"","loc":"interface/rfftfreq.html"},{"title":"zfftb – Fortran-lang/fftpack","text":"interface public pure subroutine zfftb(n, c, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=rk), intent(inout) :: c (*) real(kind=rk), intent(in) :: wsave (*) Description Unnormalized inverse of zfftf .\n( Specification )","tags":"","loc":"interface/zfftb.html"},{"title":"zfftf – Fortran-lang/fftpack","text":"interface public pure subroutine zfftf(n, c, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=rk), intent(inout) :: c (*) real(kind=rk), intent(in) :: wsave (*) Description Forward transform of a complex periodic sequence.\n( Specification )","tags":"","loc":"interface/zfftf.html"},{"title":"zffti – Fortran-lang/fftpack","text":"interface public pure subroutine zffti(n, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(out) :: wsave (*) Description Initialize zfftf and zfftb .\n( Specification )","tags":"","loc":"interface/zffti.html"},{"title":"fftpack – Fortran-lang/fftpack","text":"Uses fftpack_kind Used by Descendants: fftpack_dct fftpack_fft fftpack_fftshift fftpack_ifft fftpack_ifftshift fftpack_irfft fftpack_rfft fftpack_utils Contents Interfaces dcosqb dcosqf dcosqi dcost dcosti dct dct_t1 dct_t1i dct_t2 dct_t23i dct_t3 dfftb dfftf dffti dsint dsinti dzfftb dzfftf dzffti fft fftfreq fftshift idct ifft ifftshift irfft rfft rfftfreq zfftb zfftf zffti Interfaces interface public pure subroutine dcosqb(n, x, wsave) Unnormalized inverse of dcosqf .\n( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(inout) :: x (*) real(kind=rk), intent(in) :: wsave (*) interface public pure subroutine dcosqf(n, x, wsave) Forward transform of quarter wave data.\n( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(inout) :: x (*) real(kind=rk), intent(in) :: wsave (*) interface public pure subroutine dcosqi(n, wsave) Initialize dcosqf and dcosqb .\n( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(out) :: wsave (*) interface public pure subroutine dcost(n, x, wsave) Discrete fourier cosine transform of an even sequence.\n( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(inout) :: x (*) real(kind=rk), intent(in) :: wsave (*) interface public pure subroutine dcosti(n, wsave) Initialize dcost .\n( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(out) :: wsave (*) public        interface dct Dsicrete cosine transforms.\n( Specification ) private pure module function dct_rk(x, n, type) result(result) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (:) integer, intent(in), optional :: n integer, intent(in), optional :: type Return Value real(kind=rk), allocatable, (:) public        interface dct_t1 Perform DCT type-1\n( Specification ) public  interface dcost () Arguments None public        interface dct_t1i Initialize DCT type-1\n( Specification ) public  interface dcosti () Arguments None public        interface dct_t2 Perform DCT type-2\n( Specification ) public  interface dcosqb () Arguments None public        interface dct_t23i Initialize DCT types 2, 3\n( Specification ) public  interface dcosqi () Arguments None public        interface dct_t3 Perform DCT type-3\n( Specification ) public  interface dcosqf () Arguments None interface public pure subroutine dfftb(n, r, wsave) Unnormalized inverse of dfftf .\n( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(inout) :: r (*) real(kind=rk), intent(in) :: wsave (*) interface public pure subroutine dfftf(n, r, wsave) Forward transform of a real periodic sequence.\n( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(inout) :: r (*) real(kind=rk), intent(in) :: wsave (*) interface public pure subroutine dffti(n, wsave) Initialize dfftf and dfftb .\n( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(out) :: wsave (*) interface public pure subroutine dsint(n, x, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(inout) :: x (*) real(kind=rk), intent(in) :: wsave (*) interface public pure subroutine dsinti(n, wsave) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(out) :: wsave (*) interface public pure subroutine dzfftb(n, r, azero, a, b, wsave) Unnormalized inverse of dzfftf .\n( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(out) :: r (*) real(kind=rk), intent(in) :: azero real(kind=rk), intent(in) :: a (*) real(kind=rk), intent(in) :: b (*) real(kind=rk), intent(in) :: wsave (*) interface public pure subroutine dzfftf(n, r, azero, a, b, wsave) Simplified forward transform of a real periodic sequence.\n( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(in) :: r (*) real(kind=rk), intent(out) :: azero real(kind=rk), intent(out) :: a (*) real(kind=rk), intent(out) :: b (*) real(kind=rk), intent(in) :: wsave (*) interface public pure subroutine dzffti(n, wsave) Initialize dzfftf and dzfftb .\n( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(out) :: wsave (*) public        interface fft Forward transform of a complex periodic sequence.\n( Specifiction ) private pure module function fft_rk(x, n) result(result) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in) :: x (:) integer, intent(in), optional :: n Return Value complex(kind=rk), allocatable, (:) interface public pure module function fftfreq(n) result(out) Integer frequency values involved in complex FFT.\n( Specifiction ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer, dimension(n) public        interface fftshift Shifts zero-frequency component to center of spectrum.\n( Specifiction ) private pure module function fftshift_crk(x) result(result) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in) :: x (:) Return Value complex(kind=rk), dimension(size(x)) private pure module function fftshift_rrk(x) result(result) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (:) Return Value real(kind=rk), dimension(size(x)) public        interface idct Inverse discrete cosine transforms.\n( Specification ) private pure module function idct_rk(x, n, type) result(result) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (:) integer, intent(in), optional :: n integer, intent(in), optional :: type Return Value real(kind=rk), allocatable, (:) public        interface ifft Backward transform of a complex periodic sequence.\n( Specifiction ) private pure module function ifft_rk(x, n) result(result) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in) :: x (:) integer, intent(in), optional :: n Return Value complex(kind=rk), allocatable, (:) public        interface ifftshift Shifts zero-frequency component to beginning of spectrum.\n( Specifiction ) private pure module function ifftshift_crk(x) result(result) Arguments Type Intent Optional Attributes Name complex(kind=rk), intent(in) :: x (:) Return Value complex(kind=rk), dimension(size(x)) private pure module function ifftshift_rrk(x) result(result) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (:) Return Value real(kind=rk), dimension(size(x)) public        interface irfft Backward transform of a real periodic sequence.\n( Specifiction ) private pure module function irfft_rk(x, n) result(result) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (:) integer, intent(in), optional :: n Return Value real(kind=rk), allocatable, (:) public        interface rfft Forward transform of a real periodic sequence.\n( Specifiction ) private pure module function rfft_rk(x, n) result(result) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x (:) integer, intent(in), optional :: n Return Value real(kind=rk), allocatable, (:) interface public pure module function rfftfreq(n) result(out) Integer frequency values involved in real FFT.\n( Specifiction ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer, dimension(n) interface public pure subroutine zfftb(n, c, wsave) Unnormalized inverse of zfftf .\n( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=rk), intent(inout) :: c (*) real(kind=rk), intent(in) :: wsave (*) interface public pure subroutine zfftf(n, c, wsave) Forward transform of a complex periodic sequence.\n( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n complex(kind=rk), intent(inout) :: c (*) real(kind=rk), intent(in) :: wsave (*) interface public pure subroutine zffti(n, wsave) Initialize zfftf and zfftb .\n( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=rk), intent(out) :: wsave (*)","tags":"","loc":"module/fftpack.html"},{"title":"fftpack_kind – Fortran-lang/fftpack","text":"Uses iso_fortran_env Contents None","tags":"","loc":"module/fftpack_kind.html"},{"title":"fftpack_fft – Fortran-lang/fftpack","text":"Uses Ancestors: fftpack Contents None","tags":"","loc":"module/fftpack_fft.html"},{"title":"fftpack_dct – Fortran-lang/fftpack","text":"Uses Ancestors: fftpack Contents None","tags":"","loc":"module/fftpack_dct.html"},{"title":"fftpack_fftshift – Fortran-lang/fftpack","text":"Uses Ancestors: fftpack Contents None","tags":"","loc":"module/fftpack_fftshift.html"},{"title":"fftpack_irfft – Fortran-lang/fftpack","text":"Uses Ancestors: fftpack Contents None","tags":"","loc":"module/fftpack_irfft.html"},{"title":"fftpack_utils – Fortran-lang/fftpack","text":"Uses Ancestors: fftpack Contents None","tags":"","loc":"module/fftpack_utils.html"},{"title":"fftpack_rfft – Fortran-lang/fftpack","text":"Uses Ancestors: fftpack Contents None","tags":"","loc":"module/fftpack_rfft.html"},{"title":"fftpack_ifft – Fortran-lang/fftpack","text":"Uses Ancestors: fftpack Contents None","tags":"","loc":"module/fftpack_ifft.html"},{"title":"fftpack_ifftshift – Fortran-lang/fftpack","text":"Uses Ancestors: fftpack Contents None","tags":"","loc":"module/fftpack_ifftshift.html"},{"title":"radf4.f90 – Fortran-lang/fftpack","text":"Contents Subroutines radf4 Source Code radf4.f90 Source Code subroutine radf4 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , l1 , 4 ), wa1 ( * ), wa2 ( * ), wa3 ( * ) real ( dp ), intent ( out ) :: ch ( ido , 4 , l1 ) real ( dp ) :: ci2 , ci3 , ci4 , cr2 , cr3 , cr4 , & ti1 , ti2 , ti3 , ti4 , tr1 , tr2 , tr3 , & tr4 integer :: i , ic , idp2 , k real ( dp ), parameter :: hsqt2 = sqrt ( 2.0_dp ) / 2.0_dp do k = 1 , l1 tr1 = cc ( 1 , k , 2 ) + cc ( 1 , k , 4 ) tr2 = cc ( 1 , k , 1 ) + cc ( 1 , k , 3 ) ch ( 1 , 1 , k ) = tr1 + tr2 ch ( ido , 4 , k ) = tr2 - tr1 ch ( ido , 2 , k ) = cc ( 1 , k , 1 ) - cc ( 1 , k , 3 ) ch ( 1 , 3 , k ) = cc ( 1 , k , 4 ) - cc ( 1 , k , 2 ) end do if ( ido < 2 ) return if ( ido /= 2 ) then idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i cr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) ci2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) cr3 = wa2 ( i - 2 ) * cc ( i - 1 , k , 3 ) + wa2 ( i - 1 ) * cc ( i , k , 3 ) ci3 = wa2 ( i - 2 ) * cc ( i , k , 3 ) - wa2 ( i - 1 ) * cc ( i - 1 , k , 3 ) cr4 = wa3 ( i - 2 ) * cc ( i - 1 , k , 4 ) + wa3 ( i - 1 ) * cc ( i , k , 4 ) ci4 = wa3 ( i - 2 ) * cc ( i , k , 4 ) - wa3 ( i - 1 ) * cc ( i - 1 , k , 4 ) tr1 = cr2 + cr4 tr4 = cr4 - cr2 ti1 = ci2 + ci4 ti4 = ci2 - ci4 ti2 = cc ( i , k , 1 ) + ci3 ti3 = cc ( i , k , 1 ) - ci3 tr2 = cc ( i - 1 , k , 1 ) + cr3 tr3 = cc ( i - 1 , k , 1 ) - cr3 ch ( i - 1 , 1 , k ) = tr1 + tr2 ch ( ic - 1 , 4 , k ) = tr2 - tr1 ch ( i , 1 , k ) = ti1 + ti2 ch ( ic , 4 , k ) = ti1 - ti2 ch ( i - 1 , 3 , k ) = ti4 + tr3 ch ( ic - 1 , 2 , k ) = tr3 - ti4 ch ( i , 3 , k ) = tr4 + ti3 ch ( ic , 2 , k ) = tr4 - ti3 end do end do if ( mod ( ido , 2 ) == 1 ) return end if do k = 1 , l1 ti1 = - hsqt2 * ( cc ( ido , k , 2 ) + cc ( ido , k , 4 )) tr1 = hsqt2 * ( cc ( ido , k , 2 ) - cc ( ido , k , 4 )) ch ( ido , 1 , k ) = tr1 + cc ( ido , k , 1 ) ch ( ido , 3 , k ) = cc ( ido , k , 1 ) - tr1 ch ( 1 , 2 , k ) = ti1 - cc ( ido , k , 3 ) ch ( 1 , 4 , k ) = ti1 + cc ( ido , k , 3 ) end do end subroutine radf4","tags":"","loc":"sourcefile/radf4.f90.html"},{"title":"fftpack_fft.f90 – Fortran-lang/fftpack","text":"Contents Submodules fftpack_fft Source Code fftpack_fft.f90 Source Code submodule ( fftpack ) fftpack_fft contains !> Forward transform of a complex periodic sequence. pure module function fft_rk ( x , n ) result ( result ) complex ( kind = rk ), intent ( in ) :: x (:) integer , intent ( in ), optional :: n complex ( kind = rk ), allocatable :: result (:) integer :: lenseq , lensav , i real ( kind = rk ), allocatable :: wsave (:) if ( present ( n )) then lenseq = n if ( lenseq <= size ( x )) then result = x (: lenseq ) else if ( lenseq > size ( x )) then result = [ x , (( 0.0_rk , 0.0_rk ), i = 1 , lenseq - size ( x ))] end if else lenseq = size ( x ) result = x end if !> Initialize FFT lensav = 4 * lenseq + 15 allocate ( wsave ( lensav )) call zffti ( lenseq , wsave ) !> Forward transformation call zfftf ( lenseq , result , wsave ) end function fft_rk end submodule fftpack_fft","tags":"","loc":"sourcefile/fftpack_fft.f90.html"},{"title":"ezfft1.f90 – Fortran-lang/fftpack","text":"Contents Subroutines ezfft1 Source Code ezfft1.f90 Source Code subroutine ezfft1 ( n , wa , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wa ( * ) integer , intent ( out ) :: ifac ( * ) real ( dp ) :: arg1 , argh , ch1 , ch1h , dch1 , dsh1 , sh1 integer :: i , ib , ido , ii , ip , ipm , is , j , k1 , l1 , & l2 , nf , nfm1 , nl , nq , nr , ntry integer , dimension ( 4 ), parameter :: ntryh = [ 4 , 2 , 3 , 5 ] real ( dp ), parameter :: tpi = 2.0_dp * acos ( - 1.0_dp ) ! 2 * pi nl = n nf = 0 j = 0 100 j = j + 1 if ( j <= 4 ) then ntry = ntryh ( j ) else ntry = ntry + 2 end if 200 nq = nl / ntry nr = nl - ntry * nq if ( nr /= 0 ) goto 100 nf = nf + 1 ifac ( nf + 2 ) = ntry nl = nq if ( ntry == 2 ) then if ( nf /= 1 ) then do i = 2 , nf ib = nf - i + 2 ifac ( ib + 2 ) = ifac ( ib + 1 ) end do ifac ( 3 ) = 2 end if end if if ( nl /= 1 ) goto 200 ifac ( 1 ) = n ifac ( 2 ) = nf argh = tpi / real ( n , dp ) is = 0 nfm1 = nf - 1 l1 = 1 if ( nfm1 == 0 ) return do k1 = 1 , nfm1 ip = ifac ( k1 + 2 ) l2 = l1 * ip ido = n / l2 ipm = ip - 1 arg1 = real ( l1 , dp ) * argh ch1 = 1.0_dp sh1 = 0.0_dp dch1 = cos ( arg1 ) dsh1 = sin ( arg1 ) do j = 1 , ipm ch1h = dch1 * ch1 - dsh1 * sh1 sh1 = dch1 * sh1 + dsh1 * ch1 ch1 = ch1h i = is + 2 wa ( i - 1 ) = ch1 wa ( i ) = sh1 if ( ido >= 5 ) then do ii = 5 , ido , 2 i = i + 2 wa ( i - 1 ) = ch1 * wa ( i - 3 ) - sh1 * wa ( i - 2 ) wa ( i ) = ch1 * wa ( i - 2 ) + sh1 * wa ( i - 3 ) end do end if is = is + ido end do l1 = l2 end do end subroutine ezfft1","tags":"","loc":"sourcefile/ezfft1.f90.html"},{"title":"dsinqi.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dsinqi Source Code dsinqi.f90 Source Code subroutine dsinqi ( n , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wsave ( * ) call dcosqi ( n , wsave ) end subroutine dsinqi","tags":"","loc":"sourcefile/dsinqi.f90.html"},{"title":"cffti1.f90 – Fortran-lang/fftpack","text":"Contents Subroutines cffti1 Source Code cffti1.f90 Source Code subroutine cffti1 ( n , wa , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n integer , intent ( out ) :: ifac ( * ) real ( dp ), intent ( out ) :: wa ( * ) real ( dp ) :: arg , argh , argld , fi integer :: i , i1 , ib , ido , idot , ii , ip , ipm , j , k1 , & l1 , l2 , ld , nf , nl , nq , nr , ntry integer , dimension ( 4 ), parameter :: ntryh = [ 3 , 4 , 2 , 5 ] real ( dp ), parameter :: tpi = 2.0_dp * acos ( - 1.0_dp ) ! 2 * pi nl = n nf = 0 j = 0 100 j = j + 1 if ( j <= 4 ) then ntry = ntryh ( j ) else ntry = ntry + 2 end if 200 nq = nl / ntry nr = nl - ntry * nq if ( nr /= 0 ) goto 100 nf = nf + 1 ifac ( nf + 2 ) = ntry nl = nq if ( ntry == 2 ) then if ( nf /= 1 ) then do i = 2 , nf ib = nf - i + 2 ifac ( ib + 2 ) = ifac ( ib + 1 ) end do ifac ( 3 ) = 2 end if end if if ( nl /= 1 ) goto 200 ifac ( 1 ) = n ifac ( 2 ) = nf argh = tpi / real ( n , kind = dp ) i = 2 l1 = 1 do k1 = 1 , nf ip = ifac ( k1 + 2 ) ld = 0 l2 = l1 * ip ido = n / l2 idot = ido + ido + 2 ipm = ip - 1 do j = 1 , ipm i1 = i wa ( i - 1 ) = 1.0_dp wa ( i ) = 0.0_dp ld = ld + l1 fi = 0.0_dp argld = real ( ld , kind = dp ) * argh do ii = 4 , idot , 2 i = i + 2 fi = fi + 1.0_dp arg = fi * argld wa ( i - 1 ) = cos ( arg ) wa ( i ) = sin ( arg ) end do if ( ip > 5 ) then wa ( i1 - 1 ) = wa ( i - 1 ) wa ( i1 ) = wa ( i ) end if end do l1 = l2 end do end subroutine cffti1","tags":"","loc":"sourcefile/cffti1.f90.html"},{"title":"rfftf1.f90 – Fortran-lang/fftpack","text":"Contents Subroutines rfftf1 Source Code rfftf1.f90 Source Code subroutine rfftf1 ( n , c , ch , wa , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: c ( * ) real ( dp ), intent ( in ) :: wa ( * ) real ( dp ), intent ( inout ) :: ch ( * ) integer , intent ( in ) :: ifac ( * ) integer :: i , idl1 , ido , ip , iw , ix2 , ix3 , ix4 , k1 , & kh , l1 , l2 , na , nf nf = ifac ( 2 ) na = 1 l2 = n iw = n do k1 = 1 , nf kh = nf - k1 ip = ifac ( kh + 3 ) l1 = l2 / ip ido = n / l2 idl1 = ido * l1 iw = iw - ( ip - 1 ) * ido na = 1 - na if ( ip == 4 ) then ix2 = iw + ido ix3 = ix2 + ido if ( na /= 0 ) then call radf4 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 )) else call radf4 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 )) end if elseif ( ip /= 2 ) then if ( ip == 3 ) then ix2 = iw + ido if ( na /= 0 ) then call radf3 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 )) else call radf3 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 )) end if elseif ( ip /= 5 ) then if ( ido == 1 ) na = 1 - na if ( na /= 0 ) then call radfg ( ido , ip , l1 , idl1 , ch , ch , ch , c , c , wa ( iw )) na = 0 else call radfg ( ido , ip , l1 , idl1 , c , c , c , ch , ch , wa ( iw )) na = 1 end if else ix2 = iw + ido ix3 = ix2 + ido ix4 = ix3 + ido if ( na /= 0 ) then call radf5 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) else call radf5 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) end if end if elseif ( na /= 0 ) then call radf2 ( ido , l1 , ch , c , wa ( iw )) else call radf2 ( ido , l1 , c , ch , wa ( iw )) end if l2 = l1 end do if ( na == 1 ) return do i = 1 , n c ( i ) = ch ( i ) end do end subroutine rfftf1","tags":"","loc":"sourcefile/rfftf1.f90.html"},{"title":"dzfftf.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dzfftf Source Code dzfftf.f90 Source Code subroutine dzfftf ( n , r , azero , a , b , wsave ) !     version 3  june 1979 use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( in ) :: r ( * ) real ( dp ), intent ( out ) :: azero , a ( * ), b ( * ) real ( dp ), intent ( inout ) :: wsave ( * ) real ( dp ) :: cf , cfm integer :: i , ns2 , ns2m if ( n < 2 ) then azero = r ( 1 ) return elseif ( n == 2 ) then azero = 0.5_dp * ( r ( 1 ) + r ( 2 )) a ( 1 ) = 0.5_dp * ( r ( 1 ) - r ( 2 )) return else do i = 1 , n wsave ( i ) = r ( i ) end do call dfftf ( n , wsave , wsave ( n + 1 )) cf = 2.0_dp / real ( n , dp ) cfm = - cf azero = 0.5_dp * cf * wsave ( 1 ) ns2 = ( n + 1 ) / 2 ns2m = ns2 - 1 do i = 1 , ns2m a ( i ) = cf * wsave ( 2 * i ) b ( i ) = cfm * wsave ( 2 * i + 1 ) end do if ( mod ( n , 2 ) == 1 ) return a ( ns2 ) = 0.5_dp * cf * wsave ( n ) b ( ns2 ) = 0.0_dp end if end subroutine dzfftf","tags":"","loc":"sourcefile/dzfftf.f90.html"},{"title":"passf3.f90 – Fortran-lang/fftpack","text":"Contents Subroutines passf3 Source Code passf3.f90 Source Code subroutine passf3 ( ido , l1 , cc , ch , wa1 , wa2 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 3 , l1 ), wa1 ( * ), wa2 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 3 ) real ( dp ) :: ci2 , ci3 , cr2 , cr3 , di2 , di3 , & & dr2 , dr3 , ti2 , tr2 integer :: i , k real ( dp ), parameter :: taur = - 0.5_dp real ( dp ), parameter :: taui = - sqrt ( 3.0_dp ) / 2.0_dp if ( ido /= 2 ) then do k = 1 , l1 do i = 2 , ido , 2 tr2 = cc ( i - 1 , 2 , k ) + cc ( i - 1 , 3 , k ) cr2 = cc ( i - 1 , 1 , k ) + taur * tr2 ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 ti2 = cc ( i , 2 , k ) + cc ( i , 3 , k ) ci2 = cc ( i , 1 , k ) + taur * ti2 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 cr3 = taui * ( cc ( i - 1 , 2 , k ) - cc ( i - 1 , 3 , k )) ci3 = taui * ( cc ( i , 2 , k ) - cc ( i , 3 , k )) dr2 = cr2 - ci3 dr3 = cr2 + ci3 di2 = ci2 + cr3 di3 = ci2 - cr3 ch ( i , k , 2 ) = wa1 ( i - 1 ) * di2 - wa1 ( i ) * dr2 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * dr2 + wa1 ( i ) * di2 ch ( i , k , 3 ) = wa2 ( i - 1 ) * di3 - wa2 ( i ) * dr3 ch ( i - 1 , k , 3 ) = wa2 ( i - 1 ) * dr3 + wa2 ( i ) * di3 end do end do else do k = 1 , l1 tr2 = cc ( 1 , 2 , k ) + cc ( 1 , 3 , k ) cr2 = cc ( 1 , 1 , k ) + taur * tr2 ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + tr2 ti2 = cc ( 2 , 2 , k ) + cc ( 2 , 3 , k ) ci2 = cc ( 2 , 1 , k ) + taur * ti2 ch ( 2 , k , 1 ) = cc ( 2 , 1 , k ) + ti2 cr3 = taui * ( cc ( 1 , 2 , k ) - cc ( 1 , 3 , k )) ci3 = taui * ( cc ( 2 , 2 , k ) - cc ( 2 , 3 , k )) ch ( 1 , k , 2 ) = cr2 - ci3 ch ( 1 , k , 3 ) = cr2 + ci3 ch ( 2 , k , 2 ) = ci2 + cr3 ch ( 2 , k , 3 ) = ci2 - cr3 end do end if end subroutine passf3","tags":"","loc":"sourcefile/passf3.f90.html"},{"title":"fftpack_dct.f90 – Fortran-lang/fftpack","text":"Contents Submodules fftpack_dct Source Code fftpack_dct.f90 Source Code submodule ( fftpack ) fftpack_dct contains !> Discrete cosine transforms of types 1, 2, 3. pure module function dct_rk ( x , n , type ) result ( result ) real ( kind = rk ), intent ( in ) :: x (:) integer , intent ( in ), optional :: n integer , intent ( in ), optional :: type real ( kind = rk ), allocatable :: result (:) integer :: lenseq , lensav , i real ( kind = rk ), allocatable :: wsave (:) if ( present ( n )) then lenseq = n if ( lenseq <= size ( x )) then result = x (: lenseq ) else if ( lenseq > size ( x )) then result = [ x , ( 0.0_rk , i = 1 , lenseq - size ( x ))] end if else lenseq = size ( x ) result = x end if ! Default to DCT-2 if (. not . present ( type )) then lensav = 3 * lenseq + 15 allocate ( wsave ( lensav )) call dcosqi ( lenseq , wsave ) call dcosqb ( lenseq , result , wsave ) return end if if ( type == 1 ) then ! DCT-1 lensav = 3 * lenseq + 15 allocate ( wsave ( lensav )) call dcosti ( lenseq , wsave ) call dcost ( lenseq , result , wsave ) else if ( type == 2 ) then ! DCT-2 lensav = 3 * lenseq + 15 allocate ( wsave ( lensav )) call dcosqi ( lenseq , wsave ) call dcosqb ( lenseq , result , wsave ) else if ( type == 3 ) then ! DCT-3 lensav = 3 * lenseq + 15 allocate ( wsave ( lensav )) call dcosqi ( lenseq , wsave ) call dcosqf ( lenseq , result , wsave ) end if end function dct_rk !> Inverse discrete cosine transforms of types 1, 2, 3. pure module function idct_rk ( x , n , type ) result ( result ) real ( kind = rk ), intent ( in ) :: x (:) integer , intent ( in ), optional :: n integer , intent ( in ), optional :: type real ( kind = rk ), allocatable :: result (:) integer :: lenseq , lensav , i real ( kind = rk ), allocatable :: wsave (:) if ( present ( n )) then lenseq = n if ( lenseq <= size ( x )) then result = x (: lenseq ) else if ( lenseq > size ( x )) then result = [ x , ( 0.0_rk , i = 1 , lenseq - size ( x ))] end if else lenseq = size ( x ) result = x end if ! Default to t=2; inverse DCT-2 is DCT-3 if (. not . present ( type )) then lensav = 3 * lenseq + 15 allocate ( wsave ( lensav )) call dcosqi ( lenseq , wsave ) call dcosqf ( lenseq , result , wsave ) return end if if ( type == 1 ) then ! inverse DCT-1 is DCT-1 lensav = 3 * lenseq + 15 allocate ( wsave ( lensav )) call dcosti ( lenseq , wsave ) call dcost ( lenseq , result , wsave ) else if ( type == 2 ) then ! inverse DCT-2 is DCT-3 lensav = 3 * lenseq + 15 allocate ( wsave ( lensav )) call dcosqi ( lenseq , wsave ) call dcosqf ( lenseq , result , wsave ) else if ( type == 3 ) then ! inverse DCT-3 is DCT-2 lensav = 3 * lenseq + 15 allocate ( wsave ( lensav )) call dcosqi ( lenseq , wsave ) call dcosqb ( lenseq , result , wsave ) end if end function idct_rk end submodule fftpack_dct","tags":"","loc":"sourcefile/fftpack_dct.f90.html"},{"title":"passf.f90 – Fortran-lang/fftpack","text":"Contents Subroutines passf Source Code passf.f90 Source Code subroutine passf ( nac , ido , ip , l1 , idl1 , cc , c1 , c2 , ch , ch2 , wa ) use fftpack_kind , only : dp => rk implicit none integer , intent ( out ) :: nac integer , intent ( in ) :: ido , ip , l1 , idl1 real ( dp ), intent ( in ) :: cc ( ido , ip , l1 ), wa ( * ) real ( dp ), intent ( out ) :: c1 ( ido , l1 , ip ), c2 ( idl1 , ip ), ch ( ido , l1 , ip ) real ( dp ), intent ( inout ) :: ch2 ( idl1 , ip ) real ( dp ) :: wai , war integer :: i , idij , idj , idl , idlj , idot , idp , & ik , inc , ipp2 , ipph , j , jc , k , l , lc integer :: nt idot = ido / 2 nt = ip * idl1 ipp2 = ip + 2 ipph = ( ip + 1 ) / 2 idp = ip * ido ! if ( ido < l1 ) then do j = 2 , ipph jc = ipp2 - j do i = 1 , ido do k = 1 , l1 ch ( i , k , j ) = cc ( i , j , k ) + cc ( i , jc , k ) ch ( i , k , jc ) = cc ( i , j , k ) - cc ( i , jc , k ) end do end do end do do i = 1 , ido do k = 1 , l1 ch ( i , k , 1 ) = cc ( i , 1 , k ) end do end do else do j = 2 , ipph jc = ipp2 - j do k = 1 , l1 do i = 1 , ido ch ( i , k , j ) = cc ( i , j , k ) + cc ( i , jc , k ) ch ( i , k , jc ) = cc ( i , j , k ) - cc ( i , jc , k ) end do end do end do do k = 1 , l1 do i = 1 , ido ch ( i , k , 1 ) = cc ( i , 1 , k ) end do end do end if idl = 2 - ido inc = 0 do l = 2 , ipph lc = ipp2 - l idl = idl + ido do ik = 1 , idl1 c2 ( ik , l ) = ch2 ( ik , 1 ) + wa ( idl - 1 ) * ch2 ( ik , 2 ) c2 ( ik , lc ) = - wa ( idl ) * ch2 ( ik , ip ) end do idlj = idl inc = inc + ido do j = 3 , ipph jc = ipp2 - j idlj = idlj + inc if ( idlj > idp ) idlj = idlj - idp war = wa ( idlj - 1 ) wai = wa ( idlj ) do ik = 1 , idl1 c2 ( ik , l ) = c2 ( ik , l ) + war * ch2 ( ik , j ) c2 ( ik , lc ) = c2 ( ik , lc ) - wai * ch2 ( ik , jc ) end do end do end do do j = 2 , ipph do ik = 1 , idl1 ch2 ( ik , 1 ) = ch2 ( ik , 1 ) + ch2 ( ik , j ) end do end do do j = 2 , ipph jc = ipp2 - j do ik = 2 , idl1 , 2 ch2 ( ik - 1 , j ) = c2 ( ik - 1 , j ) - c2 ( ik , jc ) ch2 ( ik - 1 , jc ) = c2 ( ik - 1 , j ) + c2 ( ik , jc ) ch2 ( ik , j ) = c2 ( ik , j ) + c2 ( ik - 1 , jc ) ch2 ( ik , jc ) = c2 ( ik , j ) - c2 ( ik - 1 , jc ) end do end do nac = 1 if ( ido == 2 ) return nac = 0 do ik = 1 , idl1 c2 ( ik , 1 ) = ch2 ( ik , 1 ) end do do j = 2 , ip do k = 1 , l1 c1 ( 1 , k , j ) = ch ( 1 , k , j ) c1 ( 2 , k , j ) = ch ( 2 , k , j ) end do end do if ( idot > l1 ) then idj = 2 - ido do j = 2 , ip idj = idj + ido do k = 1 , l1 idij = idj do i = 4 , ido , 2 idij = idij + 2 c1 ( i - 1 , k , j ) = wa ( idij - 1 ) * ch ( i - 1 , k , j ) + wa ( idij ) & * ch ( i , k , j ) c1 ( i , k , j ) = wa ( idij - 1 ) * ch ( i , k , j ) - wa ( idij ) & * ch ( i - 1 , k , j ) end do end do end do else idij = 0 do j = 2 , ip idij = idij + 2 do i = 4 , ido , 2 idij = idij + 2 do k = 1 , l1 c1 ( i - 1 , k , j ) = wa ( idij - 1 ) * ch ( i - 1 , k , j ) + wa ( idij ) * ch ( i , k , j ) c1 ( i , k , j ) = wa ( idij - 1 ) * ch ( i , k , j ) - wa ( idij ) * ch ( i - 1 , k , j ) end do end do end do end if end subroutine passf","tags":"","loc":"sourcefile/passf.f90.html"},{"title":"passb3.f90 – Fortran-lang/fftpack","text":"Contents Subroutines passb3 Source Code passb3.f90 Source Code subroutine passb3 ( ido , l1 , cc , ch , wa1 , wa2 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 3 , l1 ), wa1 ( * ), wa2 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 3 ) real ( dp ) :: ci2 , ci3 , cr2 , cr3 , di2 , di3 , & dr2 , dr3 , ti2 , tr2 integer :: i , k real ( dp ), parameter :: taur = - 0.5_dp real ( dp ), parameter :: taui = sqrt ( 3.0_dp ) / 2.0_dp if ( ido /= 2 ) then do k = 1 , l1 do i = 2 , ido , 2 tr2 = cc ( i - 1 , 2 , k ) + cc ( i - 1 , 3 , k ) cr2 = cc ( i - 1 , 1 , k ) + taur * tr2 ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 ti2 = cc ( i , 2 , k ) + cc ( i , 3 , k ) ci2 = cc ( i , 1 , k ) + taur * ti2 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 cr3 = taui * ( cc ( i - 1 , 2 , k ) - cc ( i - 1 , 3 , k )) ci3 = taui * ( cc ( i , 2 , k ) - cc ( i , 3 , k )) dr2 = cr2 - ci3 dr3 = cr2 + ci3 di2 = ci2 + cr3 di3 = ci2 - cr3 ch ( i , k , 2 ) = wa1 ( i - 1 ) * di2 + wa1 ( i ) * dr2 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * dr2 - wa1 ( i ) * di2 ch ( i , k , 3 ) = wa2 ( i - 1 ) * di3 + wa2 ( i ) * dr3 ch ( i - 1 , k , 3 ) = wa2 ( i - 1 ) * dr3 - wa2 ( i ) * di3 end do end do else do k = 1 , l1 tr2 = cc ( 1 , 2 , k ) + cc ( 1 , 3 , k ) cr2 = cc ( 1 , 1 , k ) + taur * tr2 ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + tr2 ti2 = cc ( 2 , 2 , k ) + cc ( 2 , 3 , k ) ci2 = cc ( 2 , 1 , k ) + taur * ti2 ch ( 2 , k , 1 ) = cc ( 2 , 1 , k ) + ti2 cr3 = taui * ( cc ( 1 , 2 , k ) - cc ( 1 , 3 , k )) ci3 = taui * ( cc ( 2 , 2 , k ) - cc ( 2 , 3 , k )) ch ( 1 , k , 2 ) = cr2 - ci3 ch ( 1 , k , 3 ) = cr2 + ci3 ch ( 2 , k , 2 ) = ci2 + cr3 ch ( 2 , k , 3 ) = ci2 - cr3 end do end if end subroutine passb3","tags":"","loc":"sourcefile/passb3.f90.html"},{"title":"radb3.f90 – Fortran-lang/fftpack","text":"Contents Subroutines radb3 Source Code radb3.f90 Source Code subroutine radb3 ( ido , l1 , cc , ch , wa1 , wa2 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 3 , l1 ), wa1 ( * ), wa2 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 3 ) real ( dp ) :: ci2 , ci3 , cr2 , cr3 , di2 , di3 , & dr2 , dr3 , ti2 , tr2 integer :: i , ic , idp2 , k real ( dp ), parameter :: taur = - 0.5_dp real ( dp ), parameter :: taui = sqrt ( 3.0_dp ) / 2.0_dp do k = 1 , l1 tr2 = cc ( ido , 2 , k ) + cc ( ido , 2 , k ) cr2 = cc ( 1 , 1 , k ) + taur * tr2 ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + tr2 ci3 = taui * ( cc ( 1 , 3 , k ) + cc ( 1 , 3 , k )) ch ( 1 , k , 2 ) = cr2 - ci3 ch ( 1 , k , 3 ) = cr2 + ci3 end do if ( ido == 1 ) return idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i tr2 = cc ( i - 1 , 3 , k ) + cc ( ic - 1 , 2 , k ) cr2 = cc ( i - 1 , 1 , k ) + taur * tr2 ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 ti2 = cc ( i , 3 , k ) - cc ( ic , 2 , k ) ci2 = cc ( i , 1 , k ) + taur * ti2 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 cr3 = taui * ( cc ( i - 1 , 3 , k ) - cc ( ic - 1 , 2 , k )) ci3 = taui * ( cc ( i , 3 , k ) + cc ( ic , 2 , k )) dr2 = cr2 - ci3 dr3 = cr2 + ci3 di2 = ci2 + cr3 di3 = ci2 - cr3 ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * dr2 - wa1 ( i - 1 ) * di2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * di2 + wa1 ( i - 1 ) * dr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 2 ) * dr3 - wa2 ( i - 1 ) * di3 ch ( i , k , 3 ) = wa2 ( i - 2 ) * di3 + wa2 ( i - 1 ) * dr3 end do end do end subroutine radb3","tags":"","loc":"sourcefile/radb3.f90.html"},{"title":"dsinqb.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dsinqb Source Code dsinqb.f90 Source Code subroutine dsinqb ( n , x , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: x ( * ) real ( dp ), intent ( in ) :: wsave ( * ) integer :: k , kc , ns2 real ( dp ) :: xhold if ( n > 1 ) then ns2 = n / 2 do k = 2 , n , 2 x ( k ) = - x ( k ) end do call dcosqb ( n , x , wsave ) do k = 1 , ns2 kc = n - k xhold = x ( k ) x ( k ) = x ( kc + 1 ) x ( kc + 1 ) = xhold end do return end if x ( 1 ) = 4.0_dp * x ( 1 ) return end subroutine dsinqb","tags":"","loc":"sourcefile/dsinqb.f90.html"},{"title":"passf2.f90 – Fortran-lang/fftpack","text":"Contents Subroutines passf2 Source Code passf2.f90 Source Code subroutine passf2 ( ido , l1 , cc , ch , wa1 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 2 , l1 ), wa1 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 2 ) real ( dp ) :: ti2 , tr2 integer :: i , k if ( ido > 2 ) then do k = 1 , l1 do i = 2 , ido , 2 ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + cc ( i - 1 , 2 , k ) tr2 = cc ( i - 1 , 1 , k ) - cc ( i - 1 , 2 , k ) ch ( i , k , 1 ) = cc ( i , 1 , k ) + cc ( i , 2 , k ) ti2 = cc ( i , 1 , k ) - cc ( i , 2 , k ) ch ( i , k , 2 ) = wa1 ( i - 1 ) * ti2 - wa1 ( i ) * tr2 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * tr2 + wa1 ( i ) * ti2 end do end do else do k = 1 , l1 ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + cc ( 1 , 2 , k ) ch ( 1 , k , 2 ) = cc ( 1 , 1 , k ) - cc ( 1 , 2 , k ) ch ( 2 , k , 1 ) = cc ( 2 , 1 , k ) + cc ( 2 , 2 , k ) ch ( 2 , k , 2 ) = cc ( 2 , 1 , k ) - cc ( 2 , 2 , k ) end do end if end subroutine passf2","tags":"","loc":"sourcefile/passf2.f90.html"},{"title":"radb5.f90 – Fortran-lang/fftpack","text":"Contents Subroutines radb5 Source Code radb5.f90 Source Code subroutine radb5 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 , wa4 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 5 , l1 ), wa1 ( * ), wa2 ( * ), wa3 ( * ), wa4 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 5 ) real ( dp ) :: ci2 , ci3 , ci4 , ci5 , cr2 , cr3 , & cr4 , cr5 , di2 , di3 , di4 , di5 , dr2 , dr3 , & dr4 , dr5 real ( dp ) :: ti2 , ti3 , ti4 , ti5 , tr2 , tr3 , & tr4 , tr5 integer :: i , ic , idp2 , k real ( dp ), parameter :: pi = acos ( - 1.0_dp ) real ( dp ), parameter :: tr11 = cos ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti11 = sin ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: tr12 = cos ( 4.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti12 = sin ( 4.0_dp * pi / 5.0_dp ) do k = 1 , l1 ti5 = cc ( 1 , 3 , k ) + cc ( 1 , 3 , k ) ti4 = cc ( 1 , 5 , k ) + cc ( 1 , 5 , k ) tr2 = cc ( ido , 2 , k ) + cc ( ido , 2 , k ) tr3 = cc ( ido , 4 , k ) + cc ( ido , 4 , k ) ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + tr2 + tr3 cr2 = cc ( 1 , 1 , k ) + tr11 * tr2 + tr12 * tr3 cr3 = cc ( 1 , 1 , k ) + tr12 * tr2 + tr11 * tr3 ci5 = ti11 * ti5 + ti12 * ti4 ci4 = ti12 * ti5 - ti11 * ti4 ch ( 1 , k , 2 ) = cr2 - ci5 ch ( 1 , k , 3 ) = cr3 - ci4 ch ( 1 , k , 4 ) = cr3 + ci4 ch ( 1 , k , 5 ) = cr2 + ci5 end do if ( ido == 1 ) return idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i ti5 = cc ( i , 3 , k ) + cc ( ic , 2 , k ) ti2 = cc ( i , 3 , k ) - cc ( ic , 2 , k ) ti4 = cc ( i , 5 , k ) + cc ( ic , 4 , k ) ti3 = cc ( i , 5 , k ) - cc ( ic , 4 , k ) tr5 = cc ( i - 1 , 3 , k ) - cc ( ic - 1 , 2 , k ) tr2 = cc ( i - 1 , 3 , k ) + cc ( ic - 1 , 2 , k ) tr4 = cc ( i - 1 , 5 , k ) - cc ( ic - 1 , 4 , k ) tr3 = cc ( i - 1 , 5 , k ) + cc ( ic - 1 , 4 , k ) ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 + tr3 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 + ti3 cr2 = cc ( i - 1 , 1 , k ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( i , 1 , k ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( i - 1 , 1 , k ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( i , 1 , k ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 dr3 = cr3 - ci4 dr4 = cr3 + ci4 di3 = ci3 + cr4 di4 = ci3 - cr4 dr5 = cr2 + ci5 dr2 = cr2 - ci5 di5 = ci2 - cr5 di2 = ci2 + cr5 ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * dr2 - wa1 ( i - 1 ) * di2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * di2 + wa1 ( i - 1 ) * dr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 2 ) * dr3 - wa2 ( i - 1 ) * di3 ch ( i , k , 3 ) = wa2 ( i - 2 ) * di3 + wa2 ( i - 1 ) * dr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 2 ) * dr4 - wa3 ( i - 1 ) * di4 ch ( i , k , 4 ) = wa3 ( i - 2 ) * di4 + wa3 ( i - 1 ) * dr4 ch ( i - 1 , k , 5 ) = wa4 ( i - 2 ) * dr5 - wa4 ( i - 1 ) * di5 ch ( i , k , 5 ) = wa4 ( i - 2 ) * di5 + wa4 ( i - 1 ) * dr5 end do end do end subroutine radb5","tags":"","loc":"sourcefile/radb5.f90.html"},{"title":"passf4.f90 – Fortran-lang/fftpack","text":"Contents Subroutines passf4 Source Code passf4.f90 Source Code subroutine passf4 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 4 , l1 ), wa1 ( * ), wa2 ( * ), wa3 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 4 ) real ( dp ) :: ci2 , ci3 , ci4 , cr2 , cr3 , cr4 , & & ti1 , ti2 , ti3 , ti4 , tr1 , tr2 , tr3 , tr4 integer :: i , k if ( ido /= 2 ) then do k = 1 , l1 do i = 2 , ido , 2 ti1 = cc ( i , 1 , k ) - cc ( i , 3 , k ) ti2 = cc ( i , 1 , k ) + cc ( i , 3 , k ) ti3 = cc ( i , 2 , k ) + cc ( i , 4 , k ) tr4 = cc ( i , 2 , k ) - cc ( i , 4 , k ) tr1 = cc ( i - 1 , 1 , k ) - cc ( i - 1 , 3 , k ) tr2 = cc ( i - 1 , 1 , k ) + cc ( i - 1 , 3 , k ) ti4 = cc ( i - 1 , 4 , k ) - cc ( i - 1 , 2 , k ) tr3 = cc ( i - 1 , 2 , k ) + cc ( i - 1 , 4 , k ) ch ( i - 1 , k , 1 ) = tr2 + tr3 cr3 = tr2 - tr3 ch ( i , k , 1 ) = ti2 + ti3 ci3 = ti2 - ti3 cr2 = tr1 + tr4 cr4 = tr1 - tr4 ci2 = ti1 + ti4 ci4 = ti1 - ti4 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * cr2 + wa1 ( i ) * ci2 ch ( i , k , 2 ) = wa1 ( i - 1 ) * ci2 - wa1 ( i ) * cr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 1 ) * cr3 + wa2 ( i ) * ci3 ch ( i , k , 3 ) = wa2 ( i - 1 ) * ci3 - wa2 ( i ) * cr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 1 ) * cr4 + wa3 ( i ) * ci4 ch ( i , k , 4 ) = wa3 ( i - 1 ) * ci4 - wa3 ( i ) * cr4 end do end do else do k = 1 , l1 ti1 = cc ( 2 , 1 , k ) - cc ( 2 , 3 , k ) ti2 = cc ( 2 , 1 , k ) + cc ( 2 , 3 , k ) tr4 = cc ( 2 , 2 , k ) - cc ( 2 , 4 , k ) ti3 = cc ( 2 , 2 , k ) + cc ( 2 , 4 , k ) tr1 = cc ( 1 , 1 , k ) - cc ( 1 , 3 , k ) tr2 = cc ( 1 , 1 , k ) + cc ( 1 , 3 , k ) ti4 = cc ( 1 , 4 , k ) - cc ( 1 , 2 , k ) tr3 = cc ( 1 , 2 , k ) + cc ( 1 , 4 , k ) ch ( 1 , k , 1 ) = tr2 + tr3 ch ( 1 , k , 3 ) = tr2 - tr3 ch ( 2 , k , 1 ) = ti2 + ti3 ch ( 2 , k , 3 ) = ti2 - ti3 ch ( 1 , k , 2 ) = tr1 + tr4 ch ( 1 , k , 4 ) = tr1 - tr4 ch ( 2 , k , 2 ) = ti1 + ti4 ch ( 2 , k , 4 ) = ti1 - ti4 end do end if end subroutine passf4","tags":"","loc":"sourcefile/passf4.f90.html"},{"title":"cfftf1.f90 – Fortran-lang/fftpack","text":"Contents Subroutines cfftf1 Source Code cfftf1.f90 Source Code subroutine cfftf1 ( n , c , ch , wa , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n , ifac ( * ) real ( dp ), intent ( inout ) :: c ( * ), ch ( * ) real ( dp ), intent ( in ) :: wa ( * ) integer :: i , idl1 , ido , idot , ip , iw , ix2 , ix3 , ix4 , & k1 , l1 , l2 , n2 , na , nac , nf nf = ifac ( 2 ) na = 0 l1 = 1 iw = 1 do k1 = 1 , nf ip = ifac ( k1 + 2 ) l2 = ip * l1 ido = n / l2 idot = ido + ido idl1 = idot * l1 if ( ip == 4 ) then ix2 = iw + idot ix3 = ix2 + idot if ( na /= 0 ) then call passf4 ( idot , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 )) else call passf4 ( idot , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 )) end if na = 1 - na elseif ( ip == 2 ) then if ( na /= 0 ) then call passf2 ( idot , l1 , ch , c , wa ( iw )) else call passf2 ( idot , l1 , c , ch , wa ( iw )) end if na = 1 - na elseif ( ip == 3 ) then ix2 = iw + idot if ( na /= 0 ) then call passf3 ( idot , l1 , ch , c , wa ( iw ), wa ( ix2 )) else call passf3 ( idot , l1 , c , ch , wa ( iw ), wa ( ix2 )) end if na = 1 - na elseif ( ip /= 5 ) then if ( na /= 0 ) then call passf ( nac , idot , ip , l1 , idl1 , ch , ch , ch , c , c , wa ( iw )) else call passf ( nac , idot , ip , l1 , idl1 , c , c , c , ch , ch , wa ( iw )) end if if ( nac /= 0 ) na = 1 - na else ix2 = iw + idot ix3 = ix2 + idot ix4 = ix3 + idot if ( na /= 0 ) then call passf5 ( idot , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) else call passf5 ( idot , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) end if na = 1 - na end if l1 = l2 iw = iw + ( ip - 1 ) * idot end do if ( na == 0 ) return n2 = n + n do i = 1 , n2 c ( i ) = ch ( i ) end do end subroutine cfftf1","tags":"","loc":"sourcefile/cfftf1.f90.html"},{"title":"radfg.f90 – Fortran-lang/fftpack","text":"Contents Subroutines radfg Source Code radfg.f90 Source Code subroutine radfg ( ido , ip , l1 , idl1 , cc , c1 , c2 , ch , ch2 , wa ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , ip , l1 , idl1 real ( dp ), intent ( in ) :: wa ( * ) real ( dp ), intent ( inout ) :: cc ( ido , ip , l1 ) real ( dp ), intent ( inout ) :: c1 ( ido , l1 , ip ) real ( dp ), intent ( inout ) :: c2 ( idl1 , ip ) real ( dp ), intent ( out ) :: ch ( ido , l1 , ip ) real ( dp ), intent ( inout ) :: ch2 ( idl1 , ip ) real ( dp ) :: ai1 , ai2 , ar1 , ar1h , ar2 , ar2h , arg , & dc2 , dcp , ds2 , dsp integer :: i , ic , idij , idp2 , ik , ipp2 , & ipph , is , j , j2 , jc , k , l , lc , nbd real ( dp ), parameter :: tpi = 2.0_dp * acos ( - 1.0_dp ) ! 2 * pi arg = tpi / real ( ip , kind = dp ) dcp = cos ( arg ) dsp = sin ( arg ) ipph = ( ip + 1 ) / 2 ipp2 = ip + 2 idp2 = ido + 2 nbd = ( ido - 1 ) / 2 if ( ido == 1 ) then do ik = 1 , idl1 c2 ( ik , 1 ) = ch2 ( ik , 1 ) end do else do ik = 1 , idl1 ch2 ( ik , 1 ) = c2 ( ik , 1 ) end do do j = 2 , ip do k = 1 , l1 ch ( 1 , k , j ) = c1 ( 1 , k , j ) end do end do if ( nbd > l1 ) then is = - ido do j = 2 , ip is = is + ido do k = 1 , l1 idij = is do i = 3 , ido , 2 idij = idij + 2 ch ( i - 1 , k , j ) = wa ( idij - 1 ) * c1 ( i - 1 , k , j ) + wa ( idij ) & * c1 ( i , k , j ) ch ( i , k , j ) = wa ( idij - 1 ) * c1 ( i , k , j ) - wa ( idij ) & * c1 ( i - 1 , k , j ) end do end do end do else is = - ido do j = 2 , ip is = is + ido idij = is do i = 3 , ido , 2 idij = idij + 2 do k = 1 , l1 ch ( i - 1 , k , j ) = wa ( idij - 1 ) * c1 ( i - 1 , k , j ) + wa ( idij ) & * c1 ( i , k , j ) ch ( i , k , j ) = wa ( idij - 1 ) * c1 ( i , k , j ) - wa ( idij ) & * c1 ( i - 1 , k , j ) end do end do end do end if if ( nbd < l1 ) then do j = 2 , ipph jc = ipp2 - j do i = 3 , ido , 2 do k = 1 , l1 c1 ( i - 1 , k , j ) = ch ( i - 1 , k , j ) + ch ( i - 1 , k , jc ) c1 ( i - 1 , k , jc ) = ch ( i , k , j ) - ch ( i , k , jc ) c1 ( i , k , j ) = ch ( i , k , j ) + ch ( i , k , jc ) c1 ( i , k , jc ) = ch ( i - 1 , k , jc ) - ch ( i - 1 , k , j ) end do end do end do else do j = 2 , ipph jc = ipp2 - j do k = 1 , l1 do i = 3 , ido , 2 c1 ( i - 1 , k , j ) = ch ( i - 1 , k , j ) + ch ( i - 1 , k , jc ) c1 ( i - 1 , k , jc ) = ch ( i , k , j ) - ch ( i , k , jc ) c1 ( i , k , j ) = ch ( i , k , j ) + ch ( i , k , jc ) c1 ( i , k , jc ) = ch ( i - 1 , k , jc ) - ch ( i - 1 , k , j ) end do end do end do end if end if do j = 2 , ipph jc = ipp2 - j do k = 1 , l1 c1 ( 1 , k , j ) = ch ( 1 , k , j ) + ch ( 1 , k , jc ) c1 ( 1 , k , jc ) = ch ( 1 , k , jc ) - ch ( 1 , k , j ) end do end do ! ar1 = 1.0_dp ai1 = 0.0_dp do l = 2 , ipph lc = ipp2 - l ar1h = dcp * ar1 - dsp * ai1 ai1 = dcp * ai1 + dsp * ar1 ar1 = ar1h do ik = 1 , idl1 ch2 ( ik , l ) = c2 ( ik , 1 ) + ar1 * c2 ( ik , 2 ) ch2 ( ik , lc ) = ai1 * c2 ( ik , ip ) end do dc2 = ar1 ds2 = ai1 ar2 = ar1 ai2 = ai1 do j = 3 , ipph jc = ipp2 - j ar2h = dc2 * ar2 - ds2 * ai2 ai2 = dc2 * ai2 + ds2 * ar2 ar2 = ar2h do ik = 1 , idl1 ch2 ( ik , l ) = ch2 ( ik , l ) + ar2 * c2 ( ik , j ) ch2 ( ik , lc ) = ch2 ( ik , lc ) + ai2 * c2 ( ik , jc ) end do end do end do do j = 2 , ipph do ik = 1 , idl1 ch2 ( ik , 1 ) = ch2 ( ik , 1 ) + c2 ( ik , j ) end do end do ! if ( ido < l1 ) then do i = 1 , ido do k = 1 , l1 cc ( i , 1 , k ) = ch ( i , k , 1 ) end do end do else do k = 1 , l1 do i = 1 , ido cc ( i , 1 , k ) = ch ( i , k , 1 ) end do end do end if do j = 2 , ipph jc = ipp2 - j j2 = j + j do k = 1 , l1 cc ( ido , j2 - 2 , k ) = ch ( 1 , k , j ) cc ( 1 , j2 - 1 , k ) = ch ( 1 , k , jc ) end do end do if ( ido == 1 ) return if ( nbd < l1 ) then do j = 2 , ipph jc = ipp2 - j j2 = j + j do i = 3 , ido , 2 ic = idp2 - i do k = 1 , l1 cc ( i - 1 , j2 - 1 , k ) = ch ( i - 1 , k , j ) + ch ( i - 1 , k , jc ) cc ( ic - 1 , j2 - 2 , k ) = ch ( i - 1 , k , j ) - ch ( i - 1 , k , jc ) cc ( i , j2 - 1 , k ) = ch ( i , k , j ) + ch ( i , k , jc ) cc ( ic , j2 - 2 , k ) = ch ( i , k , jc ) - ch ( i , k , j ) end do end do end do else do j = 2 , ipph jc = ipp2 - j j2 = j + j do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i cc ( i - 1 , j2 - 1 , k ) = ch ( i - 1 , k , j ) + ch ( i - 1 , k , jc ) cc ( ic - 1 , j2 - 2 , k ) = ch ( i - 1 , k , j ) - ch ( i - 1 , k , jc ) cc ( i , j2 - 1 , k ) = ch ( i , k , j ) + ch ( i , k , jc ) cc ( ic , j2 - 2 , k ) = ch ( i , k , jc ) - ch ( i , k , j ) end do end do end do end if end subroutine radfg","tags":"","loc":"sourcefile/radfg.f90.html"},{"title":"fftpack_fftshift.f90 – Fortran-lang/fftpack","text":"Contents Submodules fftpack_fftshift Source Code fftpack_fftshift.f90 Source Code submodule ( fftpack ) fftpack_fftshift contains !> Shifts zero-frequency component to center of spectrum for `complex` type. pure module function fftshift_crk ( x ) result ( result ) complex ( kind = rk ), intent ( in ) :: x (:) complex ( kind = rk ), dimension ( size ( x )) :: result result = cshift ( x , shift =- floor ( 0.5_rk * size ( x ))) end function fftshift_crk !> Shifts zero-frequency component to center of spectrum for `real` type. pure module function fftshift_rrk ( x ) result ( result ) real ( kind = rk ), intent ( in ) :: x (:) real ( kind = rk ), dimension ( size ( x )) :: result result = cshift ( x , shift =- floor ( 0.5_rk * size ( x ))) end function fftshift_rrk end submodule fftpack_fftshift","tags":"","loc":"sourcefile/fftpack_fftshift.f90.html"},{"title":"zfftb.f90 – Fortran-lang/fftpack","text":"Contents Subroutines zfftb Source Code zfftb.f90 Source Code subroutine zfftb ( n , c , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: c ( * ) real ( dp ), intent ( inout ) :: wsave ( * ) integer :: iw1 , iw2 if ( n == 1 ) return iw1 = n + n + 1 iw2 = iw1 + n + n call cfftb1 ( n , c , wsave , wsave ( iw1 ), wsave ( iw2 )) end subroutine zfftb","tags":"","loc":"sourcefile/zfftb.f90.html"},{"title":"fftpack_irfft.f90 – Fortran-lang/fftpack","text":"Contents Submodules fftpack_irfft Source Code fftpack_irfft.f90 Source Code submodule ( fftpack ) fftpack_irfft contains !> Backward transform of a real periodic sequence. pure module function irfft_rk ( x , n ) result ( result ) real ( kind = rk ), intent ( in ) :: x (:) integer , intent ( in ), optional :: n real ( kind = rk ), allocatable :: result (:) integer :: lenseq , lensav , i real ( kind = rk ), allocatable :: wsave (:) if ( present ( n )) then lenseq = n if ( lenseq <= size ( x )) then result = x (: lenseq ) else if ( lenseq > size ( x )) then result = [ x , ( 0.0_rk , i = 1 , lenseq - size ( x ))] end if else lenseq = size ( x ) result = x end if !> Initialize FFT lensav = 2 * lenseq + 15 allocate ( wsave ( lensav )) call dffti ( lenseq , wsave ) !> Backward transformation call dfftb ( lenseq , result , wsave ) end function irfft_rk end submodule fftpack_irfft","tags":"","loc":"sourcefile/fftpack_irfft.f90.html"},{"title":"passf5.f90 – Fortran-lang/fftpack","text":"Contents Subroutines passf5 Source Code passf5.f90 Source Code subroutine passf5 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 , wa4 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 5 , l1 ), wa1 ( * ), wa2 ( * ), wa3 ( * ), wa4 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 5 ) real ( dp ) :: ci2 , ci3 , ci4 , ci5 , cr2 , cr3 , & cr4 , cr5 , di2 , di3 , di4 , di5 , dr2 , dr3 , & dr4 , dr5 real ( dp ) :: ti2 , ti3 , ti4 , ti5 , tr2 , tr3 , & tr4 , tr5 integer :: i , k real ( dp ), parameter :: pi = acos ( - 1.0_dp ) real ( dp ), parameter :: tr11 = cos ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti11 = - sin ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: tr12 = cos ( 4.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti12 = - sin ( 4.0_dp * pi / 5.0_dp ) if ( ido /= 2 ) then do k = 1 , l1 do i = 2 , ido , 2 ti5 = cc ( i , 2 , k ) - cc ( i , 5 , k ) ti2 = cc ( i , 2 , k ) + cc ( i , 5 , k ) ti4 = cc ( i , 3 , k ) - cc ( i , 4 , k ) ti3 = cc ( i , 3 , k ) + cc ( i , 4 , k ) tr5 = cc ( i - 1 , 2 , k ) - cc ( i - 1 , 5 , k ) tr2 = cc ( i - 1 , 2 , k ) + cc ( i - 1 , 5 , k ) tr4 = cc ( i - 1 , 3 , k ) - cc ( i - 1 , 4 , k ) tr3 = cc ( i - 1 , 3 , k ) + cc ( i - 1 , 4 , k ) ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 + tr3 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 + ti3 cr2 = cc ( i - 1 , 1 , k ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( i , 1 , k ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( i - 1 , 1 , k ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( i , 1 , k ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 dr3 = cr3 - ci4 dr4 = cr3 + ci4 di3 = ci3 + cr4 di4 = ci3 - cr4 dr5 = cr2 + ci5 dr2 = cr2 - ci5 di5 = ci2 - cr5 di2 = ci2 + cr5 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * dr2 + wa1 ( i ) * di2 ch ( i , k , 2 ) = wa1 ( i - 1 ) * di2 - wa1 ( i ) * dr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 1 ) * dr3 + wa2 ( i ) * di3 ch ( i , k , 3 ) = wa2 ( i - 1 ) * di3 - wa2 ( i ) * dr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 1 ) * dr4 + wa3 ( i ) * di4 ch ( i , k , 4 ) = wa3 ( i - 1 ) * di4 - wa3 ( i ) * dr4 ch ( i - 1 , k , 5 ) = wa4 ( i - 1 ) * dr5 + wa4 ( i ) * di5 ch ( i , k , 5 ) = wa4 ( i - 1 ) * di5 - wa4 ( i ) * dr5 end do end do else do k = 1 , l1 ti5 = cc ( 2 , 2 , k ) - cc ( 2 , 5 , k ) ti2 = cc ( 2 , 2 , k ) + cc ( 2 , 5 , k ) ti4 = cc ( 2 , 3 , k ) - cc ( 2 , 4 , k ) ti3 = cc ( 2 , 3 , k ) + cc ( 2 , 4 , k ) tr5 = cc ( 1 , 2 , k ) - cc ( 1 , 5 , k ) tr2 = cc ( 1 , 2 , k ) + cc ( 1 , 5 , k ) tr4 = cc ( 1 , 3 , k ) - cc ( 1 , 4 , k ) tr3 = cc ( 1 , 3 , k ) + cc ( 1 , 4 , k ) ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + tr2 + tr3 ch ( 2 , k , 1 ) = cc ( 2 , 1 , k ) + ti2 + ti3 cr2 = cc ( 1 , 1 , k ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( 2 , 1 , k ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( 1 , 1 , k ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( 2 , 1 , k ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 ch ( 1 , k , 2 ) = cr2 - ci5 ch ( 1 , k , 5 ) = cr2 + ci5 ch ( 2 , k , 2 ) = ci2 + cr5 ch ( 2 , k , 3 ) = ci3 + cr4 ch ( 1 , k , 3 ) = cr3 - ci4 ch ( 1 , k , 4 ) = cr3 + ci4 ch ( 2 , k , 4 ) = ci3 - cr4 ch ( 2 , k , 5 ) = ci2 - cr5 end do end if end subroutine passf5","tags":"","loc":"sourcefile/passf5.f90.html"},{"title":"passb4.f90 – Fortran-lang/fftpack","text":"Contents Subroutines passb4 Source Code passb4.f90 Source Code subroutine passb4 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 4 , l1 ), wa1 ( * ), wa2 ( * ), wa3 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 4 ) real ( dp ) :: ci2 , ci3 , ci4 , cr2 , cr3 , cr4 , & & ti1 , ti2 , ti3 , ti4 , tr1 , tr2 , tr3 , tr4 integer :: i , k if ( ido /= 2 ) then do k = 1 , l1 do i = 2 , ido , 2 ti1 = cc ( i , 1 , k ) - cc ( i , 3 , k ) ti2 = cc ( i , 1 , k ) + cc ( i , 3 , k ) ti3 = cc ( i , 2 , k ) + cc ( i , 4 , k ) tr4 = cc ( i , 4 , k ) - cc ( i , 2 , k ) tr1 = cc ( i - 1 , 1 , k ) - cc ( i - 1 , 3 , k ) tr2 = cc ( i - 1 , 1 , k ) + cc ( i - 1 , 3 , k ) ti4 = cc ( i - 1 , 2 , k ) - cc ( i - 1 , 4 , k ) tr3 = cc ( i - 1 , 2 , k ) + cc ( i - 1 , 4 , k ) ch ( i - 1 , k , 1 ) = tr2 + tr3 cr3 = tr2 - tr3 ch ( i , k , 1 ) = ti2 + ti3 ci3 = ti2 - ti3 cr2 = tr1 + tr4 cr4 = tr1 - tr4 ci2 = ti1 + ti4 ci4 = ti1 - ti4 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * cr2 - wa1 ( i ) * ci2 ch ( i , k , 2 ) = wa1 ( i - 1 ) * ci2 + wa1 ( i ) * cr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 1 ) * cr3 - wa2 ( i ) * ci3 ch ( i , k , 3 ) = wa2 ( i - 1 ) * ci3 + wa2 ( i ) * cr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 1 ) * cr4 - wa3 ( i ) * ci4 ch ( i , k , 4 ) = wa3 ( i - 1 ) * ci4 + wa3 ( i ) * cr4 end do end do else do k = 1 , l1 ti1 = cc ( 2 , 1 , k ) - cc ( 2 , 3 , k ) ti2 = cc ( 2 , 1 , k ) + cc ( 2 , 3 , k ) tr4 = cc ( 2 , 4 , k ) - cc ( 2 , 2 , k ) ti3 = cc ( 2 , 2 , k ) + cc ( 2 , 4 , k ) tr1 = cc ( 1 , 1 , k ) - cc ( 1 , 3 , k ) tr2 = cc ( 1 , 1 , k ) + cc ( 1 , 3 , k ) ti4 = cc ( 1 , 2 , k ) - cc ( 1 , 4 , k ) tr3 = cc ( 1 , 2 , k ) + cc ( 1 , 4 , k ) ch ( 1 , k , 1 ) = tr2 + tr3 ch ( 1 , k , 3 ) = tr2 - tr3 ch ( 2 , k , 1 ) = ti2 + ti3 ch ( 2 , k , 3 ) = ti2 - ti3 ch ( 1 , k , 2 ) = tr1 + tr4 ch ( 1 , k , 4 ) = tr1 - tr4 ch ( 2 , k , 2 ) = ti1 + ti4 ch ( 2 , k , 4 ) = ti1 - ti4 end do end if end subroutine passb4","tags":"","loc":"sourcefile/passb4.f90.html"},{"title":"dsinqf.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dsinqf Source Code dsinqf.f90 Source Code subroutine dsinqf ( n , x , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: x ( * ) real ( dp ), intent ( in ) :: wsave ( * ) integer :: k , kc , ns2 real ( dp ) :: xhold if ( n == 1 ) return ns2 = n / 2 do k = 1 , ns2 kc = n - k xhold = x ( k ) x ( k ) = x ( kc + 1 ) x ( kc + 1 ) = xhold end do call dcosqf ( n , x , wsave ) do k = 2 , n , 2 x ( k ) = - x ( k ) end do end subroutine dsinqf","tags":"","loc":"sourcefile/dsinqf.f90.html"},{"title":"zffti.f90 – Fortran-lang/fftpack","text":"Contents Subroutines zffti Source Code zffti.f90 Source Code subroutine zffti ( n , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wsave ( * ) integer :: iw1 , iw2 if ( n == 1 ) return iw1 = n + n + 1 iw2 = iw1 + n + n call cffti1 ( n , wsave ( iw1 ), wsave ( iw2 )) end subroutine zffti","tags":"","loc":"sourcefile/zffti.f90.html"},{"title":"passb2.f90 – Fortran-lang/fftpack","text":"Contents Subroutines passb2 Source Code passb2.f90 Source Code subroutine passb2 ( ido , l1 , cc , ch , wa1 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 2 , l1 ), wa1 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 2 ) real ( dp ) :: ti2 , tr2 integer :: i , k if ( ido > 2 ) then do k = 1 , l1 do i = 2 , ido , 2 ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + cc ( i - 1 , 2 , k ) tr2 = cc ( i - 1 , 1 , k ) - cc ( i - 1 , 2 , k ) ch ( i , k , 1 ) = cc ( i , 1 , k ) + cc ( i , 2 , k ) ti2 = cc ( i , 1 , k ) - cc ( i , 2 , k ) ch ( i , k , 2 ) = wa1 ( i - 1 ) * ti2 + wa1 ( i ) * tr2 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * tr2 - wa1 ( i ) * ti2 end do end do else do k = 1 , l1 ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + cc ( 1 , 2 , k ) ch ( 1 , k , 2 ) = cc ( 1 , 1 , k ) - cc ( 1 , 2 , k ) ch ( 2 , k , 1 ) = cc ( 2 , 1 , k ) + cc ( 2 , 2 , k ) ch ( 2 , k , 2 ) = cc ( 2 , 1 , k ) - cc ( 2 , 2 , k ) end do end if end subroutine passb2","tags":"","loc":"sourcefile/passb2.f90.html"},{"title":"radb4.f90 – Fortran-lang/fftpack","text":"Contents Subroutines radb4 Source Code radb4.f90 Source Code subroutine radb4 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 4 , l1 ), wa1 ( * ), wa2 ( * ), wa3 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 4 ) real ( dp ) :: ci2 , ci3 , ci4 , cr2 , cr3 , cr4 , & ti1 , ti2 , ti3 , ti4 , tr1 , tr2 , tr3 , & tr4 integer :: i , ic , idp2 , k real ( dp ), parameter :: sqrt2 = sqrt ( 2.0_dp ) do k = 1 , l1 tr1 = cc ( 1 , 1 , k ) - cc ( ido , 4 , k ) tr2 = cc ( 1 , 1 , k ) + cc ( ido , 4 , k ) tr3 = cc ( ido , 2 , k ) + cc ( ido , 2 , k ) tr4 = cc ( 1 , 3 , k ) + cc ( 1 , 3 , k ) ch ( 1 , k , 1 ) = tr2 + tr3 ch ( 1 , k , 2 ) = tr1 - tr4 ch ( 1 , k , 3 ) = tr2 - tr3 ch ( 1 , k , 4 ) = tr1 + tr4 end do if ( ido < 2 ) return if ( ido /= 2 ) then idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i ti1 = cc ( i , 1 , k ) + cc ( ic , 4 , k ) ti2 = cc ( i , 1 , k ) - cc ( ic , 4 , k ) ti3 = cc ( i , 3 , k ) - cc ( ic , 2 , k ) tr4 = cc ( i , 3 , k ) + cc ( ic , 2 , k ) tr1 = cc ( i - 1 , 1 , k ) - cc ( ic - 1 , 4 , k ) tr2 = cc ( i - 1 , 1 , k ) + cc ( ic - 1 , 4 , k ) ti4 = cc ( i - 1 , 3 , k ) - cc ( ic - 1 , 2 , k ) tr3 = cc ( i - 1 , 3 , k ) + cc ( ic - 1 , 2 , k ) ch ( i - 1 , k , 1 ) = tr2 + tr3 cr3 = tr2 - tr3 ch ( i , k , 1 ) = ti2 + ti3 ci3 = ti2 - ti3 cr2 = tr1 - tr4 cr4 = tr1 + tr4 ci2 = ti1 + ti4 ci4 = ti1 - ti4 ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * cr2 - wa1 ( i - 1 ) * ci2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * ci2 + wa1 ( i - 1 ) * cr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 2 ) * cr3 - wa2 ( i - 1 ) * ci3 ch ( i , k , 3 ) = wa2 ( i - 2 ) * ci3 + wa2 ( i - 1 ) * cr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 2 ) * cr4 - wa3 ( i - 1 ) * ci4 ch ( i , k , 4 ) = wa3 ( i - 2 ) * ci4 + wa3 ( i - 1 ) * cr4 end do end do if ( mod ( ido , 2 ) == 1 ) return end if do k = 1 , l1 ti1 = cc ( 1 , 2 , k ) + cc ( 1 , 4 , k ) ti2 = cc ( 1 , 4 , k ) - cc ( 1 , 2 , k ) tr1 = cc ( ido , 1 , k ) - cc ( ido , 3 , k ) tr2 = cc ( ido , 1 , k ) + cc ( ido , 3 , k ) ch ( ido , k , 1 ) = tr2 + tr2 ch ( ido , k , 2 ) = sqrt2 * ( tr1 - ti1 ) ch ( ido , k , 3 ) = ti2 + ti2 ch ( ido , k , 4 ) = - sqrt2 * ( tr1 + ti1 ) end do end subroutine radb4","tags":"","loc":"sourcefile/radb4.f90.html"},{"title":"dcosqi.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dcosqi Source Code dcosqi.f90 Source Code subroutine dcosqi ( n , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wsave ( * ) real ( dp ) :: dt , fk integer :: k real ( dp ), parameter :: pih = acos ( - 1.0_dp ) / 2.0_dp ! pi / 2 dt = pih / real ( n , kind = dp ) fk = 0.0_dp do k = 1 , n fk = fk + 1.0_dp wsave ( k ) = cos ( fk * dt ) end do call dffti ( n , wsave ( n + 1 )) end subroutine dcosqi","tags":"","loc":"sourcefile/dcosqi.f90.html"},{"title":"radb2.f90 – Fortran-lang/fftpack","text":"Contents Subroutines radb2 Source Code radb2.f90 Source Code subroutine radb2 ( ido , l1 , cc , ch , wa1 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 2 , l1 ), wa1 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 2 ) real ( dp ) :: ti2 , tr2 integer :: i , ic , idp2 , k do k = 1 , l1 ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + cc ( ido , 2 , k ) ch ( 1 , k , 2 ) = cc ( 1 , 1 , k ) - cc ( ido , 2 , k ) end do if ( ido < 2 ) return if ( ido /= 2 ) then idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + cc ( ic - 1 , 2 , k ) tr2 = cc ( i - 1 , 1 , k ) - cc ( ic - 1 , 2 , k ) ch ( i , k , 1 ) = cc ( i , 1 , k ) - cc ( ic , 2 , k ) ti2 = cc ( i , 1 , k ) + cc ( ic , 2 , k ) ch ( i - 1 , k , 2 ) = wa1 ( i - 2 ) * tr2 - wa1 ( i - 1 ) * ti2 ch ( i , k , 2 ) = wa1 ( i - 2 ) * ti2 + wa1 ( i - 1 ) * tr2 end do end do if ( mod ( ido , 2 ) == 1 ) return end if do k = 1 , l1 ch ( ido , k , 1 ) = cc ( ido , 1 , k ) + cc ( ido , 1 , k ) ch ( ido , k , 2 ) = - ( cc ( 1 , 2 , k ) + cc ( 1 , 2 , k )) end do end subroutine radb2","tags":"","loc":"sourcefile/radb2.f90.html"},{"title":"radf3.f90 – Fortran-lang/fftpack","text":"Contents Subroutines radf3 Source Code radf3.f90 Source Code subroutine radf3 ( ido , l1 , cc , ch , wa1 , wa2 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , l1 , 3 ), wa1 ( * ), wa2 ( * ) real ( dp ), intent ( out ) :: ch ( ido , 3 , l1 ) real ( dp ) :: ci2 , cr2 , di2 , di3 , dr2 , dr3 , & ti2 , ti3 , tr2 , tr3 integer :: i , ic , idp2 , k real ( dp ), parameter :: taur = - 0.5_dp ! note: original comment said this was -sqrt(3)/2 but value was 0.86602540378443864676d0 real ( dp ), parameter :: taui = sqrt ( 3.0_dp ) / 2.0_dp do k = 1 , l1 cr2 = cc ( 1 , k , 2 ) + cc ( 1 , k , 3 ) ch ( 1 , 1 , k ) = cc ( 1 , k , 1 ) + cr2 ch ( 1 , 3 , k ) = taui * ( cc ( 1 , k , 3 ) - cc ( 1 , k , 2 )) ch ( ido , 2 , k ) = cc ( 1 , k , 1 ) + taur * cr2 end do if ( ido == 1 ) return idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i dr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) di2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) dr3 = wa2 ( i - 2 ) * cc ( i - 1 , k , 3 ) + wa2 ( i - 1 ) * cc ( i , k , 3 ) di3 = wa2 ( i - 2 ) * cc ( i , k , 3 ) - wa2 ( i - 1 ) * cc ( i - 1 , k , 3 ) cr2 = dr2 + dr3 ci2 = di2 + di3 ch ( i - 1 , 1 , k ) = cc ( i - 1 , k , 1 ) + cr2 ch ( i , 1 , k ) = cc ( i , k , 1 ) + ci2 tr2 = cc ( i - 1 , k , 1 ) + taur * cr2 ti2 = cc ( i , k , 1 ) + taur * ci2 tr3 = taui * ( di2 - di3 ) ti3 = taui * ( dr3 - dr2 ) ch ( i - 1 , 3 , k ) = tr2 + tr3 ch ( ic - 1 , 2 , k ) = tr2 - tr3 ch ( i , 3 , k ) = ti2 + ti3 ch ( ic , 2 , k ) = ti3 - ti2 end do end do end subroutine radf3","tags":"","loc":"sourcefile/radf3.f90.html"},{"title":"zfftf.f90 – Fortran-lang/fftpack","text":"Contents Subroutines zfftf Source Code zfftf.f90 Source Code subroutine zfftf ( n , c , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: c ( * ) real ( dp ), intent ( inout ) :: wsave ( * ) integer :: iw1 , iw2 if ( n == 1 ) return iw1 = n + n + 1 iw2 = iw1 + n + n call cfftf1 ( n , c , wsave , wsave ( iw1 ), wsave ( iw2 )) end subroutine zfftf","tags":"","loc":"sourcefile/zfftf.f90.html"},{"title":"fftpack_utils.f90 – Fortran-lang/fftpack","text":"Contents Submodules fftpack_utils Source Code fftpack_utils.f90 Source Code submodule ( fftpack ) fftpack_utils contains !> Returns an integer array with the frequency values involved in the !> performed FFT, ordered in the standard way (zero first, then positive !> frequencies, then the negative ones). pure module function fftfreq ( n ) result ( out ) integer , intent ( in ) :: n integer , dimension ( n ) :: out integer :: i out ( 1 ) = 0 if ( n == 1 ) return if ( mod ( n , 2 ) == 0 ) then ! n even, smallest n = 2 do i = 2 , n / 2 out ( i ) = i - 1 end do out ( n / 2 + 1 ) = - n / 2 do i = n / 2 + 2 , n ! only enters if n/2+2 <= n out ( i ) = out ( i - 1 ) + 1 end do else ! n odd, smallest n = 3 do i = 2 , n / 2 + 1 out ( i ) = i - 1 end do out ( n / 2 + 2 ) = - out ( n / 2 + 1 ) do i = n / 2 + 3 , n ! only enters if n/2+3 <= n out ( i ) = out ( i - 1 ) + 1 end do end if end function fftfreq !> Returns an integer array with the frequency values involved in the !> performed real FFT, ordered in the standard way (zero first, then !> positive frequencies, then, if applicable, the negative one). pure module function rfftfreq ( n ) result ( out ) integer , intent ( in ) :: n integer , dimension ( n ) :: out integer :: i out ( 1 ) = 0 if ( n == 1 ) return if ( mod ( n , 2 ) == 0 ) then ! n even, smallest n = 2 do i = 2 , n - 2 , 2 out ( i ) = out ( i - 1 ) + 1 out ( i + 1 ) = out ( i ) end do out ( n ) = - n / 2 else ! n odd, smallest n = 3 do i = 2 , n - 1 , 2 out ( i ) = out ( i - 1 ) + 1 out ( i + 1 ) = out ( i ) end do end if end function rfftfreq end submodule fftpack_utils","tags":"","loc":"sourcefile/fftpack_utils.f90.html"},{"title":"radf2.f90 – Fortran-lang/fftpack","text":"Contents Subroutines radf2 Source Code radf2.f90 Source Code subroutine radf2 ( ido , l1 , cc , ch , wa1 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , l1 , 2 ), wa1 ( * ) real ( dp ), intent ( out ) :: ch ( ido , 2 , l1 ) real ( dp ) :: ti2 , tr2 integer :: i , ic , idp2 , k do k = 1 , l1 ch ( 1 , 1 , k ) = cc ( 1 , k , 1 ) + cc ( 1 , k , 2 ) ch ( ido , 2 , k ) = cc ( 1 , k , 1 ) - cc ( 1 , k , 2 ) end do if ( ido < 2 ) return if ( ido /= 2 ) then idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i tr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) ti2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) ch ( i , 1 , k ) = cc ( i , k , 1 ) + ti2 ch ( ic , 2 , k ) = ti2 - cc ( i , k , 1 ) ch ( i - 1 , 1 , k ) = cc ( i - 1 , k , 1 ) + tr2 ch ( ic - 1 , 2 , k ) = cc ( i - 1 , k , 1 ) - tr2 end do end do if ( mod ( ido , 2 ) == 1 ) return end if do k = 1 , l1 ch ( 1 , 2 , k ) = - cc ( ido , k , 2 ) ch ( ido , 1 , k ) = cc ( ido , k , 1 ) end do end subroutine radf2","tags":"","loc":"sourcefile/radf2.f90.html"},{"title":"dffti.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dffti Source Code dffti.f90 Source Code subroutine dffti ( n , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wsave ( * ) if ( n == 1 ) return call rffti1 ( n , wsave ( n + 1 ), wsave ( 2 * n + 1 )) end subroutine dffti","tags":"","loc":"sourcefile/dffti.f90.html"},{"title":"sint1.f90 – Fortran-lang/fftpack","text":"Contents Subroutines sint1 Source Code sint1.f90 Source Code subroutine sint1 ( n , war , was , xh , x , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n , ifac ( * ) real ( dp ), intent ( in ) :: was ( * ) real ( dp ), intent ( inout ) :: war ( * ), x ( * ) real ( dp ), intent ( out ) :: xh ( * ) integer :: i , k , kc , modn , np1 , ns2 real ( dp ) :: t1 , t2 , xhold real ( dp ), parameter :: sqrt3 = sqrt ( 3.0_dp ) do i = 1 , n xh ( i ) = war ( i ) war ( i ) = x ( i ) end do if ( n < 2 ) then xh ( 1 ) = xh ( 1 ) + xh ( 1 ) elseif ( n == 2 ) then xhold = sqrt3 * ( xh ( 1 ) + xh ( 2 )) xh ( 2 ) = sqrt3 * ( xh ( 1 ) - xh ( 2 )) xh ( 1 ) = xhold else np1 = n + 1 ns2 = n / 2 x ( 1 ) = 0.0_dp do k = 1 , ns2 kc = np1 - k t1 = xh ( k ) - xh ( kc ) t2 = was ( k ) * ( xh ( k ) + xh ( kc )) x ( k + 1 ) = t1 + t2 x ( kc + 1 ) = t2 - t1 end do modn = mod ( n , 2 ) if ( modn /= 0 ) x ( ns2 + 2 ) = 4.0_dp * xh ( ns2 + 1 ) call rfftf1 ( np1 , x , xh , war , ifac ) xh ( 1 ) = 0.5_dp * x ( 1 ) do i = 3 , n , 2 xh ( i - 1 ) = - x ( i ) xh ( i ) = xh ( i - 2 ) + x ( i - 1 ) end do if ( modn == 0 ) xh ( n ) = - x ( n + 1 ) end if do i = 1 , n x ( i ) = war ( i ) war ( i ) = xh ( i ) end do end subroutine sint1","tags":"","loc":"sourcefile/sint1.f90.html"},{"title":"dzffti.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dzffti Source Code dzffti.f90 Source Code subroutine dzffti ( n , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wsave ( * ) if ( n == 1 ) return call ezfft1 ( n , wsave ( 2 * n + 1 ), wsave ( 3 * n + 1 )) end subroutine dzffti","tags":"","loc":"sourcefile/dzffti.f90.html"},{"title":"dcost.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dcost Source Code dcost.f90 Source Code subroutine dcost ( n , x , wsave ) use fftpack_kind , only : rk implicit none integer , intent ( in ) :: n real ( rk ), intent ( inout ) :: wsave ( * ) real ( rk ), intent ( inout ) :: x ( * ) real ( rk ) :: c1 , t1 , t2 , tx2 , x1h , x1p3 , & xi , xim2 integer :: i , k , kc , modn , nm1 , np1 , ns2 nm1 = n - 1 np1 = n + 1 ns2 = n / 2 if ( n < 2 ) return if ( n == 2 ) then x1h = x ( 1 ) + x ( 2 ) x ( 2 ) = x ( 1 ) - x ( 2 ) x ( 1 ) = x1h return elseif ( n > 3 ) then c1 = x ( 1 ) - x ( n ) x ( 1 ) = x ( 1 ) + x ( n ) do k = 2 , ns2 kc = np1 - k t1 = x ( k ) + x ( kc ) t2 = x ( k ) - x ( kc ) c1 = c1 + wsave ( kc ) * t2 t2 = wsave ( k ) * t2 x ( k ) = t1 - t2 x ( kc ) = t1 + t2 end do modn = mod ( n , 2 ) if ( modn /= 0 ) x ( ns2 + 1 ) = x ( ns2 + 1 ) + x ( ns2 + 1 ) call dfftf ( nm1 , x , wsave ( n + 1 )) xim2 = x ( 2 ) x ( 2 ) = c1 do i = 4 , n , 2 xi = x ( i ) x ( i ) = x ( i - 2 ) - x ( i - 1 ) x ( i - 1 ) = xim2 xim2 = xi end do if ( modn /= 0 ) x ( n ) = xim2 return end if x1p3 = x ( 1 ) + x ( 3 ) tx2 = x ( 2 ) + x ( 2 ) x ( 2 ) = x ( 1 ) - x ( 3 ) x ( 1 ) = x1p3 + tx2 x ( 3 ) = x1p3 - tx2 end subroutine dcost","tags":"","loc":"sourcefile/dcost.f90.html"},{"title":"passb5.f90 – Fortran-lang/fftpack","text":"Contents Subroutines passb5 Source Code passb5.f90 Source Code subroutine passb5 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 , wa4 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , 5 , l1 ), wa1 ( * ), wa2 ( * ), wa3 ( * ), wa4 ( * ) real ( dp ), intent ( out ) :: ch ( ido , l1 , 5 ) real ( dp ) :: ci2 , ci3 , ci4 , ci5 , cr2 , cr3 , & cr4 , cr5 , di2 , di3 , di4 , di5 , dr2 , dr3 , & dr4 , dr5 real ( dp ) :: ti2 , ti3 , ti4 , ti5 , tr2 , tr3 , & tr4 , tr5 integer :: i , k real ( dp ), parameter :: pi = acos ( - 1.0_dp ) real ( dp ), parameter :: tr11 = cos ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti11 = sin ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: tr12 = cos ( 4.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti12 = sin ( 4.0_dp * pi / 5.0_dp ) if ( ido /= 2 ) then do k = 1 , l1 do i = 2 , ido , 2 ti5 = cc ( i , 2 , k ) - cc ( i , 5 , k ) ti2 = cc ( i , 2 , k ) + cc ( i , 5 , k ) ti4 = cc ( i , 3 , k ) - cc ( i , 4 , k ) ti3 = cc ( i , 3 , k ) + cc ( i , 4 , k ) tr5 = cc ( i - 1 , 2 , k ) - cc ( i - 1 , 5 , k ) tr2 = cc ( i - 1 , 2 , k ) + cc ( i - 1 , 5 , k ) tr4 = cc ( i - 1 , 3 , k ) - cc ( i - 1 , 4 , k ) tr3 = cc ( i - 1 , 3 , k ) + cc ( i - 1 , 4 , k ) ch ( i - 1 , k , 1 ) = cc ( i - 1 , 1 , k ) + tr2 + tr3 ch ( i , k , 1 ) = cc ( i , 1 , k ) + ti2 + ti3 cr2 = cc ( i - 1 , 1 , k ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( i , 1 , k ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( i - 1 , 1 , k ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( i , 1 , k ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 dr3 = cr3 - ci4 dr4 = cr3 + ci4 di3 = ci3 + cr4 di4 = ci3 - cr4 dr5 = cr2 + ci5 dr2 = cr2 - ci5 di5 = ci2 - cr5 di2 = ci2 + cr5 ch ( i - 1 , k , 2 ) = wa1 ( i - 1 ) * dr2 - wa1 ( i ) * di2 ch ( i , k , 2 ) = wa1 ( i - 1 ) * di2 + wa1 ( i ) * dr2 ch ( i - 1 , k , 3 ) = wa2 ( i - 1 ) * dr3 - wa2 ( i ) * di3 ch ( i , k , 3 ) = wa2 ( i - 1 ) * di3 + wa2 ( i ) * dr3 ch ( i - 1 , k , 4 ) = wa3 ( i - 1 ) * dr4 - wa3 ( i ) * di4 ch ( i , k , 4 ) = wa3 ( i - 1 ) * di4 + wa3 ( i ) * dr4 ch ( i - 1 , k , 5 ) = wa4 ( i - 1 ) * dr5 - wa4 ( i ) * di5 ch ( i , k , 5 ) = wa4 ( i - 1 ) * di5 + wa4 ( i ) * dr5 end do end do else do k = 1 , l1 ti5 = cc ( 2 , 2 , k ) - cc ( 2 , 5 , k ) ti2 = cc ( 2 , 2 , k ) + cc ( 2 , 5 , k ) ti4 = cc ( 2 , 3 , k ) - cc ( 2 , 4 , k ) ti3 = cc ( 2 , 3 , k ) + cc ( 2 , 4 , k ) tr5 = cc ( 1 , 2 , k ) - cc ( 1 , 5 , k ) tr2 = cc ( 1 , 2 , k ) + cc ( 1 , 5 , k ) tr4 = cc ( 1 , 3 , k ) - cc ( 1 , 4 , k ) tr3 = cc ( 1 , 3 , k ) + cc ( 1 , 4 , k ) ch ( 1 , k , 1 ) = cc ( 1 , 1 , k ) + tr2 + tr3 ch ( 2 , k , 1 ) = cc ( 2 , 1 , k ) + ti2 + ti3 cr2 = cc ( 1 , 1 , k ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( 2 , 1 , k ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( 1 , 1 , k ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( 2 , 1 , k ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 ch ( 1 , k , 2 ) = cr2 - ci5 ch ( 1 , k , 5 ) = cr2 + ci5 ch ( 2 , k , 2 ) = ci2 + cr5 ch ( 2 , k , 3 ) = ci3 + cr4 ch ( 1 , k , 3 ) = cr3 - ci4 ch ( 1 , k , 4 ) = cr3 + ci4 ch ( 2 , k , 4 ) = ci3 - cr4 ch ( 2 , k , 5 ) = ci2 - cr5 end do end if end subroutine passb5","tags":"","loc":"sourcefile/passb5.f90.html"},{"title":"dfftb.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dfftb Source Code dfftb.f90 Source Code subroutine dfftb ( n , r , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: r ( * ) real ( dp ), intent ( inout ) :: wsave ( * ) if ( n == 1 ) return call rfftb1 ( n , r , wsave , wsave ( n + 1 ), wsave ( 2 * n + 1 )) end subroutine dfftb","tags":"","loc":"sourcefile/dfftb.f90.html"},{"title":"rfftb1.f90 – Fortran-lang/fftpack","text":"Contents Subroutines rfftb1 Source Code rfftb1.f90 Source Code subroutine rfftb1 ( n , c , ch , wa , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: c ( * ) real ( dp ), intent ( in ) :: wa ( * ) real ( dp ), intent ( inout ) :: ch ( * ) integer , intent ( in ) :: ifac ( * ) integer :: i , idl1 , ido , ip , iw , ix2 , ix3 , ix4 , k1 , & l1 , l2 , na , nf nf = ifac ( 2 ) na = 0 l1 = 1 iw = 1 do k1 = 1 , nf ip = ifac ( k1 + 2 ) l2 = ip * l1 ido = n / l2 idl1 = ido * l1 if ( ip == 4 ) then ix2 = iw + ido ix3 = ix2 + ido if ( na /= 0 ) then call radb4 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 )) else call radb4 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 )) end if na = 1 - na elseif ( ip == 2 ) then if ( na /= 0 ) then call radb2 ( ido , l1 , ch , c , wa ( iw )) else call radb2 ( ido , l1 , c , ch , wa ( iw )) end if na = 1 - na elseif ( ip == 3 ) then ix2 = iw + ido if ( na /= 0 ) then call radb3 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 )) else call radb3 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 )) end if na = 1 - na elseif ( ip /= 5 ) then if ( na /= 0 ) then call radbg ( ido , ip , l1 , idl1 , ch , ch , ch , c , c , wa ( iw )) else call radbg ( ido , ip , l1 , idl1 , c , c , c , ch , ch , wa ( iw )) end if if ( ido == 1 ) na = 1 - na else ix2 = iw + ido ix3 = ix2 + ido ix4 = ix3 + ido if ( na /= 0 ) then call radb5 ( ido , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) else call radb5 ( ido , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) end if na = 1 - na end if l1 = l2 iw = iw + ( ip - 1 ) * ido end do if ( na == 0 ) return do i = 1 , n c ( i ) = ch ( i ) end do end subroutine rfftb1","tags":"","loc":"sourcefile/rfftb1.f90.html"},{"title":"dcosti.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dcosti Source Code dcosti.f90 Source Code subroutine dcosti ( n , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wsave ( * ) real ( dp ) :: dt , fk integer :: k , kc , nm1 , np1 , ns2 real ( dp ), parameter :: pi = acos ( - 1.0_dp ) if ( n <= 3 ) return nm1 = n - 1 np1 = n + 1 ns2 = n / 2 dt = pi / real ( nm1 , kind = dp ) fk = 0.0_dp do k = 2 , ns2 kc = np1 - k fk = fk + 1.0_dp wsave ( k ) = 2.0_dp * sin ( fk * dt ) wsave ( kc ) = 2.0_dp * cos ( fk * dt ) end do call dffti ( nm1 , wsave ( n + 1 )) end subroutine dcosti","tags":"","loc":"sourcefile/dcosti.f90.html"},{"title":"dsinti.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dsinti Source Code dsinti.f90 Source Code subroutine dsinti ( n , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wsave ( * ) real ( dp ) :: dt integer :: k , np1 , ns2 real ( dp ), parameter :: pi = acos ( - 1.0_dp ) if ( n <= 1 ) return ns2 = n / 2 np1 = n + 1 dt = pi / real ( np1 , dp ) do k = 1 , ns2 wsave ( k ) = 2.0_dp * sin ( k * dt ) end do call dffti ( np1 , wsave ( ns2 + 1 )) end subroutine dsinti","tags":"","loc":"sourcefile/dsinti.f90.html"},{"title":"passb.f90 – Fortran-lang/fftpack","text":"Contents Subroutines passb Source Code passb.f90 Source Code subroutine passb ( nac , ido , ip , l1 , idl1 , cc , c1 , c2 , ch , ch2 , wa ) use fftpack_kind , only : dp => rk implicit none integer , intent ( out ) :: nac integer , intent ( in ) :: ido , ip , l1 , idl1 real ( dp ), intent ( in ) :: cc ( ido , ip , l1 ), wa ( * ) real ( dp ), intent ( out ) :: c1 ( ido , l1 , ip ), c2 ( idl1 , ip ), ch ( ido , l1 , ip ) real ( dp ), intent ( inout ) :: ch2 ( idl1 , ip ) real ( dp ) :: wai , war integer :: i , idij , idj , idl , idlj , idot , idp , & ik , inc , ipp2 , ipph , j , jc , k , l , lc integer :: nt idot = ido / 2 nt = ip * idl1 ipp2 = ip + 2 ipph = ( ip + 1 ) / 2 idp = ip * ido ! if ( ido < l1 ) then do j = 2 , ipph jc = ipp2 - j do i = 1 , ido do k = 1 , l1 ch ( i , k , j ) = cc ( i , j , k ) + cc ( i , jc , k ) ch ( i , k , jc ) = cc ( i , j , k ) - cc ( i , jc , k ) end do end do end do do i = 1 , ido do k = 1 , l1 ch ( i , k , 1 ) = cc ( i , 1 , k ) end do end do else do j = 2 , ipph jc = ipp2 - j do k = 1 , l1 do i = 1 , ido ch ( i , k , j ) = cc ( i , j , k ) + cc ( i , jc , k ) ch ( i , k , jc ) = cc ( i , j , k ) - cc ( i , jc , k ) end do end do end do do k = 1 , l1 do i = 1 , ido ch ( i , k , 1 ) = cc ( i , 1 , k ) end do end do end if idl = 2 - ido inc = 0 do l = 2 , ipph lc = ipp2 - l idl = idl + ido do ik = 1 , idl1 c2 ( ik , l ) = ch2 ( ik , 1 ) + wa ( idl - 1 ) * ch2 ( ik , 2 ) c2 ( ik , lc ) = wa ( idl ) * ch2 ( ik , ip ) end do idlj = idl inc = inc + ido do j = 3 , ipph jc = ipp2 - j idlj = idlj + inc if ( idlj > idp ) idlj = idlj - idp war = wa ( idlj - 1 ) wai = wa ( idlj ) do ik = 1 , idl1 c2 ( ik , l ) = c2 ( ik , l ) + war * ch2 ( ik , j ) c2 ( ik , lc ) = c2 ( ik , lc ) + wai * ch2 ( ik , jc ) end do end do end do do j = 2 , ipph do ik = 1 , idl1 ch2 ( ik , 1 ) = ch2 ( ik , 1 ) + ch2 ( ik , j ) end do end do do j = 2 , ipph jc = ipp2 - j do ik = 2 , idl1 , 2 ch2 ( ik - 1 , j ) = c2 ( ik - 1 , j ) - c2 ( ik , jc ) ch2 ( ik - 1 , jc ) = c2 ( ik - 1 , j ) + c2 ( ik , jc ) ch2 ( ik , j ) = c2 ( ik , j ) + c2 ( ik - 1 , jc ) ch2 ( ik , jc ) = c2 ( ik , j ) - c2 ( ik - 1 , jc ) end do end do nac = 1 if ( ido == 2 ) return nac = 0 do ik = 1 , idl1 c2 ( ik , 1 ) = ch2 ( ik , 1 ) end do do j = 2 , ip do k = 1 , l1 c1 ( 1 , k , j ) = ch ( 1 , k , j ) c1 ( 2 , k , j ) = ch ( 2 , k , j ) end do end do if ( idot > l1 ) then idj = 2 - ido do j = 2 , ip idj = idj + ido do k = 1 , l1 idij = idj do i = 4 , ido , 2 idij = idij + 2 c1 ( i - 1 , k , j ) = wa ( idij - 1 ) * ch ( i - 1 , k , j ) - wa ( idij ) & * ch ( i , k , j ) c1 ( i , k , j ) = wa ( idij - 1 ) * ch ( i , k , j ) + wa ( idij ) & * ch ( i - 1 , k , j ) end do end do end do return end if idij = 0 do j = 2 , ip idij = idij + 2 do i = 4 , ido , 2 idij = idij + 2 do k = 1 , l1 c1 ( i - 1 , k , j ) = wa ( idij - 1 ) * ch ( i - 1 , k , j ) - wa ( idij ) * ch ( i , k , j ) c1 ( i , k , j ) = wa ( idij - 1 ) * ch ( i , k , j ) + wa ( idij ) * ch ( i - 1 , k , j ) end do end do end do return end subroutine passb","tags":"","loc":"sourcefile/passb.f90.html"},{"title":"fftpack_rfft.f90 – Fortran-lang/fftpack","text":"Contents Submodules fftpack_rfft Source Code fftpack_rfft.f90 Source Code submodule ( fftpack ) fftpack_rfft contains !> Forward transform of a real periodic sequence. pure module function rfft_rk ( x , n ) result ( result ) real ( kind = rk ), intent ( in ) :: x (:) integer , intent ( in ), optional :: n real ( kind = rk ), allocatable :: result (:) integer :: lenseq , lensav , i real ( kind = rk ), allocatable :: wsave (:) if ( present ( n )) then lenseq = n if ( lenseq <= size ( x )) then result = x (: lenseq ) else if ( lenseq > size ( x )) then result = [ x , ( 0.0_rk , i = 1 , lenseq - size ( x ))] end if else lenseq = size ( x ) result = x end if !> Initialize FFT lensav = 2 * lenseq + 15 allocate ( wsave ( lensav )) call dffti ( lenseq , wsave ) !> Forward transformation call dfftf ( lenseq , result , wsave ) end function rfft_rk end submodule fftpack_rfft","tags":"","loc":"sourcefile/fftpack_rfft.f90.html"},{"title":"dzfftb.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dzfftb Source Code dzfftb.f90 Source Code subroutine dzfftb ( n , r , azero , a , b , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: r ( * ) real ( dp ), intent ( inout ) :: wsave ( * ) real ( dp ), intent ( in ) :: azero , a ( * ), b ( * ) integer :: i , ns2 if ( n < 2 ) then r ( 1 ) = azero return elseif ( n == 2 ) then r ( 1 ) = azero + a ( 1 ) r ( 2 ) = azero - a ( 1 ) return else ns2 = ( n - 1 ) / 2 do i = 1 , ns2 r ( 2 * i ) = 0.5_dp * a ( i ) r ( 2 * i + 1 ) = - 0.5_dp * b ( i ) end do r ( 1 ) = azero if ( mod ( n , 2 ) == 0 ) r ( n ) = a ( ns2 + 1 ) call dfftb ( n , r , wsave ( n + 1 )) end if end subroutine dzfftb","tags":"","loc":"sourcefile/dzfftb.f90.html"},{"title":"dfftf.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dfftf Source Code dfftf.f90 Source Code subroutine dfftf ( n , r , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: r ( * ) real ( dp ), intent ( inout ) :: wsave ( * ) if ( n == 1 ) return call rfftf1 ( n , r , wsave , wsave ( n + 1 ), wsave ( 2 * n + 1 )) end subroutine dfftf","tags":"","loc":"sourcefile/dfftf.f90.html"},{"title":"radf5.f90 – Fortran-lang/fftpack","text":"Contents Subroutines radf5 Source Code radf5.f90 Source Code subroutine radf5 ( ido , l1 , cc , ch , wa1 , wa2 , wa3 , wa4 ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , l1 real ( dp ), intent ( in ) :: cc ( ido , l1 , 5 ), wa1 ( * ), wa2 ( * ), wa3 ( * ), wa4 ( * ) real ( dp ), intent ( out ) :: ch ( ido , 5 , l1 ) real ( dp ) :: ci2 , ci3 , ci4 , ci5 , cr2 , cr3 , & cr4 , cr5 , di2 , di3 , di4 , di5 , dr2 , dr3 , & dr4 , dr5 real ( dp ) :: ti2 , ti3 , ti4 , ti5 , tr2 , tr3 , & tr4 , tr5 integer :: i , ic , idp2 , k real ( dp ), parameter :: pi = acos ( - 1.0_dp ) real ( dp ), parameter :: tr11 = cos ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti11 = sin ( 2.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: tr12 = cos ( 4.0_dp * pi / 5.0_dp ) real ( dp ), parameter :: ti12 = sin ( 4.0_dp * pi / 5.0_dp ) do k = 1 , l1 cr2 = cc ( 1 , k , 5 ) + cc ( 1 , k , 2 ) ci5 = cc ( 1 , k , 5 ) - cc ( 1 , k , 2 ) cr3 = cc ( 1 , k , 4 ) + cc ( 1 , k , 3 ) ci4 = cc ( 1 , k , 4 ) - cc ( 1 , k , 3 ) ch ( 1 , 1 , k ) = cc ( 1 , k , 1 ) + cr2 + cr3 ch ( ido , 2 , k ) = cc ( 1 , k , 1 ) + tr11 * cr2 + tr12 * cr3 ch ( 1 , 3 , k ) = ti11 * ci5 + ti12 * ci4 ch ( ido , 4 , k ) = cc ( 1 , k , 1 ) + tr12 * cr2 + tr11 * cr3 ch ( 1 , 5 , k ) = ti12 * ci5 - ti11 * ci4 end do if ( ido == 1 ) return idp2 = ido + 2 do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i dr2 = wa1 ( i - 2 ) * cc ( i - 1 , k , 2 ) + wa1 ( i - 1 ) * cc ( i , k , 2 ) di2 = wa1 ( i - 2 ) * cc ( i , k , 2 ) - wa1 ( i - 1 ) * cc ( i - 1 , k , 2 ) dr3 = wa2 ( i - 2 ) * cc ( i - 1 , k , 3 ) + wa2 ( i - 1 ) * cc ( i , k , 3 ) di3 = wa2 ( i - 2 ) * cc ( i , k , 3 ) - wa2 ( i - 1 ) * cc ( i - 1 , k , 3 ) dr4 = wa3 ( i - 2 ) * cc ( i - 1 , k , 4 ) + wa3 ( i - 1 ) * cc ( i , k , 4 ) di4 = wa3 ( i - 2 ) * cc ( i , k , 4 ) - wa3 ( i - 1 ) * cc ( i - 1 , k , 4 ) dr5 = wa4 ( i - 2 ) * cc ( i - 1 , k , 5 ) + wa4 ( i - 1 ) * cc ( i , k , 5 ) di5 = wa4 ( i - 2 ) * cc ( i , k , 5 ) - wa4 ( i - 1 ) * cc ( i - 1 , k , 5 ) cr2 = dr2 + dr5 ci5 = dr5 - dr2 cr5 = di2 - di5 ci2 = di2 + di5 cr3 = dr3 + dr4 ci4 = dr4 - dr3 cr4 = di3 - di4 ci3 = di3 + di4 ch ( i - 1 , 1 , k ) = cc ( i - 1 , k , 1 ) + cr2 + cr3 ch ( i , 1 , k ) = cc ( i , k , 1 ) + ci2 + ci3 tr2 = cc ( i - 1 , k , 1 ) + tr11 * cr2 + tr12 * cr3 ti2 = cc ( i , k , 1 ) + tr11 * ci2 + tr12 * ci3 tr3 = cc ( i - 1 , k , 1 ) + tr12 * cr2 + tr11 * cr3 ti3 = cc ( i , k , 1 ) + tr12 * ci2 + tr11 * ci3 tr5 = ti11 * cr5 + ti12 * cr4 ti5 = ti11 * ci5 + ti12 * ci4 tr4 = ti12 * cr5 - ti11 * cr4 ti4 = ti12 * ci5 - ti11 * ci4 ch ( i - 1 , 3 , k ) = tr2 + tr5 ch ( ic - 1 , 2 , k ) = tr2 - tr5 ch ( i , 3 , k ) = ti2 + ti5 ch ( ic , 2 , k ) = ti5 - ti2 ch ( i - 1 , 5 , k ) = tr3 + tr4 ch ( ic - 1 , 4 , k ) = tr3 - tr4 ch ( i , 5 , k ) = ti3 + ti4 ch ( ic , 4 , k ) = ti4 - ti3 end do end do end subroutine radf5","tags":"","loc":"sourcefile/radf5.f90.html"},{"title":"fftpack_ifft.f90 – Fortran-lang/fftpack","text":"Contents Submodules fftpack_ifft Source Code fftpack_ifft.f90 Source Code submodule ( fftpack ) fftpack_ifft contains !> Backward transform of a complex periodic sequence. pure module function ifft_rk ( x , n ) result ( result ) complex ( kind = rk ), intent ( in ) :: x (:) integer , intent ( in ), optional :: n complex ( kind = rk ), allocatable :: result (:) integer :: lenseq , lensav , i real ( kind = rk ), allocatable :: wsave (:) if ( present ( n )) then lenseq = n if ( lenseq <= size ( x )) then result = x (: lenseq ) else if ( lenseq > size ( x )) then result = [ x , (( 0.0_rk , 0.0_rk ), i = 1 , lenseq - size ( x ))] end if else lenseq = size ( x ) result = x end if !> Initialize FFT lensav = 4 * lenseq + 15 allocate ( wsave ( lensav )) call zffti ( lenseq , wsave ) !> Backward transformation call zfftb ( lenseq , result , wsave ) end function ifft_rk end submodule fftpack_ifft","tags":"","loc":"sourcefile/fftpack_ifft.f90.html"},{"title":"cosqb1.f90 – Fortran-lang/fftpack","text":"Contents Subroutines cosqb1 Source Code cosqb1.f90 Source Code subroutine cosqb1 ( n , x , w , xh ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: x ( * ) real ( dp ), intent ( in ) :: w ( * ) real ( dp ), intent ( out ) :: xh ( * ) integer :: i , k , kc , modn , np2 , ns2 real ( dp ) :: xim1 ns2 = ( n + 1 ) / 2 np2 = n + 2 do i = 3 , n , 2 xim1 = x ( i - 1 ) + x ( i ) x ( i ) = x ( i ) - x ( i - 1 ) x ( i - 1 ) = xim1 end do x ( 1 ) = x ( 1 ) + x ( 1 ) modn = mod ( n , 2 ) if ( modn == 0 ) x ( n ) = x ( n ) + x ( n ) call dfftb ( n , x , xh ) do k = 2 , ns2 kc = np2 - k xh ( k ) = w ( k - 1 ) * x ( kc ) + w ( kc - 1 ) * x ( k ) xh ( kc ) = w ( k - 1 ) * x ( k ) - w ( kc - 1 ) * x ( kc ) end do if ( modn == 0 ) x ( ns2 + 1 ) = w ( ns2 ) * ( x ( ns2 + 1 ) + x ( ns2 + 1 )) do k = 2 , ns2 kc = np2 - k x ( k ) = xh ( k ) + xh ( kc ) x ( kc ) = xh ( k ) - xh ( kc ) end do x ( 1 ) = x ( 1 ) + x ( 1 ) end subroutine cosqb1","tags":"","loc":"sourcefile/cosqb1.f90.html"},{"title":"dcosqf.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dcosqf Source Code dcosqf.f90 Source Code subroutine dcosqf ( n , x , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( in ) :: wsave ( * ) real ( dp ), intent ( inout ) :: x ( * ) real ( dp ) :: tsqx real ( dp ), parameter :: sqrt2 = sqrt ( 2.0_dp ) if ( n < 2 ) then return elseif ( n == 2 ) then tsqx = sqrt2 * x ( 2 ) x ( 2 ) = x ( 1 ) - tsqx x ( 1 ) = x ( 1 ) + tsqx else call cosqf1 ( n , x , wsave , wsave ( n + 1 )) end if end subroutine dcosqf","tags":"","loc":"sourcefile/dcosqf.f90.html"},{"title":"cosqf1.f90 – Fortran-lang/fftpack","text":"Contents Subroutines cosqf1 Source Code cosqf1.f90 Source Code subroutine cosqf1 ( n , x , w , xh ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: x ( * ) real ( dp ), intent ( in ) :: w ( * ) real ( dp ), intent ( out ) :: xh ( * ) integer :: i , k , kc , modn , np2 , ns2 real ( dp ) :: xim1 ns2 = ( n + 1 ) / 2 np2 = n + 2 do k = 2 , ns2 kc = np2 - k xh ( k ) = x ( k ) + x ( kc ) xh ( kc ) = x ( k ) - x ( kc ) end do modn = mod ( n , 2 ) if ( modn == 0 ) xh ( ns2 + 1 ) = x ( ns2 + 1 ) + x ( ns2 + 1 ) do k = 2 , ns2 kc = np2 - k x ( k ) = w ( k - 1 ) * xh ( kc ) + w ( kc - 1 ) * xh ( k ) x ( kc ) = w ( k - 1 ) * xh ( k ) - w ( kc - 1 ) * xh ( kc ) end do if ( modn == 0 ) x ( ns2 + 1 ) = w ( ns2 ) * xh ( ns2 + 1 ) call dfftf ( n , x , xh ) do i = 3 , n , 2 xim1 = x ( i - 1 ) - x ( i ) x ( i ) = x ( i - 1 ) + x ( i ) x ( i - 1 ) = xim1 end do end subroutine cosqf1","tags":"","loc":"sourcefile/cosqf1.f90.html"},{"title":"fftpack.f90 – Fortran-lang/fftpack","text":"Contents Modules fftpack Source Code fftpack.f90 Source Code module fftpack use fftpack_kind implicit none private public :: zffti , zfftf , zfftb public :: fft , ifft public :: fftshift , ifftshift public :: fftfreq , rfftfreq public :: dffti , dfftf , dfftb public :: rfft , irfft public :: dzffti , dzfftf , dzfftb public :: dcosqi , dcosqf , dcosqb public :: dcosti , dcost public :: dct , idct public :: dct_t1i , dct_t1 public :: dct_t23i , dct_t2 , dct_t3 public :: dsinti , dsint public :: rk interface !> Version: experimental !> !> Initialize `zfftf` and `zfftb`. !> ([Specification](../page/specs/fftpack.html#zffti)) pure subroutine zffti ( n , wsave ) import rk integer , intent ( in ) :: n real ( kind = rk ), intent ( out ) :: wsave ( * ) end subroutine zffti !> Version: experimental !> !> Forward transform of a complex periodic sequence. !> ([Specification](../page/specs/fftpack.html#zfftf)) pure subroutine zfftf ( n , c , wsave ) import rk integer , intent ( in ) :: n complex ( kind = rk ), intent ( inout ) :: c ( * ) real ( kind = rk ), intent ( in ) :: wsave ( * ) end subroutine zfftf !> Version: experimental !> !> Unnormalized inverse of `zfftf`. !> ([Specification](../page/specs/fftpack.html#zfftb)) pure subroutine zfftb ( n , c , wsave ) import rk integer , intent ( in ) :: n complex ( kind = rk ), intent ( inout ) :: c ( * ) real ( kind = rk ), intent ( in ) :: wsave ( * ) end subroutine zfftb !> Version: experimental !> !> Initialize `dfftf` and `dfftb`. !> ([Specification](../page/specs/fftpack.html#dffti)) pure subroutine dffti ( n , wsave ) import rk integer , intent ( in ) :: n real ( kind = rk ), intent ( out ) :: wsave ( * ) end subroutine dffti !> Version: experimental !> !> Forward transform of a real periodic sequence. !> ([Specification](../page/specs/fftpack.html#dfftf)) pure subroutine dfftf ( n , r , wsave ) import rk integer , intent ( in ) :: n real ( kind = rk ), intent ( inout ) :: r ( * ) real ( kind = rk ), intent ( in ) :: wsave ( * ) end subroutine dfftf !> Version: experimental !> !> Unnormalized inverse of `dfftf`. !> ([Specification](../page/specs/fftpack.html#dfftb)) pure subroutine dfftb ( n , r , wsave ) import rk integer , intent ( in ) :: n real ( kind = rk ), intent ( inout ) :: r ( * ) real ( kind = rk ), intent ( in ) :: wsave ( * ) end subroutine dfftb !> Version: experimental !> !> Initialize `dzfftf` and `dzfftb`. !> ([Specification](../page/specs/fftpack.html#dzffti)) pure subroutine dzffti ( n , wsave ) import rk integer , intent ( in ) :: n real ( kind = rk ), intent ( out ) :: wsave ( * ) end subroutine dzffti !> Version: experimental !> !> Simplified forward transform of a real periodic sequence. !> ([Specification](../page/specs/fftpack.html#dzfftf)) pure subroutine dzfftf ( n , r , azero , a , b , wsave ) import rk integer , intent ( in ) :: n real ( kind = rk ), intent ( in ) :: r ( * ) real ( kind = rk ), intent ( out ) :: azero real ( kind = rk ), intent ( out ) :: a ( * ), b ( * ) real ( kind = rk ), intent ( in ) :: wsave ( * ) end subroutine dzfftf !> Version: experimental !> !> Unnormalized inverse of `dzfftf`. !> ([Specification](../page/specs/fftpack.html#dzfftb)) pure subroutine dzfftb ( n , r , azero , a , b , wsave ) import rk integer , intent ( in ) :: n real ( kind = rk ), intent ( out ) :: r ( * ) real ( kind = rk ), intent ( in ) :: azero real ( kind = rk ), intent ( in ) :: a ( * ), b ( * ) real ( kind = rk ), intent ( in ) :: wsave ( * ) end subroutine dzfftb !> Version: experimental !> !> Initialize `dcosqf` and `dcosqb`. !> ([Specification](../page/specs/fftpack.html#initialize-dct-2-3-dcosqi-or-dct_t23i)) pure subroutine dcosqi ( n , wsave ) import rk integer , intent ( in ) :: n real ( kind = rk ), intent ( out ) :: wsave ( * ) end subroutine dcosqi !> Version: experimental !> !> Forward transform of quarter wave data. !> ([Specification](../page/specs/fftpack.html#compute-dct-3-dcosqf-or-dct_t3)) pure subroutine dcosqf ( n , x , wsave ) import rk integer , intent ( in ) :: n real ( kind = rk ), intent ( inout ) :: x ( * ) real ( kind = rk ), intent ( in ) :: wsave ( * ) end subroutine dcosqf !> Version: experimental !> !> Unnormalized inverse of `dcosqf`. !> ([Specification](../page/specs/fftpack.html#compute-dct-2-dcosqb-or-dct_t2)) pure subroutine dcosqb ( n , x , wsave ) import rk integer , intent ( in ) :: n real ( kind = rk ), intent ( inout ) :: x ( * ) real ( kind = rk ), intent ( in ) :: wsave ( * ) end subroutine dcosqb !> Version: experimental !> !> Initialize `dcost`. !> ([Specification](../page/specs/fftpack.html#initialize-dct-1-dcosti-or-dct_t1i)) pure subroutine dcosti ( n , wsave ) import rk integer , intent ( in ) :: n real ( kind = rk ), intent ( out ) :: wsave ( * ) end subroutine dcosti !> Version: experimental !> !> Discrete fourier cosine transform of an even sequence. !> ([Specification](../page/specs/fftpack.html#compute-dct-1-dcost-or-dct_t1)) pure subroutine dcost ( n , x , wsave ) import rk integer , intent ( in ) :: n real ( kind = rk ), intent ( inout ) :: x ( * ) real ( kind = rk ), intent ( in ) :: wsave ( * ) end subroutine dcost pure subroutine dsinti ( n , wsave ) import rk integer , intent ( in ) :: n real ( kind = rk ), intent ( out ) :: wsave ( * ) end subroutine dsinti pure subroutine dsint ( n , x , wsave ) import rk integer , intent ( in ) :: n real ( kind = rk ), intent ( inout ) :: x ( * ) real ( kind = rk ), intent ( in ) :: wsave ( * ) end subroutine dsint !> Version: experimental !> !> Integer frequency values involved in complex FFT. !> ([Specifiction](../page/specs/fftpack.html#fftfreq)) pure module function fftfreq ( n ) result ( out ) integer , intent ( in ) :: n integer , dimension ( n ) :: out end function fftfreq !> Version: experimental !> !> Integer frequency values involved in real FFT. !> ([Specifiction](../page/specs/fftpack.html#rfftfreq)) pure module function rfftfreq ( n ) result ( out ) integer , intent ( in ) :: n integer , dimension ( n ) :: out end function rfftfreq end interface !> Version: experimental !> !> Forward transform of a complex periodic sequence. !> ([Specifiction](../page/specs/fftpack.html#fft)) interface fft pure module function fft_rk ( x , n ) result ( result ) complex ( kind = rk ), intent ( in ) :: x (:) integer , intent ( in ), optional :: n complex ( kind = rk ), allocatable :: result (:) end function fft_rk end interface fft !> Version: experimental !> !> Backward transform of a complex periodic sequence. !> ([Specifiction](../page/specs/fftpack.html#ifft)) interface ifft pure module function ifft_rk ( x , n ) result ( result ) complex ( kind = rk ), intent ( in ) :: x (:) integer , intent ( in ), optional :: n complex ( kind = rk ), allocatable :: result (:) end function ifft_rk end interface ifft !> Version: experimental !> !> Forward transform of a real periodic sequence. !> ([Specifiction](../page/specs/fftpack.html#rfft)) interface rfft pure module function rfft_rk ( x , n ) result ( result ) real ( kind = rk ), intent ( in ) :: x (:) integer , intent ( in ), optional :: n real ( kind = rk ), allocatable :: result (:) end function rfft_rk end interface rfft !> Version: experimental !> !> Backward transform of a real periodic sequence. !> ([Specifiction](../page/specs/fftpack.html#irfft)) interface irfft pure module function irfft_rk ( x , n ) result ( result ) real ( kind = rk ), intent ( in ) :: x (:) integer , intent ( in ), optional :: n real ( kind = rk ), allocatable :: result (:) end function irfft_rk end interface irfft !> Version: experimental !> !> Dsicrete cosine transforms. !> ([Specification](../page/specs/fftpack.html#simplified-dct-of-types-1-2-3-dct)) interface dct pure module function dct_rk ( x , n , type ) result ( result ) real ( kind = rk ), intent ( in ) :: x (:) integer , intent ( in ), optional :: n integer , intent ( in ), optional :: type real ( kind = rk ), allocatable :: result (:) end function dct_rk end interface dct !> Version: experimental !> !> Inverse discrete cosine transforms. !> ([Specification](../page/specs/fftpack.html#simplified-inverse-dct-of-types-1-2-3-idct)) interface idct pure module function idct_rk ( x , n , type ) result ( result ) real ( kind = rk ), intent ( in ) :: x (:) integer , intent ( in ), optional :: n integer , intent ( in ), optional :: type real ( kind = rk ), allocatable :: result (:) end function idct_rk end interface idct !> Version: experimental !> !> Initialize DCT type-1 !> ([Specification](../page/specs/fftpack.html#initialize-dct-1-dcosti-or-dct_t1i)) interface dct_t1i procedure :: dcosti end interface dct_t1i !> Version: experimental !> !> Perform DCT type-1 !> ([Specification](../page/specs/fftpack.html#compute-dct-1-dcost-or-dct_t1)) interface dct_t1 procedure :: dcost end interface dct_t1 !> Version: experimental !> !> Initialize DCT types 2, 3 !> ([Specification](../page/specs/fftpack.html#initialize-dct-2-3-dcosqi-or-dct_t23i)) interface dct_t23i procedure :: dcosqi end interface dct_t23i !> Version: experimental !> !> Perform DCT type-2 !> ([Specification](../page/specs/fftpack.html#compute-dct-2-dcosqb-or-dct_t2)) interface dct_t2 procedure :: dcosqb end interface dct_t2 !> Version: experimental !> !> Perform DCT type-3 !> ([Specification](../page/specs/fftpack.html#compute-dct-3-dcosqf-or-dct_t3)) interface dct_t3 procedure :: dcosqf end interface dct_t3 !> Version: experimental !> !> Shifts zero-frequency component to center of spectrum. !> ([Specifiction](../page/specs/fftpack.html#fftshift)) interface fftshift pure module function fftshift_crk ( x ) result ( result ) complex ( kind = rk ), intent ( in ) :: x (:) complex ( kind = rk ), dimension ( size ( x )) :: result end function fftshift_crk pure module function fftshift_rrk ( x ) result ( result ) real ( kind = rk ), intent ( in ) :: x (:) real ( kind = rk ), dimension ( size ( x )) :: result end function fftshift_rrk end interface fftshift !> Version: experimental !> !> Shifts zero-frequency component to beginning of spectrum. !> ([Specifiction](../page/specs/fftpack.html#ifftshift)) interface ifftshift pure module function ifftshift_crk ( x ) result ( result ) complex ( kind = rk ), intent ( in ) :: x (:) complex ( kind = rk ), dimension ( size ( x )) :: result end function ifftshift_crk pure module function ifftshift_rrk ( x ) result ( result ) real ( kind = rk ), intent ( in ) :: x (:) real ( kind = rk ), dimension ( size ( x )) :: result end function ifftshift_rrk end interface ifftshift end module fftpack","tags":"","loc":"sourcefile/fftpack.f90.html"},{"title":"rk.f90 – Fortran-lang/fftpack","text":"Contents Modules fftpack_kind Source Code rk.f90 Source Code module fftpack_kind use , intrinsic :: iso_fortran_env , only : rk => real64 implicit none ( type , external ) end module fftpack_kind","tags":"","loc":"sourcefile/rk.f90.html"},{"title":"fftpack_ifftshift.f90 – Fortran-lang/fftpack","text":"Contents Submodules fftpack_ifftshift Source Code fftpack_ifftshift.f90 Source Code submodule ( fftpack ) fftpack_ifftshift contains !> Shifts zero-frequency component to beginning of spectrum for `complex` type. pure module function ifftshift_crk ( x ) result ( result ) complex ( kind = rk ), intent ( in ) :: x (:) complex ( kind = rk ), dimension ( size ( x )) :: result result = cshift ( x , shift =- ceiling ( 0.5_rk * size ( x ))) end function ifftshift_crk !> Shifts zero-frequency component to beginning of spectrum for `real` type. pure module function ifftshift_rrk ( x ) result ( result ) real ( kind = rk ), intent ( in ) :: x (:) real ( kind = rk ), dimension ( size ( x )) :: result result = cshift ( x , shift =- ceiling ( 0.5_rk * size ( x ))) end function ifftshift_rrk end submodule fftpack_ifftshift","tags":"","loc":"sourcefile/fftpack_ifftshift.f90.html"},{"title":"dsint.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dsint Source Code dsint.f90 Source Code subroutine dsint ( n , x , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: x ( * ) real ( dp ), intent ( in ) :: wsave ( * ) integer :: iw1 , iw2 , iw3 , np1 np1 = n + 1 iw1 = n / 2 + 1 iw2 = iw1 + np1 iw3 = iw2 + np1 call sint1 ( n , x , wsave , wsave ( iw1 ), wsave ( iw2 ), wsave ( iw3 )) end subroutine dsint","tags":"","loc":"sourcefile/dsint.f90.html"},{"title":"rffti1.f90 – Fortran-lang/fftpack","text":"Contents Subroutines rffti1 Source Code rffti1.f90 Source Code subroutine rffti1 ( n , wa , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( out ) :: wa ( * ) integer , intent ( out ) :: ifac ( * ) real ( dp ) :: arg , argh , argld , fi integer :: i , ib , ido , ii , ip , ipm , is , j , k1 , l1 , & l2 , ld , nf , nfm1 , nl , nq , nr , ntry integer , dimension ( 4 ), parameter :: ntryh = [ 4 , 2 , 3 , 5 ] real ( dp ), parameter :: tpi = 2.0_dp * acos ( - 1.0_dp ) ! 2 * pi nl = n nf = 0 j = 0 100 j = j + 1 if ( j <= 4 ) then ntry = ntryh ( j ) else ntry = ntry + 2 end if 200 nq = nl / ntry nr = nl - ntry * nq if ( nr /= 0 ) goto 100 nf = nf + 1 ifac ( nf + 2 ) = ntry nl = nq if ( ntry == 2 ) then if ( nf /= 1 ) then do i = 2 , nf ib = nf - i + 2 ifac ( ib + 2 ) = ifac ( ib + 1 ) end do ifac ( 3 ) = 2 end if end if if ( nl /= 1 ) goto 200 ifac ( 1 ) = n ifac ( 2 ) = nf argh = tpi / real ( n , dp ) is = 0 nfm1 = nf - 1 l1 = 1 if ( nfm1 == 0 ) return do k1 = 1 , nfm1 ip = ifac ( k1 + 2 ) ld = 0 l2 = l1 * ip ido = n / l2 ipm = ip - 1 do j = 1 , ipm ld = ld + l1 i = is argld = real ( ld , dp ) * argh fi = 0.0_dp do ii = 3 , ido , 2 i = i + 2 fi = fi + 1.0_dp arg = fi * argld wa ( i - 1 ) = cos ( arg ) wa ( i ) = sin ( arg ) end do is = is + ido end do l1 = l2 end do end subroutine rffti1","tags":"","loc":"sourcefile/rffti1.f90.html"},{"title":"radbg.f90 – Fortran-lang/fftpack","text":"Contents Subroutines radbg Source Code radbg.f90 Source Code subroutine radbg ( ido , ip , l1 , idl1 , cc , c1 , c2 , ch , ch2 , wa ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: ido , ip , l1 , idl1 real ( dp ), intent ( in ) :: cc ( ido , ip , l1 ), wa ( * ) real ( dp ), intent ( inout ) :: c1 ( ido , l1 , ip ), ch2 ( idl1 , ip ) real ( dp ), intent ( out ) :: c2 ( idl1 , ip ), ch ( ido , l1 , ip ) real ( dp ) :: ai1 , ai2 , ar1 , ar1h , ar2 , ar2h , arg , & dc2 , dcp , ds2 , dsp integer :: i , ic , idij , idp2 , ik , ipp2 , & ipph , is , j , j2 , jc , k , l , lc , nbd real ( dp ), parameter :: tpi = 2 * acos ( - 1.0_dp ) ! 2 * pi arg = tpi / real ( ip , dp ) dcp = cos ( arg ) dsp = sin ( arg ) idp2 = ido + 2 nbd = ( ido - 1 ) / 2 ipp2 = ip + 2 ipph = ( ip + 1 ) / 2 if ( ido < l1 ) then do i = 1 , ido do k = 1 , l1 ch ( i , k , 1 ) = cc ( i , 1 , k ) end do end do else do k = 1 , l1 do i = 1 , ido ch ( i , k , 1 ) = cc ( i , 1 , k ) end do end do end if do j = 2 , ipph jc = ipp2 - j j2 = j + j do k = 1 , l1 ch ( 1 , k , j ) = cc ( ido , j2 - 2 , k ) + cc ( ido , j2 - 2 , k ) ch ( 1 , k , jc ) = cc ( 1 , j2 - 1 , k ) + cc ( 1 , j2 - 1 , k ) end do end do if ( ido /= 1 ) then if ( nbd < l1 ) then do j = 2 , ipph jc = ipp2 - j do i = 3 , ido , 2 ic = idp2 - i do k = 1 , l1 ch ( i - 1 , k , j ) = cc ( i - 1 , 2 * j - 1 , k ) + cc ( ic - 1 , 2 * j - 2 , k ) ch ( i - 1 , k , jc ) = cc ( i - 1 , 2 * j - 1 , k ) - cc ( ic - 1 , 2 * j - 2 , k ) ch ( i , k , j ) = cc ( i , 2 * j - 1 , k ) - cc ( ic , 2 * j - 2 , k ) ch ( i , k , jc ) = cc ( i , 2 * j - 1 , k ) + cc ( ic , 2 * j - 2 , k ) end do end do end do else do j = 2 , ipph jc = ipp2 - j do k = 1 , l1 do i = 3 , ido , 2 ic = idp2 - i ch ( i - 1 , k , j ) = cc ( i - 1 , 2 * j - 1 , k ) + cc ( ic - 1 , 2 * j - 2 , k ) ch ( i - 1 , k , jc ) = cc ( i - 1 , 2 * j - 1 , k ) - cc ( ic - 1 , 2 * j - 2 , k ) ch ( i , k , j ) = cc ( i , 2 * j - 1 , k ) - cc ( ic , 2 * j - 2 , k ) ch ( i , k , jc ) = cc ( i , 2 * j - 1 , k ) + cc ( ic , 2 * j - 2 , k ) end do end do end do end if end if ar1 = 1.0_dp ai1 = 0.0_dp do l = 2 , ipph lc = ipp2 - l ar1h = dcp * ar1 - dsp * ai1 ai1 = dcp * ai1 + dsp * ar1 ar1 = ar1h do ik = 1 , idl1 c2 ( ik , l ) = ch2 ( ik , 1 ) + ar1 * ch2 ( ik , 2 ) c2 ( ik , lc ) = ai1 * ch2 ( ik , ip ) end do dc2 = ar1 ds2 = ai1 ar2 = ar1 ai2 = ai1 do j = 3 , ipph jc = ipp2 - j ar2h = dc2 * ar2 - ds2 * ai2 ai2 = dc2 * ai2 + ds2 * ar2 ar2 = ar2h do ik = 1 , idl1 c2 ( ik , l ) = c2 ( ik , l ) + ar2 * ch2 ( ik , j ) c2 ( ik , lc ) = c2 ( ik , lc ) + ai2 * ch2 ( ik , jc ) end do end do end do do j = 2 , ipph do ik = 1 , idl1 ch2 ( ik , 1 ) = ch2 ( ik , 1 ) + ch2 ( ik , j ) end do end do do j = 2 , ipph jc = ipp2 - j do k = 1 , l1 ch ( 1 , k , j ) = c1 ( 1 , k , j ) - c1 ( 1 , k , jc ) ch ( 1 , k , jc ) = c1 ( 1 , k , j ) + c1 ( 1 , k , jc ) end do end do if ( ido /= 1 ) then if ( nbd < l1 ) then do j = 2 , ipph jc = ipp2 - j do i = 3 , ido , 2 do k = 1 , l1 ch ( i - 1 , k , j ) = c1 ( i - 1 , k , j ) - c1 ( i , k , jc ) ch ( i - 1 , k , jc ) = c1 ( i - 1 , k , j ) + c1 ( i , k , jc ) ch ( i , k , j ) = c1 ( i , k , j ) + c1 ( i - 1 , k , jc ) ch ( i , k , jc ) = c1 ( i , k , j ) - c1 ( i - 1 , k , jc ) end do end do end do else do j = 2 , ipph jc = ipp2 - j do k = 1 , l1 do i = 3 , ido , 2 ch ( i - 1 , k , j ) = c1 ( i - 1 , k , j ) - c1 ( i , k , jc ) ch ( i - 1 , k , jc ) = c1 ( i - 1 , k , j ) + c1 ( i , k , jc ) ch ( i , k , j ) = c1 ( i , k , j ) + c1 ( i - 1 , k , jc ) ch ( i , k , jc ) = c1 ( i , k , j ) - c1 ( i - 1 , k , jc ) end do end do end do end if end if if ( ido == 1 ) return do ik = 1 , idl1 c2 ( ik , 1 ) = ch2 ( ik , 1 ) end do do j = 2 , ip do k = 1 , l1 c1 ( 1 , k , j ) = ch ( 1 , k , j ) end do end do if ( nbd > l1 ) then is = - ido do j = 2 , ip is = is + ido do k = 1 , l1 idij = is do i = 3 , ido , 2 idij = idij + 2 c1 ( i - 1 , k , j ) = wa ( idij - 1 ) * ch ( i - 1 , k , j ) - wa ( idij ) & * ch ( i , k , j ) c1 ( i , k , j ) = wa ( idij - 1 ) * ch ( i , k , j ) + wa ( idij ) & * ch ( i - 1 , k , j ) end do end do end do else is = - ido do j = 2 , ip is = is + ido idij = is do i = 3 , ido , 2 idij = idij + 2 do k = 1 , l1 c1 ( i - 1 , k , j ) = wa ( idij - 1 ) * ch ( i - 1 , k , j ) - wa ( idij ) & * ch ( i , k , j ) c1 ( i , k , j ) = wa ( idij - 1 ) * ch ( i , k , j ) + wa ( idij ) & * ch ( i - 1 , k , j ) end do end do end do end if end subroutine radbg","tags":"","loc":"sourcefile/radbg.f90.html"},{"title":"dcosqb.f90 – Fortran-lang/fftpack","text":"Contents Subroutines dcosqb Source Code dcosqb.f90 Source Code subroutine dcosqb ( n , x , wsave ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n real ( dp ), intent ( in ) :: wsave ( * ) real ( dp ), intent ( inout ) :: x ( * ) real ( dp ) :: x1 real ( dp ), parameter :: tsqrt2 = 2.0_dp * sqrt ( 2.0_dp ) if ( n < 2 ) then x ( 1 ) = 4.0_dp * x ( 1 ) return elseif ( n == 2 ) then x1 = 4.0_dp * ( x ( 1 ) + x ( 2 )) x ( 2 ) = tsqrt2 * ( x ( 1 ) - x ( 2 )) x ( 1 ) = x1 return else call cosqb1 ( n , x , wsave , wsave ( n + 1 )) end if end subroutine dcosqb","tags":"","loc":"sourcefile/dcosqb.f90.html"},{"title":"cfftb1.f90 – Fortran-lang/fftpack","text":"Contents Subroutines cfftb1 Source Code cfftb1.f90 Source Code subroutine cfftb1 ( n , c , ch , wa , ifac ) use fftpack_kind , only : dp => rk implicit none integer , intent ( in ) :: n , ifac ( * ) real ( dp ), intent ( in ) :: wa ( * ) real ( dp ), intent ( inout ) :: c ( * ), ch ( * ) integer :: i , idl1 , ido , idot , ip , iw , ix2 , ix3 , ix4 , & k1 , l1 , l2 , n2 , na , nac , nf nf = ifac ( 2 ) na = 0 l1 = 1 iw = 1 do k1 = 1 , nf ip = ifac ( k1 + 2 ) l2 = ip * l1 ido = n / l2 idot = ido + ido idl1 = idot * l1 if ( ip == 4 ) then ix2 = iw + idot ix3 = ix2 + idot if ( na /= 0 ) then call passb4 ( idot , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 )) else call passb4 ( idot , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 )) end if na = 1 - na elseif ( ip == 2 ) then if ( na /= 0 ) then call passb2 ( idot , l1 , ch , c , wa ( iw )) else call passb2 ( idot , l1 , c , ch , wa ( iw )) end if na = 1 - na elseif ( ip == 3 ) then ix2 = iw + idot if ( na /= 0 ) then call passb3 ( idot , l1 , ch , c , wa ( iw ), wa ( ix2 )) else call passb3 ( idot , l1 , c , ch , wa ( iw ), wa ( ix2 )) end if na = 1 - na elseif ( ip /= 5 ) then if ( na /= 0 ) then call passb ( nac , idot , ip , l1 , idl1 , ch , ch , ch , c , c , wa ( iw )) else call passb ( nac , idot , ip , l1 , idl1 , c , c , c , ch , ch , wa ( iw )) end if if ( nac /= 0 ) na = 1 - na else ix2 = iw + idot ix3 = ix2 + idot ix4 = ix3 + idot if ( na /= 0 ) then call passb5 ( idot , l1 , ch , c , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) else call passb5 ( idot , l1 , c , ch , wa ( iw ), wa ( ix2 ), wa ( ix3 ), wa ( ix4 )) end if na = 1 - na end if l1 = l2 iw = iw + ( ip - 1 ) * idot end do if ( na == 0 ) return n2 = n + n do i = 1 , n2 c ( i ) = ch ( i ) end do end subroutine cfftb1","tags":"","loc":"sourcefile/cfftb1.f90.html"},{"title":"Contributing and specs – Fortran-lang/fftpack","text":"Warning This page is currently under construction!","tags":"","loc":"page/index.html"},{"title":"Specifications (specs) – Fortran-lang/fftpack","text":"Fortran fftpack Specifications (specs) Fortran fftpack Specifications (specs) Experimental Features & Modules Released/Stable Features & Modules Experimental Features & Modules fftpack - fftpack module. fftpack_kind - fftpack_kind module. Released/Stable Features & Modules (None yet)","tags":"","loc":"page/specs/index.html"},{"title":"FFTPACK – Fortran-lang/fftpack","text":"Discrete Fourier transform (DFT) of complex data zffti Description Status Class Syntax Argument Warning Example zfftf Description Status Class Syntax Argument Warning Example zfftb Description Status Class Syntax Argument Warning Example fft Description Status Class Syntax Argument Return value Notes Example ifft Description Status Class Syntax Argument Return value Example Discrete Fourier transform (DFT) of real data dffti Description Status Class Syntax Argument Warning Example dfftf Description Status Class Syntax Argument Warning Example dfftb Description Status Class Syntax Argument Warning Example rfft Description Status Class Syntax Argument Return value Notes Example irfft Description Status Class Syntax Argument Return value Example Simplified discrete Fourier transform (DFT) of real data dzffti Description Status Class Syntax Arguments Warning Example dzfftf Description Status Class Syntax Arguments Example dzfftb Description Status Class Syntax Arguments Example Discrete cosine transforms (DCT) DCT type-1 (DCT-1) Initialize DCT-1: dcosti or dct_t1i Description Status Class Syntax Arguments Example Compute DCT-1: dcost or dct_t1 Description Status Class Syntax Arguments Example DCT of types 2, 3 (DCT-2, 3), a.k.a \"Quarter\" cosine transforms Initialize DCT-2, 3: dcosqi or dct_t23i Description Status Class Syntax Arguments Example Compute DCT-3: dcosqf or dct_t3 Description Status Class Syntax Arguments Example Compute DCT-2: dcosqb or dct_t2 Description Status Class Syntax Arguments Example Simplified DCT of types 1, 2, 3: dct Description Status Class Syntax Argument Return value Notes Example Simplified inverse DCT of types 1, 2, 3: idct Description Status Class Syntax Argument Return value Notes Example References Utility functions fftshift Description Status Class Syntax Argument Return value Example ifftshift Description Status Class Syntax Argument Return value Example fftfreq Description Status Class Syntax Argument Return value Example rfftfreq Description Status Class Syntax Argument Return value Example Discrete Fourier transform (DFT) of complex data zffti Description Initializes the array wsave which is used in both zfftf and zfftb . The prime factorization of n together with a tabulation of the trigonometric functions are computed and\nstored in wsave . Status Experimental. Class Pure subroutine. Syntax call zffti (n, wsave) Argument n : Shall be an integer scalar.\nThis argument is intent(in) . The length of the sequence to be transformed. wsave : Shall be a real array.\nThis argument is intent(out) . A work array which must be dimensioned at least 4*n+15 .\nThe same work array can be used for both zfftf and zfftb as long as n remains unchanged. Different wsave arrays\nare required for different values of n . Warning The contents of wsave must not be changed between calls of zfftf or zfftb . Example program demo_zffti use fftpack , only : zffti complex ( kind = 8 ) :: x ( 4 ) = [ 1.0 , 2.0 , 3.0 , 4.0 ] real ( kind = 8 ) :: w ( 31 ) call zffti ( 4 , w ) end program demo_zffti zfftf Description Computes the forward complex discrete fourier transform (the fourier analysis). Equivalently, zfftf computes the fourier coefficients of a complex periodic sequence.\nThe transform is defined below at output parameter c . The transform is not normalized. To obtain a normalized transform the output must be divided by n . Otherwise a call of zfftf followed by a call of zfftb will multiply the sequence by n . The array wsave which is used by subroutine zfftf must be initialized by calling subroutine zffti(n,wsave) . Status Experimental. Class Pure subroutine. Syntax call zfftf (n, c, wsave) Argument n : Shall be an integer scalar.\nThis argument is intent(in) . The length of the complex sequence c . The method is more efficient when n is the product of small primes. c : Shall be a complex and rank-1 array.\nThis argument is intent(inout) . A complex array of length n which contains the sequence. for j = 1 ,..., n c ( j ) = the sum from k = 1 ,..., n of c ( k ) * exp ( - i * ( j - 1 ) * ( k - 1 ) * 2 * pi / n ) where i = sqrt ( - 1 ) wsave : Shall be a real array.\nThis argument is intent(in) . A real work array which must be dimensioned at least 4n+15 in the program that calls zfftf .\nThe wsave array must be initialized by calling subroutine zffti(n,wsave) and a different wsave array must be used for each different value of n . This initialization does not have to be repeated so long as n remains unchanged thus subsequent transforms can be obtained faster than the first.\nThe same wsave array can be used by zfftf and zfftb . Contains initialization calculations which must not be destroyed between calls of subroutine zfftf or zfftb . Warning The contents of wsave must not be changed between calls of zfftf or zfftb . Example program demo_zfftf use fftpack , only : zffti , zfftf complex ( kind = 8 ) :: x ( 4 ) real ( kind = 8 ) :: w ( 31 ) x = [ real ( kind = 8 ) :: 1.0 , 2.0 , 3.0 , 4.0 ] call zffti ( 4 , w ) call zfftf ( 4 , x , w ) !! `x` returns [(10.0,0.0), (-2.0,2.0), (-2.0,0.0), (-2.0,-2.0)]. end program demo_zfftf zfftb Description Unnormalized inverse of zfftf . Computes the backward complex discrete fourier transform (the fourier synthesis).\nEquivalently, zfftb computes a complex periodic sequence from its fourier coefficients.\nThe transform is defined below at output parameter c . The transform is not normalized. to obtain a normalized transform the output must be divided by n . Otherwise a call of zfftf followed by a call of zfftb will multiply the sequence by n . The array wsave which is used by subroutine zfftf must be initialized by calling subroutine zffti(n,wsave) . Status Experimental. Class Pure subroutine. Syntax call zfftb (n, c, wsave) Argument n : Shall be an integer scalar.\nThis argument is intent(in) . The length of the complex sequence c . The method is more efficient when n is the product of small primes. c : Shall be a complex array.\nThis argument is intent(inout) . A complex array of length n which contains the sequence. for j = 1 ,..., n c ( j ) = the sum from k = 1 ,..., n of c ( k ) * exp ( - i * ( j - 1 ) * ( k - 1 ) * 2 * pi / n ) where i = sqrt ( - 1 ) wsave : Shall be a real array.\nThis argument is intent(in) . A real work array which must be dimensioned at least 4n+15 in the program that calls zfftf . The wsave array must be initialized by calling subroutine zffti(n,wsave) and a different wsave array must be used for each different value of n . This initialization does not have to be repeated so long as n remains unchanged thus subsequent transforms can be obtained faster than the first. The same wsave array can be used by zfftf and zfftb . Contains initialization calculations which must not be destroyed between calls of subroutine zfftf or zfftb . Warning The contents of wsave must not be changed between calls of zfftf or zfftb . Example program demo_zfftb use fftpack , only : zffti , zfftf , zfftb complex ( kind = 8 ) :: x ( 4 ) real ( kind = 8 ) :: w ( 31 ) x = [ real ( kind = 8 ) :: 1.0 , 2.0 , 3.0 , 4.0 ] call zffti ( 4 , w ) call zfftf ( 4 , x , w ) !! `x` returns [(10.0,0.0), (-2.0,2.0), (-2.0,0.0), (-2.0,-2.0)]. call zfftb ( 4 , x , w ) !! `x` returns [(4.0,0.0), (8.0,0.0), (12.0,0.0), (16.0,0.0)]. end program demo_zfftb fft Description Computes the forward complex discrete fourier transform (the fourier analysis). Status Experimental. Class Pure function. Syntax result = fft (x [, n]) Argument x : Shall be a complex and rank-1 array.\nThis argument is intent(in) . n : Shall be an integer scalar.\nThis argument is intent(in) and optional . Defines the length of the Fourier transform. If n is not specified (the default) then n = size(x) . If n <= size(x) , x is truncated, if n > size(x) , x is zero-padded. Return value Returns a complex and rank-1 array, the Discrete Fourier Transform (DFT) of x . Notes Within numerical accuracy, x == ifft(fft(x))/size(x) . Example program demo_fft use fftpack , only : fft complex ( kind = 8 ) :: x ( 4 ) x = [ real ( kind = 8 ) :: 1.0 , 2.0 , 3.0 , 4.0 ] print * , fft ( x ) !! [(10.0,0.0), (-2.0,2.0), (-2.0,0.0), (-2.0,-2.0)]. print * , fft ( x , 3 ) !! [(6.0,0.0), (-1.5,0.86), (-1.5,0.86)]. print * , fft ( x , 5 ) !! [(10.0,0.0), (-4.0,1.3), (1.5,-2.1), (1.5,2.1), (-4.0,1.3)]. end program demo_fft ifft Description Unnormalized inverse of fft . Status Experimental. Class Pure function. Syntax result = ifft (x [, n]) Argument x : Shall be a complex and rank-1 array.\nThis argument is intent(in) . n : Shall be an integer scalar.\nThis argument is intent(in) and optional . Defines the length of the Fourier transform. If n is not specified (the default) then n = size(x) . If n <= size(x) , x is truncated, if n > size(x) , x is zero-padded. Return value Returns a complex and rank-1 array, the unnormalized inverse Discrete Fourier Transform (DFT) of x . Example program demo_ifft use fftpack , only : fft , ifft complex ( kind = 8 ) :: x ( 4 ) = [ 1.0 , 2.0 , 3.0 , 4.0 ] print * , ifft ( fft ( x )) / 4.0 !! [(1.0,0.0), (2.0,0.0), (3.0,0.0), (4.0,0.0)] print * , ifft ( fft ( x ), 3 ) !! [(6.0,2.0), (10.3,-1.0), (13.73,-1.0)] end program demo_ifft Discrete Fourier transform (DFT) of real data dffti Description Initializes the array wsave which is used in both dfftf and dfftb . The prime factorization of n together with a tabulation of the trigonometric functions are computed and\nstored in wsave . Status Experimental. Class Pure subroutine. Syntax call dffti (n, wsave) Argument n : Shall be an integer scalar.\nThis argument is intent(in) . The length of the sequence to be transformed. wsave : Shall be a real array.\nThis argument is intent(out) . A work array which must be dimensioned at least 2*n+15 .\nThe same work array can be used for both dfftf and dfftb as long as n remains unchanged.\nDifferent wsave arrays are required for different values of n . Warning The contents of wsave must not be changed between calls of dfftf or dfftb . Example program demo_dffti use fftpack , only : dffti real ( kind = 8 ) :: x ( 4 ) = [ 1.0 , 2.0 , 3.0 , 4.0 ] real ( kind = 8 ) :: w ( 23 ) call dffti ( 4 , w ) end program demo_dffti dfftf Description Computes the fourier coefficients of a real perodic sequence (fourier analysis).\nThe transform is defined below at output parameter r . The transform is not normalized. To obtain a normalized transform the output must be divided by n . Otherwise a call of dfftf followed by a call of dfftb will multiply the sequence by n . The array wsave which is used by subroutine dfftf must be initialized by calling subroutine dffti(n,wsave) . Status Experimental. Class Pure subroutine. Syntax call dfftf (n, r, wsave) Argument n : Shall be an integer scalar.\nThis argument is intent(in) . The length of the real sequence r . The method is more efficient when n is the product of small primes. n may change so long as different work arrays are provided. r : Shall be a real array.\nThis argument is intent(inout) . A real array of length n which contains the sequence. r ( 1 ) = the sum from i = 1 to i = n of r ( i ) if n is even set l = n / 2 , if n is odd set l = ( n + 1 ) / 2 then for k = 2 ,..., l r ( 2 * k - 2 ) = the sum from i = 1 to i = n of r ( i ) * cos (( k - 1 ) * ( i - 1 ) * 2 * pi / n ) r ( 2 * k - 1 ) = the sum from i = 1 to i = n of - r ( i ) * sin (( k - 1 ) * ( i - 1 ) * 2 * pi / n ) if n is even r ( n ) = the sum from i = 1 to i = n of ( - 1 ) ** ( i - 1 ) * r ( i ) wsave : Shall be a real array.\nThis argument is intent(in) . A real work array which must be dimensioned at least 4n+15 in the program that calls dfftf .\nThe wsave array must be initialized by calling subroutine dffti(n,wsave) and a different wsave array must be used for each different value of n . This initialization does not have to be repeated so long as n remains unchanged thus subsequent transforms can be obtained faster than the first.\nThe same wsave array can be used by dfftf and dfftb . Contains initialization calculations which must not be destroyed between calls of subroutine dfftf or dfftb . Warning The contents of wsave must not be changed between calls of dfftf or dfftb . Example program demo_dfftf use fftpack , only : dffti , dfftf real ( kind = 8 ) :: x ( 4 ) = [ 1 , 2 , 3 , 4 ] real ( kind = 8 ) :: w ( 23 ) call dffti ( 4 , w ) call dfftf ( 4 , x , w ) !! `x` returns [10.0, -2.0, 2.0, -2.0]. end program demo_dfftf dfftb Description Unnormalized inverse of dfftf . Computes the backward real discrete fourier transform (the fourier synthesis).\nEquivalently, dfftb computes a real periodic sequence from its fourier coefficients.\nThe transform is defined below at output parameter c . The transform is not normalized. To obtain a normalized transform the output must be divided by n . Otherwise a call of dfftf followed by a call of dfftb will multiply the sequence by n . The array wsave which is used by subroutine dfftf must be initialized by calling subroutine dffti(n,wsave) . Status Experimental. Class Pure subroutine. Syntax call dfftb (n, r, wsave) Argument n : Shall be an integer scalar.\nThis argument is intent(in) . The length of the real sequence r . The method is more efficient when n is the product of small primes. r : Shall be a real array.\nThis argument is intent(inout) . A real array of length n which contains the sequence. for n even and for i = 1 ,..., n r ( i ) = r ( 1 ) + ( - 1 ) ** ( i - 1 ) * r ( n ) plus the sum from k = 2 to k = n / 2 of 2 . * r ( 2 * k - 2 ) * cos (( k - 1 ) * ( i - 1 ) * 2 * pi / n ) - 2 . * r ( 2 * k - 1 ) * sin (( k - 1 ) * ( i - 1 ) * 2 * pi / n ) for n odd and for i = 1 ,..., n r ( i ) = r ( 1 ) plus the sum from k = 2 to k = ( n + 1 ) / 2 of 2 . * r ( 2 * k - 2 ) * cos (( k - 1 ) * ( i - 1 ) * 2 * pi / n ) - 2 . * r ( 2 * k - 1 ) * sin (( k - 1 ) * ( i - 1 ) * 2 * pi / n ) wsave : Shall be a real array.\nThis argument is intent(in) . A real work array which must be dimensioned at least 2n+15 in the program that calls dfftf . The wsave array must be initialized by calling subroutine dffti(n,wsave) and a different wsave array must be used for each different value of n . This initialization does not have to be repeated so long as n remains unchanged thus subsequent transforms can be obtained faster than the first. The same wsave array can be used by dfftf and dfftb . Contains initialization calculations which must not be destroyed between calls of subroutine dfftf or dfftb . Warning The contents of wsave must not be changed between calls of dfftf or dfftb . Example program demo_dfftb use fftpack , only : dffti , dfftf , dfftb real ( kind = 8 ) :: x ( 4 ) = [ 1 , 2 , 3 , 4 ] real ( kind = 8 ) :: w ( 31 ) call dffti ( 4 , w ) call dfftf ( 4 , x , w ) !! `x` returns [10.0, -2.0, 2.0, -2.0]. call dfftb ( 4 , x , w ) !! `x` returns [4.0, 8.0, 12.0, 16.0], which is not normalized. end program demo_dfftb rfft Description Discrete Fourier transform of a real sequence. Status Experimental. Class Pure function. Syntax result = rfft (x [, n]) Argument x : Shall be a real and rank-1 array.\nThis argument is intent(in) . The data to transform. n : Shall be an integer scalar.\nThis argument is intent(in) and optional . Defines the length of the Fourier transform. If n is not specified (the default) then n = size(x) . If n <= size(x) , x is truncated, if n > size(x) , x is zero-padded. Return value Returns a real and rank-1 array, the Discrete Fourier Transform (DFT) of x . Notes Within numerical accuracy, y == rfft(irfft(y))/size(y) . Example program demo_rfft use fftpack , only : rfft real ( kind = 8 ) :: x ( 4 ) = [ 1 , 2 , 3 , 4 ] print * , rfft ( x , 3 ) !! [6.0, -1.5, 0.87]. print * , rfft ( x ) !! [10.0, -2.0, 2.0, -2.0]. print * , rfft ( x , 5 ) !! [10.0, -4.0, -1.3, 1.5, -2.1]. end program demo_rfft irfft Description Unnormalized inverse of rfft . Status Experimental. Class Pure function. Syntax result = irfft (x [, n]) Argument x : Shall be a real array.\nThis argument is intent(in) .\nTransformed data to invert. n : Shall be an integer scalar.\nThis argument is intent(in) and optional . Defines the length of the Fourier transform. If n is not specified (the default) then n = size(x) . If n <= size(x) , x is truncated, if n > size(x) , x is zero-padded. Return value Returns a real and rank-1 array, the unnormalized inverse discrete Fourier transform. Example program demo_irfft use fftpack , only : rfft , irfft real ( kind = 8 ) :: x ( 4 ) = [ 1 , 2 , 3 , 4 ] print * , irfft ( rfft ( x )) / 4.0 !! [1.0, 2.0, 3.0, 4.0] print * , irfft ( rfft ( x ), 3 ) !! [6.0, 8.53, 15.46] end program demo_irfft Simplified discrete Fourier transform (DFT) of real data dzffti Description Initializes the array wsave which is used in both dzfftf and dzfftb .\nThe prime factorization of n together with a tabulation of the trigonometric functions are computed and stored in wsave . Status Experimental Class Prue function. Syntax call dzffti (n, wsave) Arguments n : Shall be an integer scalar.\nThis argument is intent(in) . The length of the sequence to be transformed. wsave : Shall be a real and rank-1 array.\nThis argument is intent(out) . A work array which must be dimensioned at least 3*n+15 .\nThe same work array can be used for both dzfftf and dzfftb as long as n remains unchanged.\nDifferent wsave arrays are required for different values of n . Warning The contents of wsave must not be changed between calls of dzfftf or dzfftb . Example program demo_dzffti use fftpack , only : dzffti real ( kind = 8 ) :: x ( 4 ) = [ 1 , 2 , 3 , 4 ] real ( kind = 8 ) :: w ( 3 * 4 + 15 ) call dzffti ( 4 , w ) !! Initializes the array `w` which is used in both `dzfftf` and `dzfftb`. end program demo_dzffti dzfftf Description Computes the fourier coefficients of a real perodic sequence (fourier analysis).\nThe transform is defined below at output parameters azero , a and b . dzfftf is a simplified but slower version of dfftf . Status Experimental Class Pure subroutine. Syntax call dzfftf (n, r, azero, a, b, wsave) Arguments n : Shall be an integer scalar.\nThis argument is intent(in) . The length of the array r to be transformed. The method is most efficient when n is the product of small primes. r : Shall be a real and rank-1 array.\nThis argument is intent(in) . A real array of length n which contains the sequence to be transformed. r is not destroyed. azero : Shall be a real scalar.\nThis argument is intent(out) . The sum from i=1 to i=n of r(i)/n . a , b : Shall be a real and rank-1 array.\nThis argument is intent(out) . for n even b ( n / 2 ) = 0 . and a ( n / 2 ) is the sum from i = 1 to i = n of ( - 1 ) ** ( i - 1 ) * r ( i ) / n for n even define kmax = n / 2 - 1 for n odd define kmax = ( n - 1 ) / 2 then for k = 1 ,..., kmax a ( k ) equals the sum from i = 1 to i = n of 2 . / n * r ( i ) * cos ( k * ( i - 1 ) * 2 * pi / n ) b ( k ) equals the sum from i = 1 to i = n of 2 . / n * r ( i ) * sin ( k * ( i - 1 ) * 2 * pi / n ) wsave : Shall be a real and rank-1 array.\nThis argument is intent(in) .\nA work array which must be dimensioned at least 3*n+15 .\nIn the program that calls dzfftf . The wsave array must be initialized by calling subroutine dzffti(n,wsave) and a different wsave array must be used for each different value of n .\nThis initialization does not have to be repeated so long as n remains unchanged thus subsequent transforms can be obtained faster than the first.\nThe same wsave array can be used by dzfftf and dzfftb . Example program demo_dzfftf use fftpack , only : dzffti , dzfftf real ( kind = 8 ) :: x ( 4 ) = [ 1 , 2 , 3 , 4 ] real ( kind = 8 ) :: w ( 3 * 4 + 15 ) real ( kind = 8 ) :: azero , a ( 4 / 2 ), b ( 4 / 2 ) call dzffti ( 4 , w ) call dzfftf ( 4 , x , azero , a , b , w ) !! `azero`: 2.5; `a`: [-1.0, -0.5]; `b`: [-1.0, -0.0] end program demo_dzfftf dzfftb Description Computes a real perodic sequence from its fourier coefficients (fourier synthesis).\nThe transform is defined below at output parameter r . dzfftb is a simplified but slower version of dfftb . Status Experimental Class Pure subroutine. Syntax call dzfftb (n, r, azero, a, b, wsave) Arguments n : Shall be an integer scalar.\nThis argument is intent(in) . The length of the output array r . The method is most efficient when n is the product of small primes. r : Shall be a real and rank-1 array.\nThis argument is intent(out) . if n is even define kmax = n / 2 if n is odd define kmax = ( n - 1 ) / 2 then for i = 1 ,..., n r ( i ) = azero plus the sum from k = 1 to k = kmax of a ( k ) * cos ( k * ( i - 1 ) * 2 * pi / n ) + b ( k ) * sin ( k * ( i - 1 ) * 2 * pi / n ) Complex notation: for j = 1 ,..., n r ( j ) equals the sum from k =- kmax to k = kmax of c ( k ) * exp ( i * k * ( j - 1 ) * 2 * pi / n ) where c ( k ) = . 5 * cmplx ( a ( k ) , - b ( k )) for k = 1 ,..., kmax c ( - k ) = conjg ( c ( k )) c ( 0 ) = azero and i = sqrt ( - 1 ) Amplitude - phase notation: for i = 1 ,..., n r ( i ) equals azero plus the sum from k = 1 to k = kmax of alpha ( k ) * cos ( k * ( i - 1 ) * 2 * pi / n + beta ( k )) where alpha ( k ) = sqrt ( a ( k ) * a ( k ) + b ( k ) * b ( k )) cos ( beta ( k )) = a ( k ) / alpha ( k ) sin ( beta ( k )) =- b ( k ) / alpha ( k ) azero : Shall be a real scalar.\nThis argument is intent(in) . The constant fourier coefficient. a , b : Shall be a real and rank-1 array.\nThis argument is intent(in) . Arrays which contain the remaining fourier coefficients these arrays are not destroyed.\nThe length of these arrays depends on whether n is even or odd. if n is even n / 2 locations are required if n is odd ( n - 1 ) / 2 locations are required wsave : Shall be a real and rank-1 array.\nThis argument is intent(in) .\nA work array which must be dimensioned at least 3*n+15 .\nIn the program that calls dzfftf . The wsave array must be initialized by calling subroutine dzffti(n,wsave) and a different wsave array must be used for each different value of n .\nThis initialization does not have to be repeated so long as n remains unchanged thus subsequent transforms can be obtained faster than the first.\nThe same wsave array can be used by dzfftf and dzfftb . Example program demo_dzfftb use fftpack , only : dzffti , dzfftf , dzfftb real ( kind = 8 ) :: x ( 4 ) = [ 1 , 2 , 3 , 4 ] real ( kind = 8 ) :: w ( 3 * 4 + 15 ) real ( kind = 8 ) :: azero , a ( 4 / 2 ), b ( 4 / 2 ) call dzffti ( 4 , w ) call dzfftf ( 4 , x , azero , a , b , w ) !! `azero`: 2.5; `a`: [-1.0, -0.5]; `b`: [-1.0, -0.0] x = 0.0 call dzfftb ( 4 , x , azero , a , b , w ) !! `x`: [1.0, 2.0, 3.0, 4.0] end program demo_dzfftb Discrete cosine transforms (DCT) DCT type-1 (DCT-1) Initialize DCT-1: dcosti or dct_t1i Description Initializes the array wsave which is used in subroutine dcost .\nThe prime factorization of n together with a tabulation of the trigonometric functions are computed and stored in wsave . The two procedures are completely equivalent and expect the same arguments.\nIt is a matter of personal preference which one you choose to use. Status Experimental Class Pure subroutine. Syntax call dcosti (n , wsave) Arguments n : Shall be a integer scalar.\nThis argument is intent(in) . The length of the sequence to be transformed. The method is most efficient when n-1 is a product of small primes. wsave : Shall be a real and rank-1 array.\nThis argument is intent(out) . A work array which must be dimensioned at least 3*n+15 .\nDifferent wsave arrays are required for different values of n .\nThe contents of wsave must not be changed between calls of dcost . Example program demo_dcosti use fftpack , only : dcosti real ( kind = 8 ) :: w ( 3 * 4 + 15 ) call dcosti ( 4 , w ) !! Initializes the array `w` which is used in subroutine `dcost`. end program demo_dcosti Compute DCT-1: dcost or dct_t1 Description Computes the DCT-1 of the input real data.\nThe transform is defined below at output parameter x . The two procedures are completely equivalent and expect the same arguments.\nIt is a matter of personal preference which one you choose to use. For real input data x of length n , the DCT-1 of x is equivalent, up to a\nscaling factor, to the DFT of the even extension of x with length 2*(n-1) ,\nwhere the first and last entries of the original data are not repeated in the\nextension. For example, the DCT-1 of input data abcde (size ) is\nequivalent to the DFT of data abcdedcb (size ). Also, dcost is the unnormalized inverse of itself. This means that a call of dcost followed by another call of dcost will multiply the input sequence x by 2*(n-1) . The array wsave which is used by subroutine dcost must be initialized by calling subroutine dcosti(n,wsave) . Status Experimental Class Pure subroutine. Syntax call dcost (n, x, wsave) Arguments n : Shall be a integer scalar.\nThis argument is intent(in) . The length of the sequence x . n must be greater than 1 .\nThe method is most efficient when n-1 is a product of small primes. x : Shall be a real and rank-1 array.\nThis argument is intent(inout) .\nAn array which contains the sequence to be transformed, and is overwritten\nby the result. for i = 1 ,..., n x ( i ) = x ( 1 ) + ( - 1 ) ** ( i - 1 ) * x ( n ) + the sum from k = 2 to k = n - 1 2 * x ( k ) * cos (( k - 1 ) * ( i - 1 ) * pi / ( n - 1 )) a call of dcost followed by another call of dcost will multiply the sequence x by 2 * ( n - 1 ) hence dcost is the unnormalized inverse of itself . wsave : Shall be a real and rank-1 array.\nThis argument is intent(in) . A work array which must be of length at least 3*n+15 in the program that calls dcost .\nThe wsave array must be initialized by calling subroutine dcosti(n,wsave) and a different wsave array must be used for each different value of n .\nThis initialization does not have to be repeated so long as n remains unchanged thus subsequent\ntransforms can be obtained faster than the first.\nContains initialization calculations which must not be destroyed between calls of dcost . Example program demo_dcost use fftpack , only : dcosti , dcost real ( kind = 8 ) :: x ( 4 ) = [ 1 , 2 , 3 , 4 ] real ( kind = 8 ) :: w ( 3 * 4 + 15 ) call dcosti ( 4 , w ) call dcost ( 4 , x , w ) !! `x`: [15.0, -4.0, 0.0, -1.0] call dcost ( 4 , x , w ) !! `x`: [6.0, 12.0, 18.0, 24.0] end program demo_dcost DCT of types 2, 3 (DCT-2, 3), a.k.a \"Quarter\" cosine transforms Initialize DCT-2, 3: dcosqi or dct_t23i Description Initializes the array wsave which is used in both dcosqf and dcosqb .\nThe prime factorization of n together with\na tabulation of the trigonometric functions are computed and\nstored in wsave . The two procedures are completely equivalent and expect the same arguments.\nIt is a matter of personal preference which one you choose to use. Status Experimental Class Pure subroutine. Syntax call dcosqi (n, wsave) Arguments n : Shall be an integer scalar.\nThis argument is intent(in) . The length of the array to be transformed.\nThe method is most efficient when n is a product of small primes. wsave : Shall be a real and rank-1 array.\nThis argument is intent(out) . A work array which must be dimensioned at least 3*n+15 .\nThe same work array can be used for both dcosqf and dcosqb as long as n remains unchanged.\nDifferent wsave arrays are required for different values of n .\nThe contents of wsave must not be changed between calls of dcosqf or dcosqb . Example program demo_dcosqi use fftpack , only : dcosqi real ( kind = 8 ) :: w ( 3 * 4 + 15 ) call dcosqi ( 4 , w ) !! Initializes the array `w` which is used in both `dcosqf` and `dcosqb`. end program demo_dcosqi Compute DCT-3: dcosqf or dct_t3 Description Computes the DCT-3 of the input real data.\nThe transform is defined below at output parameter x . The two procedures are completely equivalent and expect the same arguments.\nIt is a matter of personal preference which one you choose to use. Also, dcosqf (DCT-3) is the unnormalized inverse of dcosqb (DCT-2), since a\ncall of dcosqf followed by a call of dcosqb will multiply the input sequence x by 4*n . The array wsave which is used by subroutine dcosqf must be initialized by calling subroutine dcosqi(n,wsave) . Status Experimental Class Pure subroutine. Syntax call dcosqf (n, x, wsave) Arguments n : Shall be an integer scalar.\nThis argument is intent(in) . The length of the array x to be transformed.\nThe method is most efficient when n is a product of small primes. x : Shall be a real and rank-1 array.\nThis argument is intent(inout) . An array which contains the sequence to be transformed, and is overwritten by\nthe result. for i = 1 ,..., n x ( i ) = x ( 1 ) plus the sum from k = 2 to k = n of 2 * x ( k ) * cos (( 2 * i - 1 ) * ( k - 1 ) * pi / ( 2 * n )) a call of dcosqf followed by a call of cosqb will multiply the sequence x by 4 * n . therefore dcosqb is the unnormalized inverse of dcosqf . wsave : Shall be a real and rank-1 array.\nThis argument is intent(in) . A work array which must be dimensioned at least 3*n+15 in the program that calls dcosqf .\nThe wsave array must be initialized by calling subroutine dcosqi(n,wsave) and a different wsave array must be used for each different value of n .\nThis initialization does not have to be repeated so long as n remains unchanged thus subsequent transforms can be obtained faster than the first. Warning : wsave contains initialization calculations which must not be\ndestroyed between calls of dcosqf or dcosqb of the same n . Example program demo_dcosqf use fftpack , only : dcosqi , dcosqf real ( kind = 8 ) :: w ( 3 * 4 + 15 ) real ( kind = 8 ) :: x ( 4 ) = [ 1 , 2 , 3 , 4 ] call dcosqi ( 4 , w ) call dcosqf ( 4 , x , w ) !! `x`: [12.0, -9.10, 2.62, -1.51] end program demo_dcosqf Compute DCT-2: dcosqb or dct_t2 Description Computes the DCT-2 of the input real data.\nThe transform is defined below at output parameter x . The two procedures are completely equivalent and expect the same arguments.\nIt is a matter of personal preference which one you choose to use. For real input data x of length n , the DCT-2 of x is equivalent, up to a\nscaling factor, to the DFT of the even extension of x with length 4*n ,\nwhere all the even-frequency entries are zero. Also, dcosqb (DCT-2) is the unnormalized inverse of dcosqf (DCT-3), since a\ncall of dcosqb followed by a call of dcosqf will multiply the input sequence x by 4*n . The array wsave which is used by subroutine dcosqb must be initialized by calling subroutine dcosqi(n,wsave) . Status Experimental Class Pure subroutine. Syntax call dcosqb (n, x, wsave) Arguments n : Shall be an integer scalar.\nThis argument is intent(in) . The length of the array x to be transformed.\nThe method is most efficient when n is a product of small primes. x : Shall be a real and rank-1 array.\nThis argument is intent(inout) . An array which contains the sequence to be transformed, and is overwritten by\nthe result. for i = 1 ,..., n x ( i ) = the sum from k = 1 to k = n of 4 * x ( k ) * cos (( 2 * k - 1 ) * ( i - 1 ) * pi / ( 2 * n )) a call of dcosqb followed by a call of dcosqf will multiply the sequence x by 4 * n . therefore dcosqf is the unnormalized inverse of dcosqb . wsave : Shall be a real and rank-1 array.\nThis argument is intent(in) . A work array which must be dimensioned at least 3*n+15 in the program that calls dcosqb .\nThe wsave array must be initialized by calling subroutine dcosqi(n,wsave) and a different wsave array must be used for each different value of n .\nThis initialization does not have to be repeated so long as n remains unchanged thus subsequent transforms can be obtained faster than the first. Warning : wsave contains initialization calculations which must not be\ndestroyed between calls of dcosqf or dcosqb of the same n . Example program demo_dcosqb use fftpack , only : dcosqi , dcosqf , dcosqb real ( kind = 8 ) :: w ( 3 * 4 + 15 ) real ( kind = 8 ) :: x ( 4 ) = [ 4 , 3 , 5 , 10 ] call dcosqi ( 4 , w ) call dcosqf ( 4 , x , w ) call dcosqb ( 4 , x , w ) !! [64.0, 48.0, 80.0, 160.0] end program demo_dcosqb Simplified DCT of types 1, 2, 3: dct Description Discrete cosine transforms (DCT) of types 1, 2, 3.\nThis is a more flexible interface for the DCT of types 1, 2 and 3, albeit\nslightly slower than the in-place DCT procedures. Status Experimental. Class Pure function. Syntax result = dct (x [, n, type]) Argument x : Shall be a real and rank-1 array.\nThis argument is intent(in) .\nThe data to transform. n : Shall be an integer scalar.\nThis argument is intent(in) and optional .\nDefines the length of the DCT. If n is not specified (the default) then n = size(x) . If n <= size(x) , x is truncated, if n > size(x) , x is zero-padded. type : Shall be an integer scalar, equal to 1 , 2 or 3 .\nThis argument is intent(in) and optional .\nDefines the type of DCT to be performed. The default type is 2 . Return value Returns a real and rank-1 array, the DCT type- t of the input data x . Notes Within numerical accuracy,\n- x == idct(dct(x, type=1), type=1) / (2*(size(x) - 1)) - x == idct(dct(x, type=2), type=2) / (4*size(x)) - x == idct(dct(x, type=3), type=3) / (4*size(x)) Example program demo_dct use fftpack , only : dct real ( kind = 8 ) :: x ( 4 ) = [ 1 , 2 , 3 , 4 ] print * , dct ( x , 3 , 1 ) !! [8.0, -2.0, 0.0]. print * , dct ( x , type = 1 ) !! [15.0, -4.0, 0.0, -1.0]. print * , dct ( x , 5 , 2 ) !! [14.36, -6.11, -5.0, 4.40, -2.65]. print * , dct ( dct ( x , type = 1 ), type = 1 ) / ( 2 * ( 4 - 1 )) !! (normalized): [1.0, 2.0, 3.0, 4.0] end program demo_dct Simplified inverse DCT of types 1, 2, 3: idct Description Unnormalized inverse discrete cosine transform (IDCT) of types 1, 2 and 3.\nThis is a more flexible interface for the IDCT of types 1, 2 and 3,\nalbeit slightly slower than the in-place DCT procedures. Status Experimental. Class Pure function. Syntax result = idct (x [, n, type]) Argument x : Shall be a real array.\nThis argument is intent(in) .\nTransformed data to invert. n : Shall be an integer scalar.\nThis argument is intent(in) and optional . Defines the length of the Fourier transform. If n is not specified (the default) then n = size(x) . If n <= size(x) , x is truncated, if n > size(x) , x is zero-padded. type : Shall be an integer scalar, equal to 1 or 2 .\nThis argument is intent(in) and optional .\nDefines the type of the IDCT to be performed. The default type is 2 . Return value Returns a real and rank-1 array, the IDCT type- t of the input data x . Notes Within numerical accuracy,\n- x == idct(dct(x, type=1), type=1) / (2*(size(x) - 1)) - x == idct(dct(x, type=2), type=2) / (4*size(x)) - x == idct(dct(x, type=3), type=3) / (4*size(x)) Example program demo_idct use fftpack , only : dct , idct real ( kind = 8 ) :: x ( 4 ) = [ 1 , 2 , 3 , 4 ] print * , idct ( dct ( x , type = 1 ), type = 1 ) / ( 2 * ( 4 - 1 )) !! (normalized):   [1.0, 2.0, 3.0, 4.0] print * , idct ( dct ( x , type = 2 ), type = 2 ) / ( 4 * 4 ) !! (normalized):   [1.0, 2.0, 3.0, 4.0] print * , idct ( dct ( x ), n = 3 ) !! (unnormalized): [22.06, 32.5, 65.65] end program demo_idct References [1] Wikipedia, \"Discrete cosine transform\", https://en.wikipedia.org/wiki/Discrete_cosine_transform Utility functions fftshift Description Rearranges the Fourier transform by moving the zero-frequency component to the center of the array. Status Experimental. Class Pure function. Syntax result = fftshift (x) Argument x : Shall be a complex/real and rank-1 array.\nThis argument is intent(in) . Return value Returns the complex/real and rank-1 Fourier transform by moving the zero-frequency component to the center of the array. Example program demo_fftshift use fftpack , only : fftshift complex ( kind = 8 ) :: c ( 5 ) = [ 1 , 2 , 3 , 4 , 5 ] real ( kind = 8 ) :: x ( 5 ) = [ 1 , 2 , 3 , 4 , 5 ] print * , fftshift ( c ( 1 : 4 )) !! [(3.0,0.0), (4.0,0.0), (1.0,0.0), (2.0,0.0)] print * , fftshift ( c ) !! [(4.0,0.0), (5.0,0.0), (1.0,0.0), (2.0,0.0), (3.0,0.0)] print * , fftshift ( x ( 1 : 4 )) !! [3.0, 4.0, 1.0, 2.0] print * , fftshift ( x ) !! [4.0, 5.0, 1.0, 2.0, 3.0] end program demo_fftshift ifftshift Description Rearranges the Fourier transform with zero frequency shifting back to the original transform output. In other words, ifftshift is the result of undoing fftshift . Status Experimental. Class Pure function. Syntax result = ifftshift (x) Argument x : Shall be a complex/real and rank-1 array.\nThis argument is intent(in) . Return value Returns the complex/real and rank-1 Fourier transform with zero frequency shifting back to the original transform output. Example program demo_ifftshift use fftpack , only : fftshift , ifftshift complex ( kind = 8 ) :: c ( 5 ) = [ 1 , 2 , 3 , 4 , 5 ] real ( kind = 8 ) :: x ( 5 ) = [ 1 , 2 , 3 , 4 , 5 ] print * , ifftshift ( fftshift ( c ( 1 : 4 ))) !! [(1.0,0.0), (2.0,0.0), (3.0,0.0), (4.0,0.0)] print * , ifftshift ( fftshift ( c ) ) !! [(1.0,0.0), (2.0,0.0), (3.0,0.0), (4.0,0.0), (5.0,0.0)] print * , ifftshift ( fftshift ( x ( 1 : 4 ))) !! [1.0, 2.0, 3.0, 4.0] print * , ifftshift ( fftshift ( x )) !! [1.0, 2.0, 3.0, 4.0, 5.0] end program demo_ifftshift fftfreq Description Returns the integer frequency (or wavenumber) values that correspond to the coefficients calculated by the complex discrete Fourier transform, in the standard order (zero frequency first). Status Experimental. Class Pure function. Syntax result = fftfreq (n) Argument n : Shall be an integer , equal to the length of the corresponding complex discrete Fourier transform.\nThis argument is intent(in) . Return value Returns the integer and rank-1 array of the transform's frequency values in the standard order (zero frequency first). Example program demo_fftfreq use fftpack , only : fftfreq print * , fftfreq ( 4 ) ! [0, 1, -2, -1] print * , fftfreq ( 5 ) ! [0, 1, 2, -2, -1] end program demo_fftfreq rfftfreq Description Returns the integer frequency (or wavenumber) values that correspond to the coefficients calculated by the real discrete Fourier transform, in the standard order (zero frequency first). Status Experimental. Class Pure function. Syntax result = rfftfreq (n) Argument n : Shall be an integer , equal to the length of the corresponding real discrete Fourier transform.\nThis argument is intent(in) . Return value Returns the integer and rank-1 array of the transform's frequency values in the standard order (zero frequency first). Example program demo_rfftfreq use fftpack , only : rfftfreq print * , rfftfreq ( 4 ) ! [0, 1, 1, -2] print * , rfftfreq ( 5 ) ! [0, 1, 1, 2, 2] end program demo_rfftfreq","tags":"","loc":"page/specs/fftpack.html"},{"title":"FFTPACK Kind – Fortran-lang/fftpack","text":"The fftpack_kind Module The fftpack_kind Module Introduction Constants provided by fftpack_kind Introduction The fftpack_kind module provides kind parameters for FFTs. Constants provided by fftpack_kind rk : Double precision real kind parameter . Provides real kind parameter for floating point numbers with a minimal precision of 15 significant digits.","tags":"","loc":"page/specs/fftpack_kind.html"}]}